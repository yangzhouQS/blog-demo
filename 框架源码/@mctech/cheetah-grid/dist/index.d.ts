// Generated by dts-bundle v0.7.3

declare module 'cheetah-grid' {
    import type * as TYPES from "cheetah-grid/ts-types";
    import * as columns from "cheetah-grid/columns";
    import * as core from "cheetah-grid/core";
    import * as data from "cheetah-grid/data";
    import * as headers from "cheetah-grid/headers";
    import * as register from "cheetah-grid/register";
    import * as themes from "cheetah-grid/themes";
    import * as tools from "cheetah-grid/tools";
    import { ColumnDefine, GroupHeaderDefine, HeaderDefine, HeadersDefine, ListGrid, ListGridConstructorOptions } from "cheetah-grid/ListGrid";
    import { GridCanvasHelper } from "cheetah-grid/GridCanvasHelper";
    export { getInternal as _getInternal } from "cheetah-grid/get-internal";
    /**
        * Cheetah Grid
        * @namespace cheetahGrid
        */
    export { 
    /**
        * Types
        * @namespace cheetahGrid.TYPES
        */
    TYPES, core, tools, ListGrid, ListGridConstructorOptions, HeadersDefine, ColumnDefine, HeaderDefine, GroupHeaderDefine, columns, headers, themes, data, GridCanvasHelper, getIcons, register, };
    /** @private */
    function getIcons(): {
            [key: string]: TYPES.IconDefine;
    };
    const _default: {
            core: typeof core;
            tools: typeof tools;
            ListGrid: typeof ListGrid;
            columns: typeof columns;
            headers: typeof headers;
            themes: typeof themes;
            data: typeof data;
            GridCanvasHelper: typeof GridCanvasHelper;
            register: typeof register;
            readonly icons: {
                    [key: string]: TYPES.IconDefine;
            };
    };
    export default _default;
}

declare module 'cheetah-grid/ts-types' {
    export * from "cheetah-grid/ts-types/base";
    export * from "cheetah-grid/ts-types/grid";
    export * from "cheetah-grid/ts-types/column";
    export * from "cheetah-grid/ts-types/events";
    export * from "cheetah-grid/ts-types/plugin";
    export * from "cheetah-grid/ts-types/define";
    export * from "cheetah-grid/ts-types/data";
    export * from "cheetah-grid/ts-types/grid-engine";
}

declare module 'cheetah-grid/columns' {
    import * as action from "cheetah-grid/columns/action";
    import * as style from "cheetah-grid/columns/style";
    import * as type from "cheetah-grid/columns/type";
    /**
      * columns
      * @namespace cheetahGrid.columns
      * @memberof cheetahGrid
      */
    export { action, type, style };
}

declare module 'cheetah-grid/core' {
    import { DrawGrid } from "cheetah-grid/core/DrawGrid";
    import { DG_EVENT_TYPE as EVENT_TYPE } from "cheetah-grid/core/DG_EVENT_TYPE";
    export { DrawGrid, EVENT_TYPE };
}

declare module 'cheetah-grid/data' {
    import { DataSource, DataSourceParam } from "cheetah-grid/data/DataSource";
    import { CachedDataSource } from "cheetah-grid/data/CachedDataSource";
    import { FilterDataSource } from "cheetah-grid/data/FilterDataSource";
    /**
      * data modules
      * @namespace cheetahGrid.data
      * @memberof cheetahGrid
      */
    export { DataSource, CachedDataSource, FilterDataSource, DataSourceParam, };
}

declare module 'cheetah-grid/headers' {
    import * as action from "cheetah-grid/header/action";
    import * as style from "cheetah-grid/header/style";
    import * as type from "cheetah-grid/header/type";
    /**
      * header classes
      * @namespace cheetahGrid.headers
      * @memberof cheetahGrid
      */
    export { action, type, style };
}

declare module 'cheetah-grid/register' {
    import type { IconDefine } from "cheetah-grid/ts-types";
    import type { Theme } from "cheetah-grid/themes/theme";
    export function theme(name: string, theme?: Theme): Theme;
    export function icon(name: string, icon?: IconDefine): IconDefine;
    export function icons(icons: {
        [key: string]: IconDefine;
    }): void;
}

declare module 'cheetah-grid/themes' {
    import { Theme } from "cheetah-grid/themes/theme";
    import type { ThemeDefine } from "cheetah-grid/ts-types";
    export const BASIC: Theme;
    export const MATERIAL_DESIGN: Theme;
    export const theme: {
        Theme: typeof Theme;
    };
    export function of(value: ThemeDefine | string | undefined | null): Theme | null;
    export function getDefault(): Theme;
    export function setDefault(defaultTheme: Theme): void;
    export function getChoices(): {
        [key: string]: Theme;
    };
}

declare module 'cheetah-grid/tools' {
    import * as canvashelper from "cheetah-grid/tools/canvashelper";
    /**
      * tools
      * @namespace cheetahGrid.tools
      * @memberof cheetahGrid
      */
    export { canvashelper };
}

declare module 'cheetah-grid/ListGrid' {
    import { DataSource } from "cheetah-grid/data";
    import type { CellAddress, CellContext, CellRange, ColumnTypeAPI, EventListenerId, FieldDef, HeaderValues, LayoutObjectId, ListGridAPI, ListGridEventHandlersEventMap, ListGridEventHandlersReturnMap, MaybePromise, MaybePromiseOrUndef, SetPasteValueTestData, SortState, ThemeDefine } from "cheetah-grid/ts-types";
    import { ColumnDefine, GroupHeaderDefine, HeaderDefine, HeadersDefine } from "cheetah-grid/list-grid/layout-map";
    import type { DrawGridConstructorOptions, DrawGridProtected } from "cheetah-grid/core/DrawGrid";
    import type { LayoutDefine, LayoutMapAPI } from "cheetah-grid/list-grid/layout-map";
    import { MessageHandler } from "cheetah-grid/columns/message/MessageHandler";
    import { DrawGrid } from "cheetah-grid/core/DrawGrid";
    import { GridCanvasHelper } from "cheetah-grid/GridCanvasHelper";
    import { LG_EVENT_TYPE } from "cheetah-grid/list-grid/LG_EVENT_TYPE";
    import type { Theme } from "cheetah-grid/themes/theme";
    import { TooltipHandler } from "cheetah-grid/tooltip/TooltipHandler";
    /** @private */
    const _: "$$$$protected symbol$$$$";
    /** @protected */
    interface ListGridProtected<T> extends DrawGridProtected {
            dataSourceEventIds?: EventListenerId[];
            headerEvents?: EventListenerId[];
            layoutMap: LayoutMapAPI<T>;
            headerValues?: HeaderValues;
            tooltipHandler: TooltipHandler<T>;
            messageHandler: MessageHandler<T>;
            theme: Theme | null;
            headerRowHeight: number[] | number;
            header: HeadersDefine<T>;
            layout: LayoutDefine<T>;
            gridCanvasHelper: GridCanvasHelper<T>;
            sortState: SortState;
            dataSource: DataSource<T>;
            records?: T[] | null;
            allowRangePaste: boolean;
    }
    export { ListGridProtected };
    export interface ListGridConstructorOptions<T> extends DrawGridConstructorOptions {
            /**
                * Simple header property
                */
            header?: HeadersDefine<T>;
            /**
                * Layout property
                */
            layout?: LayoutDefine<T>;
            /**
                * Header row height(s)
                */
            headerRowHeight?: number[] | number;
            /**
                * Records data source
                */
            dataSource?: DataSource<T>;
            /**
                * Simple records data
                */
            records?: T[];
            /**
                * Theme
                */
            theme?: ThemeDefine | string;
            /**
                * If set to true to allow pasting of ranges. default false
                */
            allowRangePaste?: boolean;
            /**
                * @deprecated Cannot be used with ListGrid.
                * @override
                */
            rowCount?: undefined;
            /**
                * @deprecated Cannot be used with ListGrid.
                * @override
                */
            colCount?: undefined;
            /**
                * @deprecated Cannot be used with ListGrid.
                * @override
                */
            frozenRowCount?: undefined;
    }
    export { HeadersDefine, ColumnDefine, HeaderDefine, GroupHeaderDefine };
    /**
        * ListGrid
        * @classdesc cheetahGrid.ListGrid
        * @memberof cheetahGrid
        */
    export class ListGrid<T> extends DrawGrid implements ListGridAPI<T> {
            protected [_]: ListGridProtected<T>;
            disabled: boolean;
            readOnly: boolean;
            static get EVENT_TYPE(): typeof LG_EVENT_TYPE;
            /**
                * constructor
                *
                * @constructor
                * @param options Constructor options
                */
            constructor(options?: ListGridConstructorOptions<T>);
            /**
                * Dispose the grid instance.
                * @returns {void}
                */
            dispose(): void;
            /**
                * Gets the define of the header.
                */
            get header(): HeadersDefine<T>;
            /**
                * Sets the define of the header with the given data.
                * <pre>
                * column options
                * -----
                * caption: header caption
                * field: field name
                * width: column width
                * minWidth: column min width
                * maxWidth: column max width
                * icon: icon name
                * message: message key name
                * columnType: column type
                * action: column action
                * style: column style
                * headerType: header type
                * headerStyle: header style
                * headerAction: header action
                * headerField: header field name
                * sort: define sort setting
                * -----
                *
                * multiline header
                * -----
                * caption: header caption
                * columns: columns define
                * -----
                * </pre>
                */
            set header(header: HeadersDefine<T>);
            /**
                * Gets the define of the layout.
                */
            get layout(): LayoutDefine<T>;
            /**
                * Sets the define of the layout with the given data.
                */
            set layout(layout: LayoutDefine<T>);
            /**
                * Get the row count per record
                */
            get recordRowCount(): number;
            /**
                * Get the records.
                */
            get records(): T[] | null;
            /**
                * Set the records from given
                */
            set records(records: T[] | null);
            /**
                * Get the data source.
                */
            get dataSource(): DataSource<T>;
            /**
                * Set the data source from given
                */
            set dataSource(dataSource: DataSource<T>);
            /**
                * Get the theme.
                */
            get theme(): Theme | null;
            /**
                * Set the theme from given
                */
            set theme(theme: Theme | null);
            /**
                * If set to true to allow pasting of ranges.
                */
            get allowRangePaste(): boolean;
            set allowRangePaste(allowRangePaste: boolean);
            /**
                * Get the font definition as a string.
                * @override
                */
            get font(): string;
            /**
                * Set the font definition with the given string.
                * @override
                */
            set font(font: string);
            /**
                * Get the background color of the underlay.
                * @override
                */
            get underlayBackgroundColor(): string;
            /**
                * Set the background color of the underlay.
                * @override
                */
            set underlayBackgroundColor(underlayBackgroundColor: string);
            /**
                * Get the sort state.
                */
            get sortState(): SortState;
            /**
                * Sets the sort state.
                * If `null` to set, the sort state is initialized.
                */
            set sortState(sortState: SortState);
            /**
                * Get the header values.
                */
            get headerValues(): HeaderValues;
            /**
                * Sets the header values.
                */
            set headerValues(headerValues: HeaderValues);
            /**
                * Get the field of the given column index.
                * @param  {number} col The column index.
                * @param  {number} row The row index.
                * @return {*} The field object.
                */
            getField(col: number, row: number): FieldDef<T> | undefined;
            /**
                * Get the column define of the given column index.
                * @param  {number} col The column index.
                * @param  {number} row The row index.
                * @return {*} The column define object.
                */
            getColumnDefine(col: number, row: number): ColumnDefine<T>;
            getColumnType(col: number, row: number): ColumnTypeAPI;
            /**
                * Get the header field of the given header cell.
                * @param  {number} col The column index.
                * @param  {number} row The header row index.
                * @return {*} The field object.
                */
            getHeaderField(col: number, row: number): any | undefined;
            /**
                * Get the header define of the given header cell.
                * @param  {number} col The column index.
                * @param  {number} row The header row index.
                * @return {*} The header define object.
                */
            getHeaderDefine(col: number, row: number): HeaderDefine<T>;
            /**
                * Get the record of the given row index.
                * @param  {number} row The row index.
                * @return {object} The record.
                */
            getRowRecord(row: number): MaybePromiseOrUndef<T>;
            /**
                * Get the record index of the given row index.
                * @param  {number} row The row index.
                */
            getRecordIndexByRow(row: number): number;
            /**
                * Gets the row index starting at the given record index.
                * @param  {number} index The record index.
                */
            getRecordStartRowByRecordIndex(index: number): number;
            /**
                * Get the column index of the given field.
                * @param  {*} field The field.
                * @return {number} The column index.
                * @deprecated use `getCellRangeByField` instead
                */
            getColumnIndexByField(field: FieldDef<T>): number | null;
            /**
                * Get the column index of the given field.
                * @param  {*} field The field.
                * @param  {number} index The record index
                * @return {number} The column index.
                */
            getCellRangeByField(field: FieldDef<T>, index: number): CellRange | null;
            /**
                * Focus the cell.
                * @param  {*} field The field.
                * @param  {number} index The record index
                * @return {void}
                */
            focusGridCell(field: FieldDef<T>, index: number): void;
            /**
                * Scroll to where cell is visible.
                * @param  {*} field The field.
                * @param  {number} index The record index
                * @return {void}
                */
            makeVisibleGridCell(field: FieldDef<T>, index: number): void;
            getGridCanvasHelper(): GridCanvasHelper<T>;
            /**
                * Get cell range information for a given cell.
                * @param {number} col column index of the cell
                * @param {number} row row index of the cell
                * @returns {object} cell range info
                */
            getCellRange(col: number, row: number): CellRange;
            /**
                * Get header range information for a given cell.
                * @param {number} col column index of the cell
                * @param {number} row row index of the cell
                * @returns {object} cell range info
                * @deprecated use `getCellRange` instead
                */
            getHeaderCellRange(col: number, row: number): CellRange;
            protected getCopyCellValue(col: number, row: number, range?: CellRange): string;
            protected onDrawCell(col: number, row: number, context: CellContext): MaybePromise<void>;
            doGetCellValue(col: number, row: number, valueCallback: (value: any) => void): boolean;
            doChangeValue(col: number, row: number, changeValueCallback: (before: any) => any): MaybePromise<boolean>;
            doSetPasteValue(text: string, test?: (data: SetPasteValueTestData<T>) => boolean): void;
            getHeaderValue(col: number, row: number): any | undefined;
            setHeaderValue(col: number, row: number, newValue: any): void;
            getLayoutCellId(col: number, row: number): LayoutObjectId;
            protected bindEventsInternal(): void;
            protected getMoveLeftColByKeyDownInternal({ col, row }: CellAddress): number;
            protected getMoveRightColByKeyDownInternal({ col, row, }: CellAddress): number;
            protected getMoveUpRowByKeyDownInternal({ col, row }: CellAddress): number;
            protected getMoveDownRowByKeyDownInternal({ col, row }: CellAddress): number;
            protected getOffsetInvalidateCells(): number;
            protected getCopyRangeInternal(range: CellRange): CellRange;
            fireListeners<TYPE extends keyof ListGridEventHandlersEventMap<T>>(type: TYPE, ...event: ListGridEventHandlersEventMap<T>[TYPE]): ListGridEventHandlersReturnMap[TYPE][];
    }
}

declare module 'cheetah-grid/GridCanvasHelper' {
    import * as canvashelper from "cheetah-grid/tools/canvashelper";
    import type { CellContext, ColorDef, ColorPropertyDefine, ColorsPropertyDefine, FontPropertyDefine, GridCanvasHelperAPI, LineClamp, ListGridAPI, RectProps, RequiredThemeDefine, TextOverflow } from "cheetah-grid/ts-types";
    import { InlineDrawer } from "cheetah-grid/element/InlineDrawer";
    import type { SimpleColumnIconOption } from "cheetah-grid/ts-types-internal";
    type ColorsDef = ColorDef | (ColorDef | null)[];
    export class GridCanvasHelper<T> implements GridCanvasHelperAPI {
        constructor(grid: ListGridAPI<T>);
        createCalculator(context: CellContext, font: string | undefined): {
            calcWidth(width: number | string): number;
            calcHeight(height: number | string): number;
        };
        getColor(color: ColorPropertyDefine, col: number, row: number, ctx: CanvasRenderingContext2D): ColorDef;
        getColor(color: ColorsPropertyDefine, col: number, row: number, ctx: CanvasRenderingContext2D): ColorsDef;
        toBoxArray(obj: ColorsDef): [ColorDef | null, ColorDef | null, ColorDef | null, ColorDef | null];
        toBoxPixelArray(value: number | string | (number | string)[], context: CellContext, font: string | undefined): [number, number, number, number];
        get theme(): RequiredThemeDefine;
        drawWithClip(context: CellContext, draw: (ctx: CanvasRenderingContext2D) => void): void;
        drawBorderWithClip(context: CellContext, draw: (ctx: CanvasRenderingContext2D) => void): void;
        text(text: string, context: CellContext, { padding, offset, color, textAlign, textBaseline, font, textOverflow, icons, }?: {
            padding?: number | string | (number | string)[];
            offset?: number;
            color?: ColorPropertyDefine;
            textAlign?: CanvasTextAlign;
            textBaseline?: CanvasTextBaseline;
            font?: FontPropertyDefine;
            textOverflow?: TextOverflow;
            icons?: SimpleColumnIconOption[];
        }): void;
        multilineText(multilines: string[], context: CellContext, { padding, offset, color, textAlign, textBaseline, font, lineHeight, autoWrapText, lineClamp, textOverflow, icons, }?: {
            padding?: number | string | (number | string)[];
            offset?: number;
            color?: ColorPropertyDefine;
            textAlign?: CanvasTextAlign;
            textBaseline?: CanvasTextBaseline;
            font?: FontPropertyDefine;
            lineHeight?: string | number;
            autoWrapText?: boolean;
            lineClamp?: LineClamp;
            textOverflow?: TextOverflow;
            icons?: SimpleColumnIconOption[];
        }): void;
        fillText(text: string, x: number, y: number, context: CellContext, { color, textAlign, textBaseline, font, }?: {
            color?: ColorPropertyDefine;
            textAlign?: CanvasTextAlign;
            textBaseline?: CanvasTextBaseline;
            font?: FontPropertyDefine;
        }): void;
        fillCell(context: CellContext, { fillColor, }?: {
            fillColor?: ColorPropertyDefine;
        }): void;
        fillCellWithState(context: CellContext, option?: {
            fillColor?: ColorPropertyDefine;
        }): void;
        fillRect(rect: RectProps, context: CellContext, { fillColor, }?: {
            fillColor?: ColorPropertyDefine;
        }): void;
        fillRectWithState(rect: RectProps, context: CellContext, option?: {
            fillColor?: ColorPropertyDefine;
        }): void;
        getFillColorState(context: CellContext, option?: {
            fillColor?: ColorPropertyDefine;
        }): ColorPropertyDefine;
        border(context: CellContext, { borderColor, lineWidth, }?: {
            borderColor?: ColorsPropertyDefine;
            lineWidth?: number;
        }): void;
        borderWithState(context: CellContext, option?: {
            borderColor?: ColorsPropertyDefine;
            lineWidth?: number;
        }): void;
        buildCheckBoxInline(check: boolean, context: CellContext, option?: {
            animElapsedTime?: number;
            uncheckBgColor?: ColorPropertyDefine;
            checkBgColor?: ColorPropertyDefine;
            borderColor?: ColorPropertyDefine;
            textAlign?: CanvasTextAlign;
            textBaseline?: CanvasTextBaseline;
        }): InlineDrawer;
        checkbox(check: boolean, context: CellContext, option?: {
            animElapsedTime?: number;
            uncheckBgColor?: ColorPropertyDefine;
            checkBgColor?: ColorPropertyDefine;
            borderColor?: ColorPropertyDefine;
            textAlign?: CanvasTextAlign;
            textBaseline?: CanvasTextBaseline;
        }): void;
        radioButton(check: boolean, context: CellContext, option?: {
            animElapsedTime?: number;
            checkColor?: ColorPropertyDefine;
            uncheckBorderColor?: ColorPropertyDefine;
            checkBorderColor?: ColorPropertyDefine;
            bgColor?: ColorPropertyDefine;
            textAlign?: CanvasTextAlign;
            textBaseline?: CanvasTextBaseline;
        }): void;
        button(caption: string, context: CellContext, { bgColor, padding, offset, color, textAlign, textBaseline, shadow, font, textOverflow, icons, }?: {
            bgColor?: ColorPropertyDefine;
            padding?: number | string | (number | string)[];
            offset?: number;
            color?: ColorPropertyDefine;
            textAlign?: CanvasTextAlign;
            textBaseline?: CanvasTextBaseline;
            shadow?: canvashelper.DrawButtonOption["shadow"];
            font?: FontPropertyDefine;
            textOverflow?: TextOverflow;
            icons?: SimpleColumnIconOption[];
        }): void;
        testFontLoad(font: string | undefined, value: string, context: CellContext): boolean;
    }
    export {};
}

declare module 'cheetah-grid/get-internal' {
    export function getInternal(): unknown;
}

declare module 'cheetah-grid/ts-types/base' {
    export type MaybeUndef<T> = T | undefined;
    export type PromiseOrUndef<T> = undefined | Promise<T | undefined>;
    export type PromiseMaybeUndef<T> = Promise<T | undefined>;
    export type MaybePromise<T> = T | Promise<T>;
    export type MaybeCall<T, A extends any[]> = T | ((...args: A) => T);
    export type MaybePromiseOrCall<T, A extends any[]> = T | Promise<T> | ((...args: A) => T);
    export type MaybePromiseOrUndef<T> = T | undefined | Promise<T | undefined>;
    export type MaybeCallOrUndef<T, A extends any[]> = undefined | T | ((...args: A) => T);
    export type MaybePromiseOrCallOrUndef<T, A extends any[]> = T | undefined | Promise<T | undefined> | ((...args: A) => T);
    export type PromiseMaybeUndefOrCall<T, A extends any[]> = Promise<T | undefined> | ((...args: A) => T);
    export type PromiseMaybeCallOrUndef<T, A extends any[]> = Promise<MaybeCallOrUndef<T, A>>;
    export type AnyFunction = (...args: any[]) => any;
    export interface RectProps {
        left: number;
        right: number;
        top: number;
        bottom: number;
        width: number;
        height: number;
    }
    export type ColorDef = CanvasRenderingContext2D["fillStyle"];
}

declare module 'cheetah-grid/ts-types/grid' {
    import type { MaybePromiseOrUndef } from "cheetah-grid/ts-types/base";
    export interface CellAddress {
        col: number;
        row: number;
    }
    export interface CellRange {
        start: CellAddress;
        end: CellAddress;
    }
    export type FieldGetter<T> = (record: T) => any;
    export type FieldSetter<T> = (record: T, value: any) => void;
    export interface FieldAssessor<T> {
        get: FieldGetter<T>;
        set: FieldSetter<T>;
    }
    export type FieldDef<T> = keyof T | FieldGetter<T> | FieldAssessor<T>;
    export type FieldData = MaybePromiseOrUndef<any>;
}

declare module 'cheetah-grid/ts-types/column' {
    export * from "cheetah-grid/ts-types/column/type";
    export * from "cheetah-grid/ts-types/column/style";
    export * from "cheetah-grid/ts-types/column/action";
}

declare module 'cheetah-grid/ts-types/events' {
    import type { CellAddress, CellRange, FieldDef } from "cheetah-grid/ts-types/grid";
    import type { AnyFunction } from "cheetah-grid/ts-types/base";
    export type KeyboardEventListener = (e: KeyboardEvent) => void;
    export type AnyListener = AnyFunction;
    export type EventListenerId = number;
    export type BeforeSelectedCellEvent = CellAddress & {
        selected: false;
        after: CellAddress;
    };
    export type AfterSelectedCellEvent = CellAddress & {
        selected: true;
        before: CellAddress;
    };
    export type SelectedCellEvent = BeforeSelectedCellEvent | AfterSelectedCellEvent;
    export type MouseCellEvent = CellAddress & {
        event: MouseEvent;
    };
    export type TouchCellEvent = CellAddress & {
        event: TouchEvent;
    };
    export type KeydownEvent = {
        keyCode: number;
        event: KeyboardEvent;
        stopCellMoving(): void;
    };
    export interface PasteRangeBoxValues {
        readonly colCount: number;
        readonly rowCount: number;
        getCellValue(offsetCol: number, offsetRow: number): string;
    }
    export type PasteCellEvent = CellAddress & {
        value: string;
        normalizeValue: string;
        multi: boolean;
        rangeBoxValues: PasteRangeBoxValues;
        event: ClipboardEvent;
    };
    export type InputCellEvent = CellAddress & {
        value: string;
    };
    export type DeleteCellEvent = CellAddress & {
        event: KeyboardEvent;
    };
    export type ScrollEvent = {
        event: Event;
    };
    export type ModifyStatusEditableinputCellEvent = CellAddress & {
        input: HTMLInputElement;
    };
    export type MousePointerCellEvent = CellAddress & {
        related?: CellAddress;
    };
    export interface DrawGridEventHandlersEventMap {
        selected_cell: [SelectedCellEvent, boolean];
        click_cell: [MouseCellEvent];
        dblclick_cell: [MouseCellEvent];
        mouseenter_cell: [MousePointerCellEvent];
        mouseleave_cell: [MousePointerCellEvent];
        mouseover_cell: [MousePointerCellEvent];
        mouseout_cell: [MousePointerCellEvent];
        mousemove_cell: [MouseCellEvent];
        mousedown_cell: [MouseCellEvent];
        mouseup_cell: [MouseCellEvent];
        contextmenu_cell: [MouseCellEvent];
        dbltap_cell: [TouchCellEvent];
        keydown: [KeydownEvent];
        paste_cell: [PasteCellEvent];
        input_cell: [InputCellEvent];
        delete_cell: [DeleteCellEvent];
        scroll: [ScrollEvent];
        editableinput_cell: [CellAddress];
        modify_status_editableinput_cell: [ModifyStatusEditableinputCellEvent];
        focus_grid: [FocusEvent];
        blur_grid: [FocusEvent];
        resize_column: [{
            col: number;
        }];
        copydata: [CellRange];
    }
    export interface DrawGridEventHandlersReturnMap {
        selected_cell: void;
        click_cell: void;
        dblclick_cell: void;
        mouseenter_cell: void;
        mouseleave_cell: void;
        mouseover_cell: void;
        mouseout_cell: void;
        mousemove_cell: void;
        mousedown_cell: boolean;
        mouseup_cell: void;
        contextmenu_cell: void;
        dbltap_cell: void;
        keydown: void;
        paste_cell: void;
        input_cell: void;
        delete_cell: void;
        scroll: void;
        editableinput_cell: boolean | void;
        modify_status_editableinput_cell: void;
        focus_grid: void;
        blur_grid: void;
        resize_column: void;
        copydata: string;
    }
    export type ChangedValueCellEvent<T> = CellAddress & {
        record: T;
        field: FieldDef<T>;
        value: any;
        oldValue: any;
    };
    export type ChangedHeaderValueCellEvent = CellAddress & {
        field: string;
        value: any;
        oldValue: any;
    };
    export interface ListGridEventHandlersEventMap<T> extends DrawGridEventHandlersEventMap {
        changed_value: [ChangedValueCellEvent<T>];
        changed_header_value: [ChangedHeaderValueCellEvent];
    }
    export interface ListGridEventHandlersReturnMap extends DrawGridEventHandlersReturnMap {
        changed_value: void;
        changed_header_value: void;
    }
}

declare module 'cheetah-grid/ts-types/plugin' {
    import type { ColorPropertyDefine, ColorsPropertyDefine } from "cheetah-grid/ts-types/define";
    export interface IconDefine {
        d: string;
        width: number;
        height: number;
    }
    export type PartialThemeDefine = Partial<ThemeDefine>;
    export interface ThemeDefine {
        font?: string;
        underlayBackgroundColor: string;
        color: ColorPropertyDefine;
        frozenRowsColor?: ColorPropertyDefine;
        defaultBgColor?: ColorPropertyDefine;
        frozenRowsBgColor?: ColorPropertyDefine;
        selectionBgColor: ColorPropertyDefine;
        highlightBgColor?: ColorPropertyDefine;
        borderColor: ColorsPropertyDefine;
        frozenRowsBorderColor: ColorsPropertyDefine;
        highlightBorderColor: ColorsPropertyDefine;
        checkbox: {
            uncheckBgColor?: ColorPropertyDefine;
            checkBgColor?: ColorPropertyDefine;
            borderColor?: ColorPropertyDefine;
        };
        radioButton: {
            checkColor?: ColorPropertyDefine;
            uncheckBorderColor?: ColorPropertyDefine;
            checkBorderColor?: ColorPropertyDefine;
            uncheckBgColor?: ColorPropertyDefine;
            checkBgColor?: ColorPropertyDefine;
        };
        button: {
            color?: ColorPropertyDefine;
            bgColor?: ColorPropertyDefine;
        };
        header: {
            sortArrowColor?: ColorPropertyDefine;
        };
    }
    export type RequiredThemeDefine = Required<ThemeDefine> & {
        checkbox: Required<ThemeDefine["checkbox"]>;
        radioButton: Required<ThemeDefine["radioButton"]>;
        button: Required<ThemeDefine["button"]>;
        header: Required<ThemeDefine["header"]>;
    };
}

declare module 'cheetah-grid/ts-types/define' {
    import type { ColorDef } from "cheetah-grid/ts-types/base";
    import type { ListGridAPI } from "cheetah-grid/ts-types/grid-engine";
    export interface FontIcon<T> {
        font?: string;
        content?: keyof T;
        className?: string;
        tagName?: string;
        isLiga?: boolean;
        width?: number;
        height?: number;
        color?: string;
    }
    export interface ImageIcon<T> {
        src: keyof T | string;
        width?: number;
        height?: number;
    }
    export interface PathIcon<T> {
        path: keyof T | string;
        width: number;
        height: number;
        color?: string;
    }
    export interface SvgIcon<T> {
        svg: keyof T | string;
        width?: number;
        height?: number;
    }
    export interface NamedIcon<T> {
        name: keyof T | string;
        width?: number;
        height?: number;
    }
    export type ColumnIconOption<T> = FontIcon<T> | ImageIcon<T> | PathIcon<T> | SvgIcon<T> | NamedIcon<T>;
    export type ColumnMenuItemOptions = ColumnMenuItemOption[] | SimpleColumnMenuItemOption[] | OldSimpleColumnMenuItemOption[] | string | ColumnMenuItemObjectOptions;
    export interface ColumnMenuItemOption {
        value: any;
        label: string;
        classList?: string[];
        html?: string;
    }
    export interface SimpleColumnMenuItemOption {
        value: any;
        label: string;
    }
    /** @internal */
    export interface OldSimpleColumnMenuItemOption {
        value: any;
        caption: string;
    }
    export interface ColumnMenuItemObjectOptions {
        [value: string]: string;
    }
    export type TextOverflow = "clip" | "ellipsis" | string;
    export type LineClamp = number | "auto";
    export interface StylePropertyFunctionArg {
        row: number;
        col: number;
        grid: ListGridAPI<any>;
        context: CanvasRenderingContext2D;
    }
    export type ColorPropertyDefine = ColorDef | ((args: StylePropertyFunctionArg) => string) | ((args: StylePropertyFunctionArg) => CanvasGradient) | ((args: StylePropertyFunctionArg) => CanvasPattern);
    export type ColorsPropertyDefine = ColorPropertyDefine | (ColorDef | null)[] | ((args: StylePropertyFunctionArg) => (ColorDef | null)[]);
    export type FontPropertyDefine = string | ((args: StylePropertyFunctionArg) => string);
}

declare module 'cheetah-grid/ts-types/data' {
    export interface MessageObject {
        type: "error" | "info" | "warning";
        message: string | null;
        original?: Message;
    }
    export type Message = MessageObject | string;
}

declare module 'cheetah-grid/ts-types/grid-engine' {
    import type { AnyFunction, ColorDef, MaybePromise, MaybePromiseOrUndef, RectProps } from "cheetah-grid/ts-types/base";
    import type { AnyListener, DrawGridEventHandlersEventMap, DrawGridEventHandlersReturnMap, EventListenerId, ListGridEventHandlersEventMap, ListGridEventHandlersReturnMap } from "cheetah-grid/ts-types/events";
    import type { CellAddress, CellRange, FieldData, FieldDef } from "cheetah-grid/ts-types/grid";
    import type { ColorPropertyDefine, ColorsPropertyDefine, FontPropertyDefine, LineClamp, TextOverflow } from "cheetah-grid/ts-types/define";
    import type { RequiredThemeDefine } from "cheetah-grid/ts-types/plugin";
    import type { SimpleColumnIconOption } from "cheetah-grid/ts-types-internal/data";
    export type LayoutObjectId = number | string | symbol;
    export interface DrawGridKeyboardOptions {
        moveCellOnTab?: boolean;
        moveCellOnEnter?: boolean;
        deleteCellValueOnDel?: boolean;
        selectAllOnCtrlA?: boolean;
    }
    export interface DrawGridAPI {
        font?: string;
        rowCount: number;
        colCount: number;
        frozenRowCount: number;
        frozenColCount: number;
        defaultRowHeight: number;
        defaultColWidth: string | number;
        underlayBackgroundColor?: string;
        keyboardOptions: DrawGridKeyboardOptions | null;
        readonly selection: Selection;
        readonly canvas: HTMLCanvasElement;
        readonly visibleRowCount: number;
        readonly visibleColCount: number;
        readonly topRow: number;
        readonly leftCol: number;
        scrollLeft: number;
        scrollTop: number;
        getElement(): HTMLElement;
        focus(): void;
        hasFocusGrid(): boolean;
        listen<TYPE extends keyof DrawGridEventHandlersEventMap>(type: TYPE, listener: (...event: DrawGridEventHandlersEventMap[TYPE]) => DrawGridEventHandlersReturnMap[TYPE]): EventListenerId;
        listen(type: string, listener: AnyListener): EventListenerId;
        configure(name: "fadeinWhenCallbackInPromise", value?: boolean): boolean;
        updateSize(): void;
        updateScroll(): boolean;
        invalidate(): void;
        invalidateCell(col: number, row: number): void;
        invalidateGridRect(startCol: number, startRow: number, endCol?: number, endRow?: number): void;
        invalidateCellRange(cellRange: CellRange): void;
        getRowHeight(row: number): number;
        setRowHeight(row: number, height: number): void;
        getColWidth(col: number): number;
        setColWidth(col: number, width: number): void;
        getMaxColWidth(col: number): string | number | undefined;
        setMaxColWidth(col: number, maxwidth: string | number): void;
        getMinColWidth(col: number): string | number | undefined;
        setMinColWidth(col: number, minwidth: string | number): void;
        getCellRect(col: number, row: number): RectProps;
        getCellRelativeRect(col: number, row: number): RectProps;
        getCellsRect(startCol: number, startRow: number, endCol: number, endRow: number): RectProps;
        getCellRangeRect(cellRange: CellRange): RectProps;
        isFrozenCell(col: number, row: number): {
            row: boolean;
            col: boolean;
        } | null;
        getRowAt(absoluteY: number): number;
        getColAt(absoluteX: number): number;
        getCellAt(absoluteX: number, absoluteY: number): CellAddress;
        makeVisibleCell(col: number, row: number): void;
        setFocusCursor(col: number, row: number): void;
        focusCell(col: number, row: number): void;
        getCellOverflowText(col: number, row: number): string | null;
        setCellOverflowText(col: number, row: number, overflowText: false | string): void;
        getAttachCellsArea(range: CellRange): {
            element: HTMLElement;
            rect: RectProps;
        };
        onKeyDownMove(evt: KeyboardEvent): void;
        dispose(): void;
        addDisposable(disposable: {
            dispose(): void;
        }): void;
    }
    export interface DataSourceAPI<T> {
        length: number;
        get(index: number): MaybePromiseOrUndef<T>;
        getField<F extends FieldDef<T>>(index: number, field: F): FieldData;
        hasField(index: number, field: FieldDef<T>): boolean;
        setField<F extends FieldDef<T>>(index: number, field: F, value: any): MaybePromise<boolean>;
        sort(field: FieldDef<T>, order: "desc" | "asc"): MaybePromise<void>;
    }
    export interface SortState {
        col: number;
        row: number;
        order: "asc" | "desc" | undefined;
    }
    export type HeaderValues = Map<any, any>;
    export interface ListGridAPI<T> extends DrawGridAPI {
        records: T[] | null;
        dataSource: DataSourceAPI<T>;
        theme: RequiredThemeDefine | null;
        sortState: SortState | null;
        headerValues: HeaderValues;
        recordRowCount: number;
        disabled: boolean;
        readOnly: boolean;
        listen<TYPE extends keyof ListGridEventHandlersEventMap<T>>(type: TYPE, listener: (...event: ListGridEventHandlersEventMap<T>[TYPE]) => ListGridEventHandlersReturnMap[TYPE]): EventListenerId;
        getField(col: number, row: number): FieldDef<T> | undefined;
        getRowRecord(row: number): MaybePromiseOrUndef<T>;
        getRecordIndexByRow(row: number): number;
        getRecordStartRowByRecordIndex(index: number): number;
        getHeaderField(col: number, row: number): any | undefined;
        getHeaderValue(col: number, row: number): any | undefined;
        setHeaderValue(col: number, row: number, newValue: any): void;
        getCellRange(col: number, row: number): CellRange;
        getCellRangeByField(field: FieldDef<T>, index: number): CellRange | null;
        focusGridCell(field: FieldDef<T>, index: number): void;
        makeVisibleGridCell(field: FieldDef<T>, index: number): void;
        getGridCanvasHelper(): GridCanvasHelperAPI;
        doChangeValue(col: number, row: number, changeValueCallback: (before: any) => any): MaybePromise<boolean>;
        doGetCellValue(col: number, row: number, valueCallback: (value: any) => void): boolean;
        doSetPasteValue(text: string): void;
        doSetPasteValue(text: string, test: (data: SetPasteValueTestData<T>) => boolean): void;
        getLayoutCellId(col: number, row: number): LayoutObjectId;
        getColumnType(col: number, row: number): ColumnTypeAPI;
    }
    export interface ColumnTypeAPI {
    }
    export type SetPasteValueTestData<T> = CellAddress & {
        grid: ListGridAPI<T>;
        record: T;
        value: string;
        oldValue: any;
    };
    export interface InlineAPI {
        width(arg: {
            ctx: CanvasRenderingContext2D;
        }): number;
        font(): string | null;
        color(): ColorDef | null;
        canDraw(): boolean;
        onReady(callback: AnyFunction): void;
        draw(opt: any): void;
        canBreak(): boolean;
    }
    type ColorsDef = ColorDef | (ColorDef | null)[];
    export interface GridCanvasHelperAPI {
        theme: RequiredThemeDefine;
        text(text: string | (InlineAPI | string)[], context: CellContext, option: {
            padding?: number | string | (number | string)[];
            offset?: number;
            color?: ColorPropertyDefine;
            textAlign?: CanvasTextAlign;
            textBaseline?: CanvasTextBaseline;
            font?: FontPropertyDefine;
            textOverflow?: TextOverflow;
            icons?: SimpleColumnIconOption[];
        }): void;
        button(caption: string, context: CellContext, option: {
            bgColor?: ColorPropertyDefine;
            padding?: number | string | (number | string)[];
            offset?: number;
            color?: ColorPropertyDefine;
            textAlign?: CanvasTextAlign;
            textBaseline?: CanvasTextBaseline;
            shadow?: {
                color?: string;
                blur?: number;
                offsetX?: number;
                offsetY?: number;
                offset?: {
                    x?: number;
                    y?: number;
                };
            };
            font?: FontPropertyDefine;
            textOverflow?: TextOverflow;
            icons?: SimpleColumnIconOption[];
        }): void;
        checkbox(check: boolean, context: CellContext, option: {
            animElapsedTime?: number;
            uncheckBgColor?: ColorPropertyDefine;
            checkBgColor?: ColorPropertyDefine;
            borderColor?: ColorPropertyDefine;
            textAlign?: CanvasTextAlign;
            textBaseline?: CanvasTextBaseline;
        }): void;
        radioButton(check: boolean, context: CellContext, option: {
            animElapsedTime?: number;
            bgColor?: ColorPropertyDefine;
            checkColor?: ColorPropertyDefine;
            uncheckBorderColor?: ColorPropertyDefine;
            checkBorderColor?: ColorPropertyDefine;
            uncheckBgColor?: ColorPropertyDefine;
            checkBgColor?: ColorPropertyDefine;
            textAlign?: CanvasTextAlign;
            textBaseline?: CanvasTextBaseline;
        }): void;
        multilineText(multilines: string[], context: CellContext, option: {
            padding?: number | string | (number | string)[];
            offset?: number;
            color?: ColorPropertyDefine;
            textAlign?: CanvasTextAlign;
            textBaseline?: CanvasTextBaseline;
            font?: FontPropertyDefine;
            lineHeight?: string | number;
            autoWrapText?: boolean;
            lineClamp?: LineClamp;
            textOverflow?: TextOverflow;
            icons?: SimpleColumnIconOption[];
        }): void;
        getColor(color: ColorPropertyDefine, col: number, row: number, ctx: CanvasRenderingContext2D): ColorDef;
        getColor(color: ColorsPropertyDefine, col: number, row: number, ctx: CanvasRenderingContext2D): ColorsDef;
        toBoxPixelArray(value: number | string | (number | string)[], context: CellContext, font: string | undefined): [number, number, number, number];
        fillRectWithState(rect: RectProps, context: CellContext, option: {
            fillColor?: ColorPropertyDefine;
        }): void;
        drawBorderWithClip(context: CellContext, draw: (ctx: CanvasRenderingContext2D) => void): void;
        drawWithClip(context: CellContext, draw: (ctx: CanvasRenderingContext2D) => void): void;
        testFontLoad(font: string | undefined, value: string, context: CellContext): boolean;
        buildCheckBoxInline(check: boolean, context: CellContext, option: {
            animElapsedTime?: number;
            uncheckBgColor?: ColorPropertyDefine;
            checkBgColor?: ColorPropertyDefine;
            borderColor?: ColorPropertyDefine;
            textAlign?: CanvasTextAlign;
            textBaseline?: CanvasTextBaseline;
        }): InlineAPI;
    }
    export interface CellContext {
        readonly col: number;
        readonly row: number;
        getContext(): CanvasRenderingContext2D;
        toCurrentContext(): CellContext;
        getDrawRect(): RectProps | null;
        getRect(): RectProps;
        getSelection(): {
            select: CellAddress;
            range: CellRange;
        };
        setRectFilter(rectFilter: (base: RectProps) => RectProps): void;
    }
    export interface Selection {
        select: CellAddress;
        range: CellRange;
    }
    export {};
}

declare module 'cheetah-grid/columns/action' {
    import type { ActionOption, BaseActionOption, ButtonActionOption, ColumnActionOption, EditorOption, InlineInputEditorOption, InlineMenuEditorOption, RecordBoolean, SmallDialogInputEditorOption } from "cheetah-grid/ts-types";
    import { Action } from "cheetah-grid/columns/action/Action";
    import { BaseAction } from "cheetah-grid/columns/action/BaseAction";
    import { ButtonAction } from "cheetah-grid/columns/action/ButtonAction";
    import { CheckEditor } from "cheetah-grid/columns/action/CheckEditor";
    import { Editor } from "cheetah-grid/columns/action/Editor";
    import { InlineInputEditor } from "cheetah-grid/columns/action/InlineInputEditor";
    import { InlineMenuEditor } from "cheetah-grid/columns/action/InlineMenuEditor";
    import { RadioEditor } from "cheetah-grid/columns/action/RadioEditor";
    import { SmallDialogInputEditor } from "cheetah-grid/columns/action/SmallDialogInputEditor";
    class ImmutableCheckEditor extends CheckEditor<any> {
        get disabled(): RecordBoolean;
        get readOnly(): RecordBoolean;
    }
    class ImmutableRadioEditor extends RadioEditor<any> {
        get disabled(): RecordBoolean;
        get readOnly(): RecordBoolean;
    }
    class ImmutableInputEditor extends SmallDialogInputEditor<any> {
        get disabled(): RecordBoolean;
        get readOnly(): RecordBoolean;
    }
    export const ACTIONS: {
        CHECK: ImmutableCheckEditor;
        INPUT: ImmutableInputEditor;
        RADIO: ImmutableRadioEditor;
    };
    /**
      * column actions
      * @namespace cheetahGrid.columns.action
      * @memberof cheetahGrid.columns
      */
    export { BaseAction, Editor, Action, CheckEditor, RadioEditor, ButtonAction, SmallDialogInputEditor, InlineInputEditor, InlineMenuEditor, ActionOption, BaseActionOption, ButtonActionOption, EditorOption, InlineInputEditorOption, InlineMenuEditorOption, SmallDialogInputEditorOption, };
    export function of<T>(columnAction: ColumnActionOption | BaseAction<T> | null | undefined): BaseAction<T> | undefined;
}

declare module 'cheetah-grid/columns/style' {
    import type { BaseStyleOption, ButtonStyleOption, CheckStyleOption, ColumnStyleOption, IconStyleOption, ImageStyleOption, MenuStyleOption, MultilineTextStyleOption, NumberStyleOption, PercentCompleteBarStyleOption, StyleOption } from "cheetah-grid/ts-types";
    import { BaseStyle } from "cheetah-grid/columns/style/BaseStyle";
    import { ButtonStyle } from "cheetah-grid/columns/style/ButtonStyle";
    import { CheckStyle } from "cheetah-grid/columns/style/CheckStyle";
    import { IconStyle } from "cheetah-grid/columns/style/IconStyle";
    import { ImageStyle } from "cheetah-grid/columns/style/ImageStyle";
    import { MenuStyle } from "cheetah-grid/columns/style/MenuStyle";
    import { MultilineTextStyle } from "cheetah-grid/columns/style/MultilineTextStyle";
    import { NumberStyle } from "cheetah-grid/columns/style/NumberStyle";
    import { PercentCompleteBarStyle } from "cheetah-grid/columns/style/PercentCompleteBarStyle";
    import { RadioStyle } from "cheetah-grid/columns/style/RadioStyle";
    import { Style } from "cheetah-grid/columns/style/Style";
    const EVENT_TYPE: {
        CHANGE_STYLE: "change_style";
    };
    export { EVENT_TYPE, BaseStyle, Style, NumberStyle, CheckStyle, RadioStyle, ButtonStyle, ImageStyle, IconStyle, PercentCompleteBarStyle, MultilineTextStyle, MenuStyle, BaseStyleOption, ButtonStyleOption, CheckStyleOption, IconStyleOption, ImageStyleOption, MenuStyleOption, MultilineTextStyleOption, NumberStyleOption, PercentCompleteBarStyleOption, StyleOption, };
    export function of(columnStyle: ColumnStyleOption | null | undefined, record: any, StyleClassDef?: typeof BaseStyle): BaseStyle;
}

declare module 'cheetah-grid/columns/type' {
    import type { BaseColumnOption, BranchGraphColumnOption, ButtonColumnOption, ColumnTypeOption, IconColumnOption, MenuColumnOption, NumberColumnOption, PercentCompleteBarColumnOption } from "cheetah-grid/ts-types";
    import type { BaseColumn } from "cheetah-grid/columns/type/BaseColumn";
    import { BranchGraphColumn } from "cheetah-grid/columns/type/BranchGraphColumn";
    import { ButtonColumn } from "cheetah-grid/columns/type/ButtonColumn";
    import { CheckColumn } from "cheetah-grid/columns/type/CheckColumn";
    import { Column } from "cheetah-grid/columns/type/Column";
    import { IconColumn } from "cheetah-grid/columns/type/IconColumn";
    import { ImageColumn } from "cheetah-grid/columns/type/ImageColumn";
    import { MenuColumn } from "cheetah-grid/columns/type/MenuColumn";
    import { MultilineTextColumn } from "cheetah-grid/columns/type/MultilineTextColumn";
    import { NumberColumn } from "cheetah-grid/columns/type/NumberColumn";
    import { PercentCompleteBarColumn } from "cheetah-grid/columns/type/PercentCompleteBarColumn";
    import { RadioColumn } from "cheetah-grid/columns/type/RadioColumn";
    /**
      * column types
      * @namespace cheetahGrid.columns.type
      * @memberof cheetahGrid.columns
      */
    export { Column, NumberColumn, CheckColumn, RadioColumn, ButtonColumn, ImageColumn, PercentCompleteBarColumn, IconColumn, BranchGraphColumn, MenuColumn, MultilineTextColumn, BaseColumnOption, BranchGraphColumnOption, ButtonColumnOption, IconColumnOption, MenuColumnOption, NumberColumnOption, PercentCompleteBarColumnOption, };
    export function of<T>(columnType: ColumnTypeOption | BaseColumn<T, any> | null | undefined): BaseColumn<T, any>;
}

declare module 'cheetah-grid/core/DrawGrid' {
    import type { AnyFunction, CellAddress, CellContext, CellRange, DrawGridAPI, DrawGridEventHandlersEventMap, DrawGridEventHandlersReturnMap, DrawGridKeyboardOptions, EventListenerId, KeyboardEventListener, KeydownEvent } from "cheetah-grid/ts-types";
    import { DG_EVENT_TYPE } from "cheetah-grid/core/DG_EVENT_TYPE";
    import { EventHandler } from "cheetah-grid/internal/EventHandler";
    import { EventTarget } from "cheetah-grid/core/EventTarget";
    import { NumberMap } from "cheetah-grid/internal/NumberMap";
    import { Rect } from "cheetah-grid/internal/Rect";
    import { Scrollable } from "cheetah-grid/internal/Scrollable";
    /**
        * managing mouse down moving
        * @private
        */
    class BaseMouseDownMover {
            protected _grid: DrawGrid;
            constructor(grid: DrawGrid);
            moving(_e: MouseEvent | TouchEvent): boolean;
            lastMoving(e: MouseEvent | TouchEvent): boolean;
            protected _bindMoveAndUp(e: MouseEvent | TouchEvent): void;
            protected _moveInternal(_e: MouseEvent | TouchEvent): boolean;
            protected _upInternal(_e: MouseEvent | TouchEvent): void;
            dispose(): void;
    }
    /**
        * managing cell selection operation with mouse
        * @private
        */
    class CellSelector extends BaseMouseDownMover {
            start(e: MouseEvent | TouchEvent): void;
            select(e: MouseEvent | TouchEvent): void;
            protected _moveInternal(e: MouseEvent | TouchEvent): boolean;
    }
    /**
        * managing row width changing operation with mouse
        * @private
        */
    class ColumnResizer extends BaseMouseDownMover {
            constructor(grid: DrawGrid);
            start(col: number, e: MouseEvent | TouchEvent): void;
            protected _moveInternal(e: MouseEvent | TouchEvent): boolean;
            protected _upInternal(_e: MouseEvent | TouchEvent): void;
    }
    /**
        * Manage focus
        * @private
        */
    class FocusControl extends EventTarget {
            constructor(grid: DrawGrid, parentElement: HTMLElement, scrollable: Scrollable);
            fireKeyDownMove(keyCode: number, e: KeyboardEvent): void;
            onKeyDownMove(fn: KeyboardEventListener): void;
            onKeyDown(fn: (e: KeydownEvent) => void): EventListenerId;
            onInput(fn: (value: string) => void): EventListenerId;
            onDelete(fn: (e: KeyboardEvent) => void): EventListenerId;
            onCopy(fn: (e: ClipboardEvent) => void): EventListenerId;
            onPaste(fn: (e: {
                    value: string;
                    event: ClipboardEvent;
            }) => void): EventListenerId;
            onFocus(fn: (e: FocusEvent) => void): EventListenerId;
            onBlur(fn: (e: FocusEvent) => void): EventListenerId;
            focus(): void;
            setFocusRect(rect: Rect): void;
            get editMode(): boolean;
            set editMode(editMode: boolean);
            resetInputStatus(): void;
            storeInputStatus(): void;
            setDefaultInputStatus(): void;
            get input(): HTMLInputElement;
            dispose(): void;
    }
    /**
        * Selected area management
        */
    class Selection extends EventTarget {
            constructor(grid: DrawGrid);
            get range(): CellRange;
            set range(range: CellRange);
            get focus(): CellAddress;
            get select(): CellAddress;
            set select(cell: CellAddress);
            _setSelectCell(col: number, row: number): void;
            _setFocusCell(col: number, row: number, keepSelect: boolean): void;
            _wrapFireSelectedEvent(callback: AnyFunction): void;
            _updateGridRange(): boolean;
    }
    /** @private */
    type DrawLayerFunction = (ctx: CanvasRenderingContext2D) => void;
    /** @private */
    class DrawLayers {
            constructor();
            addDraw(level: number, fn: DrawLayerFunction): void;
            draw(ctx: CanvasRenderingContext2D): void;
    }
    /**
        * Context of cell drawing
        * @private
        */
    class DrawCellContext implements CellContext {
            /**
                * constructor
                * @param {number} col index of column
                * @param {number} row index of row
                * @param {CanvasRenderingContext2D} ctx context
                * @param {Rect} rect rect of cell area
                * @param {Rect} drawRect rect of drawing area
                * @param {boolean} drawing `true` if drawing is in progress
                * @param {object} selection the selection
                * @param {Array} drawLayers array of draw layers
                * @private
                */
            constructor(col: number, row: number, ctx: CanvasRenderingContext2D, rect: Rect | null, drawRect: Rect | null, drawing: boolean, selection: Selection, drawLayers: DrawLayers);
            get drawing(): boolean;
            get row(): number;
            get col(): number;
            cancel(): void;
            /**
                * select status.
                * @return {object} select status
                */
            getSelection(): {
                    select: CellAddress;
                    range: CellRange;
            };
            /**
                * Canvas context.
                * @return {CanvasRenderingContext2D} Canvas context.
                */
            getContext(): CanvasRenderingContext2D;
            /**
                * Rectangle of cell.
                * @return {Rect} rect Rectangle of cell.
                */
            getRect(): Rect;
            setRectFilter(rectFilter: (base: Rect) => Rect): void;
            /**
                * Rectangle of Drawing range.
                * @return {Rect} Rectangle of Drawing range.
                */
            getDrawRect(): Rect | null;
            /**
                * get Context of current state
                * @return {DrawCellContext} current DrawCellContext.
                */
            toCurrentContext(): DrawCellContext;
            addLayerDraw(level: number, fn: DrawLayerFunction): void;
            _delayMode(grid: DrawGrid, onTerminate: () => void): void;
            /**
                * terminate
                * @return {void}
                */
            terminate(): void;
    }
    /** @protected */
    interface DrawGridProtected {
            element: HTMLElement;
            scrollable: Scrollable;
            handler: EventHandler;
            selection: Selection;
            focusControl: FocusControl;
            canvas: HTMLCanvasElement;
            context: CanvasRenderingContext2D;
            rowCount: number;
            colCount: number;
            frozenColCount: number;
            frozenRowCount: number;
            defaultRowHeight: number;
            defaultColWidth: string | number;
            font?: string;
            underlayBackgroundColor?: string;
            keyboardOptions?: DrawGridKeyboardOptions;
            disableColumnResize?: boolean;
            rowHeightsMap: NumberMap<number>;
            colWidthsMap: NumberMap<string | number>;
            colWidthsLimit: {
                    [col: number]: {
                            max?: string | number;
                            min?: string | number;
                    };
            };
            calcWidthContext: {
                    _: DrawGridProtected;
                    full: number;
                    em: number;
            };
            columnResizer: ColumnResizer;
            cellSelector: CellSelector;
            drawCells: {
                    [row: number]: {
                            [col: number]: DrawCellContext;
                    };
            };
            cellTextOverflows: {
                    [at: string]: string;
            };
            focusedGrid: boolean;
            config: {
                    [name: string]: any;
            } | undefined;
            scroll: {
                    left: number;
                    top: number;
            };
            disposables?: {
                    dispose(): void;
            }[] | null;
    }
    export { DrawGridProtected };
    export interface DrawGridConstructorOptions {
            rowCount?: number;
            colCount?: number;
            frozenColCount?: number;
            frozenRowCount?: number;
            /**
                * Default grid row height. default 40
                */
            defaultRowHeight?: number;
            /**
                * Default grid col width. default 80
                */
            defaultColWidth?: string | number;
            font?: string;
            underlayBackgroundColor?: string;
            keyboardOptions?: DrawGridKeyboardOptions;
            /**
                * Canvas parent element
                */
            parentElement?: HTMLElement | null;
            /**
                * Disable column resizing
                */
            disableColumnResize?: boolean;
    }
    /** @private */
    const protectedKey: "$$$$protected symbol$$$$";
    /**
        * DrawGrid
        * @classdesc cheetahGrid.core.DrawGrid
        * @memberof cheetahGrid.core
        */
    export abstract class DrawGrid extends EventTarget implements DrawGridAPI {
            protected [protectedKey]: DrawGridProtected;
            static get EVENT_TYPE(): typeof DG_EVENT_TYPE;
            constructor(options?: DrawGridConstructorOptions);
            /**
                * Get root element.
                * @returns {HTMLElement} root element
                */
            getElement(): HTMLElement;
            /**
                * Get canvas element.
                */
            get canvas(): HTMLCanvasElement;
            /**
                * Focus the grid.
                * @return {void}
                */
            focus(): void;
            hasFocusGrid(): boolean;
            /**
                * Get the selection instance.
                */
            get selection(): Selection;
            /**
                * Get the number of rows.
                */
            get rowCount(): number;
            /**
                * Set the number of rows.
                */
            set rowCount(rowCount: number);
            /**
                * Get the number of columns.
                */
            get colCount(): number;
            /**
                * Set the number of columns.
                */
            set colCount(colCount: number);
            /**
                * Get the number of frozen columns.
                */
            get frozenColCount(): number;
            /**
                * Set the number of frozen columns.
                */
            set frozenColCount(frozenColCount: number);
            /**
                * Get the number of frozen rows.
                */
            get frozenRowCount(): number;
            /**
                * Set the number of frozen rows.
                */
            set frozenRowCount(frozenRowCount: number);
            /**
                * Get the default row height.
                *
                */
            get defaultRowHeight(): number;
            /**
                * Set the default row height.
                */
            set defaultRowHeight(defaultRowHeight: number);
            /**
                * Get the default column width.
                */
            get defaultColWidth(): string | number;
            /**
                * Set the default column width.
                */
            set defaultColWidth(defaultColWidth: string | number);
            /**
                * Get the font definition as a string.
                */
            get font(): string | undefined;
            /**
                * Set the font definition with the given string.
                */
            set font(font: string | undefined);
            /**
                * Get the background color of the underlay.
                */
            get underlayBackgroundColor(): string | undefined;
            /**
                * Set the background color of the underlay.
                */
            set underlayBackgroundColor(underlayBackgroundColor: string | undefined);
            get keyboardOptions(): DrawGridKeyboardOptions | null;
            set keyboardOptions(keyboardOptions: DrawGridKeyboardOptions | null);
            configure(name: "fadeinWhenCallbackInPromise", value?: boolean): boolean;
            /**
                * Apply the changed size.
                * @return {void}
                */
            updateSize(): void;
            /**
                * Apply the changed scroll size.
                * @return {boolean} `true` if there was a change in the scroll size
                */
            updateScroll(): boolean;
            /**
                * Get the row height of the given the row index.
                * @param  {number} row The row index
                * @return {number} The row height
                */
            getRowHeight(row: number): number;
            /**
                * Set the row height of the given the row index.
                * @param  {number} row The row index
                * @param  {number} height The row height
                * @return {void}
                */
            setRowHeight(row: number, height: number): void;
            /**
                * Get the column width of the given the column index.
                * @param  {number} col The column index
                * @return {number} The column width
                */
            getColWidth(col: number): number;
            /**
                * Set the column widtht of the given the column index.
                * @param  {number} col The column index
                * @param  {number} width The column width
                * @return {void}
                */
            setColWidth(col: number, width: string | number): void;
            /**
                * Get the column max width of the given the column index.
                * @param  {number} col The column index
                * @return {number} The column max width
                */
            getMaxColWidth(col: number): string | number | undefined;
            /**
                * Set the column max widtht of the given the column index.
                * @param  {number} col The column index
                * @param  {number} maxwidth The column max width
                * @return {void}
                */
            setMaxColWidth(col: number, maxwidth: string | number): void;
            /**
                * Get the column min width of the given the column index.
                * @param  {number} col The column index
                * @return {number} The column min width
                */
            getMinColWidth(col: number): string | number | undefined;
            /**
                * Set the column min widtht of the given the column index.
                * @param  {number} col The column index
                * @param  {number} minwidth The column min width
                * @return {void}
                */
            setMinColWidth(col: number, minwidth: string | number): void;
            /**
                * Get the rect of the cell.
                * @param {number} col index of column, of the cell
                * @param {number} row index of row, of the cell
                * @returns {Rect} the rect of the cell.
                */
            getCellRect(col: number, row: number): Rect;
            /**
                * Get the relative rectangle of the cell.
                * @param {number} col index of column, of the cell
                * @param {number} row index of row, of the cell
                * @returns {Rect} the rect of the cell.
                */
            getCellRelativeRect(col: number, row: number): Rect;
            /**
                * Get the rectangle of the cells area.
                * @param {number} startCol index of the starting column, of the cell
                * @param {number} startRow index of the starting row, of the cell
                * @param {number} endCol index of the ending column, of the cell
                * @param {number} endRow index of the ending row, of the cell
                * @returns {Rect} the rect of the cells.
                */
            getCellsRect(startCol: number, startRow: number, endCol: number, endRow: number): Rect;
            getCellRangeRect(range: CellRange): Rect;
            isFrozenCell(col: number, row: number): {
                    row: boolean;
                    col: boolean;
            } | null;
            getRowAt(absoluteY: number): number;
            getColAt(absoluteX: number): number;
            getCellAt(absoluteX: number, absoluteY: number): CellAddress;
            /**
                * Scroll to where cell is visible.
                * @param  {number} col The column index.
                * @param  {number} row The row index
                * @return {void}
                */
            makeVisibleCell(col: number, row: number): void;
            /**
                * Moves the focus cursor to the given cell.
                * @param  {number} col The column index.
                * @param  {number} row The row index
                * @return {void}
                */
            setFocusCursor(col: number, row: number): void;
            /**
                * Focus the cell.
                * @param  {number} col The column index.
                * @param  {number} row The row index
                * @return {void}
                */
            focusCell(col: number, row: number): void;
            /**
                * Redraws the range of the given cell.
                * @param  {number} col The column index of cell.
                * @param  {number} row The row index of cell.
                * @return {void}
                */
            invalidateCell(col: number, row: number): void;
            /**
                * Redraws the range of the given cells.
                * @param {number} startCol index of the starting column, of the cell
                * @param {number} startRow index of the starting row, of the cell
                * @param {number} endCol index of the ending column, of the cell
                * @param {number} endRow index of the ending row, of the cell
                * @return {void}
                */
            invalidateGridRect(startCol: number, startRow: number, endCol?: number, endRow?: number): void;
            invalidateCellRange(range: CellRange): void;
            /**
                * Redraws the whole grid.
                * @return {void}
                */
            invalidate(): void;
            /**
                * Get the number of scrollable rows fully visible in the grid. visibleRowCount does not include the frozen rows counted by the frozenRowCount property. It does not include any partially visible rows on the bottom of the grid.
                * @returns {number}
                */
            get visibleRowCount(): number;
            /**
                * Get the number of scrollable columns fully visible in the grid. visibleColCount does not include the frozen columns counted by the frozenColCount property. It does not include any partially visible columns on the right of the grid.
                * @returns {number}
                */
            get visibleColCount(): number;
            /**
                * Get the index of the first row in the scrollable region that is visible.
                * @returns {number}
                */
            get topRow(): number;
            /**
                * Get the index of the first column in the scrollable region that is visible.
                * @returns {number}
                */
            get leftCol(): number;
            /**
                * gets or sets the number of pixels that an element's content is scrolled vertically
                */
            get scrollTop(): number;
            set scrollTop(scrollTop: number);
            /**
                * gets or sets the number of pixels that an element's content is scrolled from its left edge
                */
            get scrollLeft(): number;
            set scrollLeft(scrollLeft: number);
            /**
                * Get the value of cell with the copy action.
                * <p>
                * Please implement
                * </p>
                *
                * @protected
                * @param col Column index of cell.
                * @param row Row index of cell.
                * @param range Copy range.
                * @return {string} the value of cell
                */
            protected getCopyCellValue(_col: number, _row: number, _range: CellRange): string | Promise<string> | void;
            /**
                * Draw a cell
                * <p>
                * Please implement cell drawing.
                * </p>
                *
                * @protected
                * @param  {number} col Column index of cell.
                * @param  {number} row Row index of cell.
                * @param  {DrawCellContext} context context of cell drawing.
                * @return {void}
                */
            protected abstract onDrawCell(col: number, row: number, context: CellContext): Promise<void> | void;
            /**
                * Get the overflowed text in the cell rectangle, from the given cell.
                * @param  {number} col The column index.
                * @param  {number} row The row index
                * @return {string | null} The text overflowing the cell rect.
                */
            getCellOverflowText(col: number, row: number): string | null;
            /**
                * Set the overflowed text in the cell rectangle, to the given cell.
                * @param  {number} col The column index.
                * @param  {number} row The row index
                * @param  {string} overflowText The overflowed text in the cell rectangle.
                * @return {void}
                */
            setCellOverflowText(col: number, row: number, overflowText: string | false): void;
            addDisposable(disposable: {
                    dispose(): void;
            }): void;
            /**
                * Dispose the grid instance.
                * @returns {void}
                */
            dispose(): void;
            getAttachCellsArea(range: CellRange): {
                    element: HTMLElement;
                    rect: Rect;
            };
            onKeyDownMove(evt: KeyboardEvent): void;
            protected bindEventsInternal(): void;
            protected getTargetRowAtInternal(_absoluteY: number): {
                    row: number;
                    top: number;
            } | void;
            protected getRowsHeightInternal(_startRow: number, _endRow: number): number | void;
            protected getRowHeightInternal(_row: number): number | void;
            protected getScrollHeightInternal(_row?: number): number | void;
            protected getMoveLeftColByKeyDownInternal({ col }: CellAddress): number;
            protected getMoveRightColByKeyDownInternal({ col }: CellAddress): number;
            protected getMoveUpRowByKeyDownInternal({ row }: CellAddress): number;
            protected getMoveDownRowByKeyDownInternal({ row }: CellAddress): number;
            protected getOffsetInvalidateCells(): number;
            protected getCopyRangeInternal(range: CellRange): CellRange;
            protected _getInitContext(): CanvasRenderingContext2D;
            fireListeners<TYPE extends keyof DrawGridEventHandlersEventMap>(type: TYPE, ...event: DrawGridEventHandlersEventMap[TYPE]): DrawGridEventHandlersReturnMap[TYPE][];
    }
}

declare module 'cheetah-grid/core/DG_EVENT_TYPE' {
    export interface DrawGridEvents {
            /**
                * Indicates when the cell was clicked.
                */
            CLICK_CELL: "click_cell";
            /**
                * Indicates when the cell was double-clicked.
                */
            DBLCLICK_CELL: "dblclick_cell";
            /**
                * Indicates when the cell was double-taped.
                */
            DBLTAP_CELL: "dbltap_cell";
            /**
                * Indicates when pointing device button is pressed in a cell.
                */
            MOUSEDOWN_CELL: "mousedown_cell";
            /**
                * Indicates when pointing device button is released in a cell.
                */
            MOUSEUP_CELL: "mouseup_cell";
            /**
                * Indicates the cell selection state has changed.
                */
            SELECTED_CELL: "selected_cell";
            /**
                * Indicates key-downed.
                */
            KEYDOWN: "keydown";
            MOUSEMOVE_CELL: "mousemove_cell";
            MOUSEENTER_CELL: "mouseenter_cell";
            MOUSELEAVE_CELL: "mouseleave_cell";
            MOUSEOVER_CELL: "mouseover_cell";
            MOUSEOUT_CELL: "mouseout_cell";
            /**
                * Indicates when the user attempts to open a context menu in the cell.
                */
            CONTEXTMENU_CELL: "contextmenu_cell";
            INPUT_CELL: "input_cell";
            PASTE_CELL: "paste_cell";
            DELETE_CELL: "delete_cell";
            EDITABLEINPUT_CELL: "editableinput_cell";
            MODIFY_STATUS_EDITABLEINPUT_CELL: "modify_status_editableinput_cell";
            /**
                * Indicates when the column width has changed.
                */
            RESIZE_COLUMN: "resize_column";
            /**
                * Indicates when scrolled.
                */
            SCROLL: "scroll";
            FOCUS_GRID: "focus_grid";
            BLUR_GRID: "blur_grid";
    }
    /**
        * DrawGrid event types
        * @classdesc cheetahGrid.core.EVENT_TYPE
        * @memberof cheetahGrid.core
        */
    export const DG_EVENT_TYPE: DrawGridEvents;
}

declare module 'cheetah-grid/data/DataSource' {
    import type { DataSourceAPI, FieldData, FieldDef, MaybePromise, MaybePromiseOrUndef } from "cheetah-grid/ts-types";
    import { EventTarget } from "cheetah-grid/core/EventTarget";
    import type { PromiseCacheValue } from "cheetah-grid/data/internal/types";
    /** @private */
    const EVENT_TYPE: {
            readonly UPDATE_LENGTH: "update_length";
            readonly UPDATED_LENGTH: "updated_length";
            readonly UPDATED_ORDER: "updated_order";
    };
    export interface DataSourceParam<T> {
            get: (index: number) => T;
            length: number;
            source?: any;
    }
    /**
        * grid data source
        *
        * @classdesc cheetahGrid.data.DataSource
        * @memberof cheetahGrid.data
        */
    export class DataSource<T> extends EventTarget implements DataSourceAPI<T> {
            protected _sortedIndexMap: null | number[];
            static get EVENT_TYPE(): typeof EVENT_TYPE;
            static ofArray<T>(array: T[]): DataSource<T>;
            constructor(obj?: DataSourceParam<T> | DataSource<T>);
            get source(): any;
            get(index: number): MaybePromiseOrUndef<T>;
            getField<F extends FieldDef<T>>(index: number, field: F): FieldData;
            hasField(index: number, field: FieldDef<T>): boolean;
            setField<F extends FieldDef<T>>(index: number, field: F, value: any): MaybePromise<boolean>;
            sort(field: FieldDef<T>, order: "desc" | "asc"): MaybePromise<void>;
            get length(): number;
            set length(length: number);
            get dataSource(): DataSource<T>;
            dispose(): void;
            protected getOriginal(index: number): MaybePromiseOrUndef<T>;
            protected getOriginalField<F extends FieldDef<T>>(index: number, field: F): FieldData;
            protected hasOriginalField(index: number, field: FieldDef<T>): boolean;
            protected setOriginalField<F extends FieldDef<T>>(index: number, field: F, value: any): MaybePromise<boolean>;
            protected fieldPromiseCallBackInternal<F extends FieldDef<T>>(_index: number, _field: F, _value: PromiseCacheValue<any>): void;
            protected recordPromiseCallBackInternal(_index: number, _record: PromiseCacheValue<T>): void;
            static EMPTY: DataSource<any>;
    }
    export {};
}

declare module 'cheetah-grid/data/CachedDataSource' {
    import type { FieldData, FieldDef, MaybePromise, MaybePromiseOrUndef } from "cheetah-grid/ts-types";
    import { DataSource } from "cheetah-grid/data/DataSource";
    import type { DataSourceParam } from "cheetah-grid/data/DataSource";
    import type { PromiseCacheValue } from "cheetah-grid/data/internal/types";
    /**
      * grid data source for caching Promise data
      *
      * @classdesc cheetahGrid.data.CachedDataSource
      * @memberof cheetahGrid.data
      */
    export class CachedDataSource<T> extends DataSource<T> {
        static get EVENT_TYPE(): typeof DataSource.EVENT_TYPE;
        static ofArray<T>(array: T[]): CachedDataSource<T>;
        constructor(opt?: DataSourceParam<T>);
        protected getOriginal(index: number): MaybePromiseOrUndef<T>;
        protected getOriginalField<F extends FieldDef<T>>(index: number, field: F): FieldData;
        protected setOriginalField<F extends FieldDef<T>>(index: number, field: F, value: any): MaybePromise<boolean>;
        clearCache(): void;
        protected fieldPromiseCallBackInternal<F extends FieldDef<T>>(index: number, field: F, value: PromiseCacheValue<any>): void;
        protected recordPromiseCallBackInternal(index: number, record: PromiseCacheValue<T>): void;
        dispose(): void;
    }
}

declare module 'cheetah-grid/data/FilterDataSource' {
    import type { FieldDef, MaybePromise, MaybePromiseOrUndef } from "cheetah-grid/ts-types";
    import { DataSource } from "cheetah-grid/data/DataSource";
    /** @private */
    type Filter<T> = (record: T | undefined) => boolean;
    /**
        * grid data source for filter
        *
        * @classdesc cheetahGrid.data.FilterDataSource
        * @memberof cheetahGrid.data
        */
    export class FilterDataSource<T> extends DataSource<T> {
            static get EVENT_TYPE(): typeof DataSource.EVENT_TYPE;
            constructor(dataSource: DataSource<T>, filter: Filter<T>);
            get filter(): Filter<T> | null;
            set filter(filter: Filter<T> | null);
            protected getOriginal(index: number): MaybePromiseOrUndef<T>;
            sort(field: FieldDef<T>, order: "desc" | "asc"): MaybePromise<void>;
            get source(): any;
            get dataSource(): DataSource<T>;
            dispose(): void;
    }
    export {};
}

declare module 'cheetah-grid/header/action' {
    import type { BaseActionOption, HeaderActionOption, SortHeaderActionOption } from "cheetah-grid/ts-types";
    import { BaseAction } from "cheetah-grid/header/action/BaseAction";
    import type { BaseHeaderDefine } from "cheetah-grid/list-grid/layout-map/api";
    import { CheckHeaderAction } from "cheetah-grid/header/action/CheckHeaderAction";
    import { SortHeaderAction } from "cheetah-grid/header/action/SortHeaderAction";
    class ImmutableSortHeaderAction<T> extends SortHeaderAction<T> {
        get disabled(): boolean;
    }
    class ImmutableCheckHeaderAction<T> extends CheckHeaderAction<T> {
        get disabled(): boolean;
    }
    export const ACTIONS: {
        SORT: ImmutableSortHeaderAction<any>;
        CHECK: ImmutableCheckHeaderAction<any>;
    };
    /**
      * column actions
      * @namespace cheetahGrid.columns.action
      * @memberof cheetahGrid.columns
      */
    export { BaseAction, SortHeaderAction, CheckHeaderAction, BaseActionOption, SortHeaderActionOption, };
    export function of<T>(headerAction: HeaderActionOption | BaseAction<T> | null | undefined): BaseAction<T> | undefined;
    export function ofCell<T>(headerCell: BaseHeaderDefine<T>): BaseAction<T> | undefined;
}

declare module 'cheetah-grid/header/style' {
    import type { BaseStyleOption, CheckHeaderStyleOption, HeaderStyleOption, SortHeaderStyleOption } from "cheetah-grid/ts-types";
    import { BaseStyle } from "cheetah-grid/header/style/BaseStyle";
    import { CheckHeaderStyle } from "cheetah-grid/header/style/CheckHeaderStyle";
    import { MultilineTextHeaderStyle } from "cheetah-grid/header/style/MultilineTextHeaderStyle";
    import { SortHeaderStyle } from "cheetah-grid/header/style/SortHeaderStyle";
    import { Style } from "cheetah-grid/header/style/Style";
    export { BaseStyle, Style, SortHeaderStyle, CheckHeaderStyle, BaseStyleOption, CheckHeaderStyleOption, MultilineTextHeaderStyle, SortHeaderStyleOption, };
    export function of(headerStyle: HeaderStyleOption | null | undefined, StyleClass: typeof BaseStyle): BaseStyle;
}

declare module 'cheetah-grid/header/type' {
    import { BaseHeader } from "cheetah-grid/header/type/BaseHeader";
    import type { BaseHeaderDefine } from "cheetah-grid/list-grid/layout-map/api";
    import { CheckHeader } from "cheetah-grid/header/type/CheckHeader";
    import { Header } from "cheetah-grid/header/type/Header";
    import type { HeaderTypeOption } from "cheetah-grid/ts-types";
    import { MultilineTextHeader } from "cheetah-grid/header/type/MultilineTextHeader";
    import { SortHeader } from "cheetah-grid/header/type/SortHeader";
    export { BaseHeader, Header, SortHeader, CheckHeader, MultilineTextHeader };
    export function of<T>(headerType: HeaderTypeOption | BaseHeader<T> | null | undefined): BaseHeader<T>;
    export function ofCell<T>(headerCell: BaseHeaderDefine<T>): BaseHeader<T>;
}

declare module 'cheetah-grid/themes/theme' {
    import type { ColorPropertyDefine, ColorsPropertyDefine, PartialThemeDefine, RequiredThemeDefine, ThemeDefine } from "cheetah-grid/ts-types";
    const _: "$$$$private symbol$$$$";
    export class Theme implements RequiredThemeDefine {
        constructor(obj: ThemeDefine);
        constructor(obj: PartialThemeDefine, superTheme: ThemeDefine);
        get font(): string;
        get underlayBackgroundColor(): string;
        get color(): ColorPropertyDefine;
        get frozenRowsColor(): ColorPropertyDefine;
        get defaultBgColor(): ColorPropertyDefine;
        get frozenRowsBgColor(): ColorPropertyDefine;
        get selectionBgColor(): ColorPropertyDefine;
        get highlightBgColor(): ColorPropertyDefine;
        get borderColor(): ColorsPropertyDefine;
        get frozenRowsBorderColor(): ColorsPropertyDefine;
        get highlightBorderColor(): ColorsPropertyDefine;
        get checkbox(): RequiredThemeDefine["checkbox"];
        get radioButton(): RequiredThemeDefine["radioButton"];
        get button(): RequiredThemeDefine["button"];
        get header(): RequiredThemeDefine["header"];
        hasProperty(names: string[]): boolean;
        extends(obj: PartialThemeDefine): Theme;
    }
    export {};
}

declare module 'cheetah-grid/tools/canvashelper' {
    import type { ColorDef } from "cheetah-grid/ts-types";
    import type { PaddingOption } from "cheetah-grid/internal/canvases";
    export function strokeColorsRect(ctx: CanvasRenderingContext2D, borderColors: [ColorDef | null, ColorDef | null, ColorDef | null, ColorDef | null], left: number, top: number, width: number, height: number): void;
    export function roundRect(ctx: CanvasRenderingContext2D, left: number, top: number, width: number, height: number, radius: number): void;
    export function fillRoundRect(ctx: CanvasRenderingContext2D, left: number, top: number, width: number, height: number, radius: number): void;
    export function strokeRoundRect(ctx: CanvasRenderingContext2D, left: number, top: number, width: number, height: number, radius: number): void;
    export function fillCircle(ctx: CanvasRenderingContext2D, left: number, top: number, width: number, height: number): void;
    export function strokeCircle(ctx: CanvasRenderingContext2D, left: number, top: number, width: number, height: number): void;
    export type FillTextRectOption = {
            offset?: number;
            padding?: PaddingOption;
    };
    export function fillTextRect(ctx: CanvasRenderingContext2D, text: string, left: number, top: number, width: number, height: number, { offset, padding }?: FillTextRectOption): void;
    export type DrawInlineImageRectOption = {
            offset?: number;
            padding?: PaddingOption;
    };
    export function drawInlineImageRect(ctx: CanvasRenderingContext2D, image: CanvasImageSource, srcLeft: number, srcTop: number, srcWidth: number, srcHeight: number, destWidth: number, destHeight: number, left: number, top: number, width: number, height: number, { offset, padding }?: DrawInlineImageRectOption): void;
    /**
        * Returns an object containing the width of the checkbox.
        * @param  {CanvasRenderingContext2D} ctx canvas context
        * @return {Object} Object containing the width of the checkbox
        * @memberof cheetahGrid.tools.canvashelper
        */
    export function measureCheckbox(ctx: CanvasRenderingContext2D): {
            width: number;
    };
    /**
        * Returns an object containing the width of the radio button.
        * @param  {CanvasRenderingContext2D} ctx canvas context
        * @return {Object} Object containing the width of the radio button
        * @memberof cheetahGrid.tools.canvashelper
        */
    export function measureRadioButton(ctx: CanvasRenderingContext2D): {
            width: number;
    };
    export type DrawCheckboxOption = {
            uncheckBgColor?: ColorDef;
            checkBgColor?: ColorDef;
            borderColor?: ColorDef;
            boxSize?: number;
    };
    /**
        * draw Checkbox
        * @param  {CanvasRenderingContext2D} ctx canvas context
        * @param  {number} x The x coordinate where to start drawing the checkbox (relative to the canvas)
        * @param  {number} y The y coordinate where to start drawing the checkbox (relative to the canvas)
        * @param  {boolean|number} check checkbox check status
        * @param  {object} option option
        * @return {void}
        * @memberof cheetahGrid.tools.canvashelper
        */
    export function drawCheckbox(ctx: CanvasRenderingContext2D, x: number, y: number, check: number | boolean, { uncheckBgColor, checkBgColor, borderColor, boxSize, }?: DrawCheckboxOption): void;
    export type DrawRadioButtonOption = {
            checkColor?: ColorDef;
            borderColor?: ColorDef;
            bgColor?: ColorDef;
            boxSize?: number;
    };
    /**
        * draw Radio button
        * @param  {CanvasRenderingContext2D} ctx canvas context
        * @param  {number} x The x coordinate where to start drawing the radio button (relative to the canvas)
        * @param  {number} y The y coordinate where to start drawing the radio button (relative to the canvas)
        * @param  {boolean|number} check radio button check status
        * @param  {object} option option
        * @return {void}
        * @memberof cheetahGrid.tools.canvashelper
        */
    export function drawRadioButton(ctx: CanvasRenderingContext2D, x: number, y: number, check: number | boolean, { checkColor, borderColor, bgColor, boxSize, }?: DrawRadioButtonOption): void;
    export type DrawButtonOption = {
            backgroundColor?: ColorDef;
            bgColor?: ColorDef;
            radius?: number;
            shadow?: {
                    color?: string;
                    blur?: number;
                    offsetX?: number;
                    offsetY?: number;
                    offset?: {
                            x?: number;
                            y?: number;
                    };
            };
    };
    /**
        * draw Button
        */
    export function drawButton(ctx: CanvasRenderingContext2D, left: number, top: number, width: number, height: number, option?: DrawButtonOption): void;
    export type Canvashelper = {
            roundRect: typeof roundRect;
            fillRoundRect: typeof fillRoundRect;
            strokeRoundRect: typeof strokeRoundRect;
            drawCheckbox: typeof drawCheckbox;
            measureCheckbox: typeof measureCheckbox;
            fillTextRect: typeof fillTextRect;
            drawButton: typeof drawButton;
            drawInlineImageRect: typeof drawInlineImageRect;
            strokeColorsRect: typeof strokeColorsRect;
    };
}

declare module 'cheetah-grid/list-grid/layout-map' {
    export { LayoutMapAPI, HeaderDefine, ColumnDefine, HeadersDefine, GroupHeaderDefine, LayoutDefine, } from "cheetah-grid/list-grid/layout-map/api";
    export { SimpleHeaderLayoutMap } from "cheetah-grid/list-grid/layout-map/internal/simple-header-layout";
    export { MultiLayoutMap } from "cheetah-grid/list-grid/layout-map/internal/multi-layout";
}

declare module 'cheetah-grid/columns/message/MessageHandler' {
    import type { MessageHandler as Base, DrawCellInfo } from "cheetah-grid/ts-types-internal";
    import type { CellContext, ColumnStyle, GridCanvasHelperAPI, ListGridAPI, Message } from "cheetah-grid/ts-types";
    import type { BaseMessage } from "cheetah-grid/columns/message/BaseMessage";
    export function hasMessage(message: Message): boolean;
    export class MessageHandler<T> implements Base<T> {
        constructor(grid: ListGridAPI<T>, getMessage: (col: number, row: number) => Message);
        dispose(): void;
        drawCellMessage(message: Message, context: CellContext, style: ColumnStyle, helper: GridCanvasHelperAPI, grid: ListGridAPI<T>, info: DrawCellInfo<T>): void;
        _attach(col: number, row: number, message: Message): void;
        _move(col: number, row: number): void;
        _detach(): void;
        _bindGridEvent(grid: ListGridAPI<T>, getMessage: (col: number, row: number) => Message): void;
        _getMessageInstanceOfMessage(message: Message): BaseMessage<T>;
    }
}

declare module 'cheetah-grid/list-grid/LG_EVENT_TYPE' {
    import type { DrawGridEvents } from "cheetah-grid/core/DG_EVENT_TYPE";
    export interface ListGridEvents extends DrawGridEvents {
            /**
                * Indicates when the cell value was changed.
                */
            CHANGED_VALUE: "changed_value";
            /**
                * Indicates when the header cell value was changed.
                */
            CHANGED_HEADER_VALUE: "changed_header_value";
    }
    export const LG_EVENT_TYPE: ListGridEvents;
}

declare module 'cheetah-grid/tooltip/TooltipHandler' {
    import type { ListGridAPI } from "cheetah-grid/ts-types";
    import { Tooltip } from "cheetah-grid/tooltip/Tooltip";
    export class TooltipHandler<T> {
        constructor(grid: ListGridAPI<T>);
        dispose(): void;
        _attach(col: number, row: number): void;
        _move(col: number, row: number): void;
        _detach(): void;
        _isAttachCell(col: number, row: number): boolean;
        _bindGridEvent(grid: ListGridAPI<T>): void;
        _getTooltipInstanceInfo(col: number, row: number): {
            instance: Tooltip<T>;
            type: string;
            content: string;
        } | null;
    }
}

declare module 'cheetah-grid/element/InlineDrawer' {
    import type { AnyFunction, ColorDef } from "cheetah-grid/ts-types";
    import { Inline } from "cheetah-grid/element/Inline";
    import type { InlineDrawOption } from "cheetah-grid/element/Inline";
    export type InlineDrawerFunction = (options: InlineDrawOption) => void;
    export class InlineDrawer extends Inline {
        constructor({ draw, width, color, }: {
            draw: InlineDrawerFunction;
            width: number;
            height: number;
            color?: ColorDef;
        });
        width(_arg: {
            ctx: CanvasRenderingContext2D;
        }): number;
        font(): string | null;
        color(): ColorDef | null;
        canDraw(): boolean;
        onReady(_callback: AnyFunction): void;
        draw({ ctx, canvashelper, rect, offset, offsetLeft, offsetRight, offsetTop, offsetBottom, }: InlineDrawOption): void;
        canBreak(): boolean;
        toString(): string;
    }
}

declare module 'cheetah-grid/ts-types-internal' {
    export * from "cheetah-grid/ts-types-internal/grid-engine";
    export * from "cheetah-grid/ts-types-internal/data";
}

declare module 'cheetah-grid/ts-types/column/type' {
    import type { ColumnMenuItemOptions } from "cheetah-grid/ts-types/define";
    export interface BaseColumnOption {
        fadeinWhenCallbackInPromise?: boolean | null;
    }
    export interface NumberColumnOption extends BaseColumnOption {
        format?: Intl.NumberFormat;
    }
    export interface ButtonColumnOption extends BaseColumnOption {
        caption?: string;
    }
    export interface MenuColumnOption extends BaseColumnOption {
        options?: ColumnMenuItemOptions;
    }
    export interface IconColumnOption extends BaseColumnOption {
        tagName?: string;
        className?: string;
        content?: string;
        name?: string;
        iconWidth?: number;
    }
    export interface PercentCompleteBarColumnOption extends BaseColumnOption {
        min?: number;
        max?: number;
        formatter?: (value: string) => string;
    }
    export interface BranchGraphColumnOption extends BaseColumnOption {
        start?: "top" | "bottom";
        cache?: boolean;
    }
    export type SimpleBranchGraphCommand = {
        command: "branch";
        branch: string | {
            from: string;
            to: string;
        };
    } | {
        command: "commit";
        branch: string;
    } | {
        command: "merge";
        branch: {
            from: string;
            to: string;
        };
    } | {
        command: "tag";
        branch: string;
        tag: string;
    };
    export type BranchGraphCommand = SimpleBranchGraphCommand | undefined | null | SimpleBranchGraphCommand[];
    export type ColumnTypeOption = "DEFAULT" | "default" | "NUMBER" | "number" | "CHECK" | "check" | "BUTTON" | "button" | "IMAGE" | "image" | "MULTILINETEXT" | "multilinetext";
    export type HeaderTypeOption = "DEFAULT" | "default" | "SORT" | "sort" | "CHECK" | "check";
}

declare module 'cheetah-grid/ts-types/column/style' {
    import type { LineClamp, TextOverflow } from "cheetah-grid/ts-types/define";
    import type { ColorDef } from "cheetah-grid/ts-types/base";
    export interface ColumnStyle {
        bgColor?: ColorDef;
        doChangeStyle(): void;
        clone(): ColumnStyle;
    }
    export interface BaseStyleOption {
        bgColor?: ColorDef;
    }
    export interface StdBaseStyleOption extends BaseStyleOption {
        textAlign?: CanvasTextAlign;
        textBaseline?: CanvasTextBaseline;
    }
    export interface StyleOption extends StdBaseStyleOption {
        color?: ColorDef;
        font?: string;
        padding?: number | string | (number | string)[];
        textOverflow?: TextOverflow;
    }
    export interface HeaderStdStyleOption extends StdBaseStyleOption {
        color?: ColorDef;
        font?: string;
        textOverflow?: TextOverflow;
    }
    export interface ButtonStyleOption extends StyleOption {
        buttonBgColor?: ColorDef;
    }
    export interface CheckStyleOption extends StdBaseStyleOption {
        uncheckBgColor?: ColorDef;
        checkBgColor?: ColorDef;
        borderColor?: ColorDef;
    }
    export interface RadioStyleOption extends StdBaseStyleOption {
        checkColor?: ColorDef;
        uncheckBorderColor?: ColorDef;
        checkBorderColor?: ColorDef;
        uncheckBgColor?: ColorDef;
        checkBgColor?: ColorDef;
    }
    export interface CheckHeaderStyleOption extends HeaderStdStyleOption {
        uncheckBgColor?: ColorDef;
        checkBgColor?: ColorDef;
        borderColor?: ColorDef;
    }
    export type NumberStyleOption = StyleOption;
    export interface MultilineTextStyleOption extends StyleOption {
        lineHeight?: string | number;
        autoWrapText?: boolean;
        lineClamp?: LineClamp;
    }
    export interface MultilineTextHeaderStyleOption extends HeaderStdStyleOption {
        lineHeight?: string | number;
        autoWrapText?: boolean;
        lineClamp?: LineClamp;
    }
    export interface MenuStyleOption extends StyleOption {
        appearance?: "menulist-button" | "none";
    }
    export interface ImageStyleOption extends StdBaseStyleOption {
        imageSizing?: "keep-aspect-ratio";
        margin?: number;
    }
    export type IconStyleOption = StyleOption;
    export interface BranchGraphStyleOption extends BaseStyleOption {
        branchColors?: ColorDef | ((name: string, index: number) => ColorDef);
        margin?: number;
        circleSize?: number;
        branchLineWidth?: number;
        mergeStyle?: "straight" | "bezier";
    }
    export interface PercentCompleteBarStyleOption extends StyleOption {
        barColor?: ColorDef | ((num: number) => ColorDef);
        barBgColor?: ColorDef;
        barHeight?: number;
    }
    export interface SortHeaderStyleOption extends HeaderStdStyleOption {
        sortArrowColor?: ColorDef;
    }
    export type ColumnStyleOption = string | ColumnStyle | BaseStyleOption | StdBaseStyleOption | StyleOption | ButtonStyleOption | CheckStyleOption | NumberStyleOption | MultilineTextStyleOption | MenuStyleOption | ImageStyleOption | IconStyleOption | BranchGraphStyleOption | PercentCompleteBarStyleOption | ((record: any) => string | ColumnStyle | BaseStyleOption | StdBaseStyleOption | StyleOption | ButtonStyleOption | CheckStyleOption | NumberStyleOption | MultilineTextStyleOption | MenuStyleOption | ImageStyleOption | IconStyleOption | BranchGraphStyleOption | PercentCompleteBarStyleOption);
    export type HeaderStyleOption = ColumnStyle | BaseStyleOption | HeaderStdStyleOption | CheckHeaderStyleOption | MultilineTextHeaderStyleOption | SortHeaderStyleOption | (() => ColumnStyle | BaseStyleOption | HeaderStdStyleOption | CheckHeaderStyleOption | MultilineTextHeaderStyleOption | SortHeaderStyleOption);
}

declare module 'cheetah-grid/ts-types/column/action' {
    import type { CellAddress } from "cheetah-grid/ts-types/grid";
    import type { ColumnMenuItemOptions } from "cheetah-grid/ts-types/define";
    import type { ListGridAPI } from "cheetah-grid/ts-types/grid-engine";
    import type { MaybePromise } from "cheetah-grid/ts-types/base";
    export type RecordBoolean<T = any> = boolean | ((record: T) => boolean);
    export interface BaseActionOption {
        disabled?: RecordBoolean;
    }
    export type ActionListener = (record: any, cell: CellAddress) => void;
    export interface ActionOption extends BaseActionOption {
        action?: ActionListener;
    }
    export interface EditorOption extends BaseActionOption {
        readOnly?: RecordBoolean;
    }
    export type ButtonActionOption = ActionOption;
    export interface InlineMenuEditorOption<T> extends EditorOption {
        classList?: string | string[];
        options?: ColumnMenuItemOptions | ((record: T | undefined) => ColumnMenuItemOptions);
    }
    export interface InlineInputEditorOption extends EditorOption {
        classList?: string | string[];
        type?: string;
    }
    type GetValueResult<T, R> = (value: string, info: {
        grid: ListGridAPI<T>;
        col: number;
        row: number;
    }) => R;
    export interface SmallDialogInputEditorOption<T> extends EditorOption {
        classList?: string | string[];
        type?: string;
        helperText?: string | GetValueResult<T, string>;
        inputValidator?: GetValueResult<T, MaybePromise<string>>;
        validator?: GetValueResult<T, MaybePromise<string>>;
    }
    export type GetRadioEditorGroup<T> = (target: {
        grid: ListGridAPI<T>;
        col: number;
        row: number;
    }) => CellAddress[];
    export interface RadioEditorOption<T> extends EditorOption {
        group?: GetRadioEditorGroup<T>;
    }
    export type SortOption<T> = boolean | ((arg: {
        order: "asc" | "desc";
        col: number;
        row: number;
        grid: ListGridAPI<T>;
    }) => void);
    export interface SortHeaderActionOption<T> extends BaseActionOption {
        sort?: SortOption<T>;
    }
    export type ColumnActionOption = "CHECK" | "check" | "INPUT" | "input";
    export type HeaderActionOption = "CHECK" | "check" | "SORT" | "sort";
    export {};
}

declare module 'cheetah-grid/ts-types-internal/data' {
    import type { ColorDef, MaybePromise } from "cheetah-grid/ts-types/base";
    export type SimpleColumnIconOption = {
        content?: string;
        font?: string;
        color?: ColorDef;
        className?: string;
        tagName?: string;
        isLiga?: boolean;
        width?: number;
        src?: MaybePromise<string>;
        svg?: string;
        name?: string;
        path?: string;
    };
}

declare module 'cheetah-grid/columns/action/Action' {
    import type { ActionListener, ActionOption, CellAddress, EventListenerId, LayoutObjectId, ListGridAPI } from "cheetah-grid/ts-types";
    import { BaseAction } from "cheetah-grid/columns/action/BaseAction";
    import type { GridInternal } from "cheetah-grid/ts-types-internal";
    export class Action<T> extends BaseAction<T> {
        constructor(option?: ActionOption);
        get editable(): boolean;
        get action(): ActionListener;
        set action(action: ActionListener);
        clone(): Action<T>;
        getState(_grid: GridInternal<T>): {
            mouseActiveCell?: CellAddress;
        };
        bindGridEvent(grid: ListGridAPI<T>, cellId: LayoutObjectId): EventListenerId[];
        onPasteCellRangeBox(): void;
        onDeleteCellRangeBox(): void;
    }
}

declare module 'cheetah-grid/columns/action/BaseAction' {
    import type { BaseActionOption, CellAddress, EventListenerId, LayoutObjectId, ListGridAPI, RecordBoolean } from "cheetah-grid/ts-types";
    export abstract class BaseAction<T> {
        protected _disabled: RecordBoolean;
        constructor(option?: BaseActionOption);
        abstract get editable(): boolean;
        get disabled(): RecordBoolean;
        set disabled(disabled: RecordBoolean);
        abstract clone(): BaseAction<T>;
        abstract bindGridEvent(grid: ListGridAPI<T>, cellId: LayoutObjectId): EventListenerId[];
        protected onChangeDisabledInternal(): void;
        abstract onPasteCellRangeBox(grid: ListGridAPI<T>, cell: CellAddress, value: string): void;
        abstract onDeleteCellRangeBox(grid: ListGridAPI<T>, cell: CellAddress): void;
    }
}

declare module 'cheetah-grid/columns/action/ButtonAction' {
    import type { ButtonColumnState, GridInternal } from "cheetah-grid/ts-types-internal";
    import { Action } from "cheetah-grid/columns/action/Action";
    export class ButtonAction<T> extends Action<T> {
        getState(grid: GridInternal<T>): ButtonColumnState;
    }
}

declare module 'cheetah-grid/columns/action/CheckEditor' {
    import type { CellAddress, EventListenerId, LayoutObjectId } from "cheetah-grid/ts-types";
    import { Editor } from "cheetah-grid/columns/action/Editor";
    import type { GridInternal } from "cheetah-grid/ts-types-internal";
    export class CheckEditor<T> extends Editor<T> {
        clone(): CheckEditor<T>;
        bindGridEvent(grid: GridInternal<T>, cellId: LayoutObjectId): EventListenerId[];
        onPasteCellRangeBox(grid: GridInternal<T>, cell: CellAddress, value: string): void;
        onDeleteCellRangeBox(): void;
    }
}

declare module 'cheetah-grid/columns/action/Editor' {
    import type { EditorOption, RecordBoolean } from "cheetah-grid/ts-types";
    import { BaseAction } from "cheetah-grid/columns/action/BaseAction";
    export abstract class Editor<T> extends BaseAction<T> {
        protected _readOnly: RecordBoolean;
        constructor(option?: EditorOption);
        get editable(): boolean;
        get readOnly(): RecordBoolean;
        set readOnly(readOnly: RecordBoolean);
        onChangeReadOnlyInternal(): void;
    }
}

declare module 'cheetah-grid/columns/action/InlineInputEditor' {
    import type { CellAddress, InlineInputEditorOption, ListGridAPI } from "cheetah-grid/ts-types";
    import { BaseInputEditor } from "cheetah-grid/columns/action/BaseInputEditor";
    export class InlineInputEditor<T> extends BaseInputEditor<T> {
        constructor(option?: InlineInputEditorOption);
        get classList(): string[] | undefined;
        set classList(classList: string[] | undefined);
        get type(): string | undefined;
        set type(type: string | undefined);
        clone(): InlineInputEditor<T>;
        onInputCellInternal(grid: ListGridAPI<T>, cell: CellAddress, inputValue: string): void;
        onOpenCellInternal(grid: ListGridAPI<T>, cell: CellAddress): void;
        onChangeSelectCellInternal(grid: ListGridAPI<T>, _cell: CellAddress, _selected: boolean): void;
        onGridScrollInternal(grid: ListGridAPI<T>): void;
        onChangeDisabledInternal(): void;
        onChangeReadOnlyInternal(): void;
        onSetInputAttrsInternal(grid: ListGridAPI<T>, _cell: CellAddress, input: HTMLInputElement): void;
    }
}

declare module 'cheetah-grid/columns/action/InlineMenuEditor' {
    import type { CellAddress, ColumnMenuItemOption, EventListenerId, InlineMenuEditorOption, LayoutObjectId, ListGridAPI } from "cheetah-grid/ts-types";
    import { Editor } from "cheetah-grid/columns/action/Editor";
    export class InlineMenuEditor<T> extends Editor<T> {
        constructor(option?: InlineMenuEditorOption<T>);
        dispose(): void;
        get classList(): string[] | undefined;
        set classList(classList: string[] | undefined);
        get options(): (record: T | undefined) => ColumnMenuItemOption[];
        set options(options: (record: T | undefined) => ColumnMenuItemOption[]);
        clone(): InlineMenuEditor<T>;
        onChangeDisabledInternal(): void;
        onChangeReadOnlyInternal(): void;
        bindGridEvent(grid: ListGridAPI<T>, cellId: LayoutObjectId): EventListenerId[];
        onPasteCellRangeBox(grid: ListGridAPI<T>, cell: CellAddress, value: string): void;
        onDeleteCellRangeBox(grid: ListGridAPI<T>, cell: CellAddress): void;
    }
}

declare module 'cheetah-grid/columns/action/RadioEditor' {
    import type { CellAddress, EventListenerId, GetRadioEditorGroup, LayoutObjectId, RadioEditorOption } from "cheetah-grid/ts-types";
    import { Editor } from "cheetah-grid/columns/action/Editor";
    import type { GridInternal } from "cheetah-grid/ts-types-internal";
    export class RadioEditor<T> extends Editor<T> {
        protected _group: GetRadioEditorGroup<T>;
        constructor(option?: RadioEditorOption<T>);
        clone(): RadioEditor<T>;
        get group(): GetRadioEditorGroup<T>;
        set group(group: GetRadioEditorGroup<T>);
        bindGridEvent(grid: GridInternal<T>, cellId: LayoutObjectId): EventListenerId[];
        onPasteCellRangeBox(grid: GridInternal<T>, cell: CellAddress, value: string): void;
        onDeleteCellRangeBox(): void;
    }
}

declare module 'cheetah-grid/columns/action/SmallDialogInputEditor' {
    import type { CellAddress, ListGridAPI, MaybePromise, SmallDialogInputEditorOption } from "cheetah-grid/ts-types";
    import { BaseInputEditor } from "cheetah-grid/columns/action/BaseInputEditor";
    type GetValueResult<T, R> = (value: string, info: {
        grid: ListGridAPI<T>;
        col: number;
        row: number;
    }) => R;
    export class SmallDialogInputEditor<T> extends BaseInputEditor<T> {
        constructor(option?: SmallDialogInputEditorOption<T>);
        dispose(): void;
        get classList(): string[] | undefined;
        set classList(classList: string[] | undefined);
        get type(): string | undefined;
        set type(type: string | undefined);
        get helperText(): string | GetValueResult<T, string> | undefined;
        get inputValidator(): GetValueResult<T, MaybePromise<string>> | undefined;
        get validator(): GetValueResult<T, MaybePromise<string>> | undefined;
        clone(): SmallDialogInputEditor<T>;
        onInputCellInternal(grid: ListGridAPI<T>, cell: CellAddress, inputValue: string): void;
        onOpenCellInternal(grid: ListGridAPI<T>, cell: CellAddress): void;
        onChangeSelectCellInternal(_grid: ListGridAPI<T>, _cell: CellAddress, _selected: boolean): void;
        onGridScrollInternal(_grid: ListGridAPI<T>): void;
        onChangeDisabledInternal(): void;
        onChangeReadOnlyInternal(): void;
        onSetInputAttrsInternal(grid: ListGridAPI<T>, _cell: CellAddress, input: HTMLInputElement): void;
    }
    export {};
}

declare module 'cheetah-grid/columns/style/BaseStyle' {
    import type { BaseStyleOption, ColorDef, ColumnStyle } from "cheetah-grid/ts-types";
    import { EventTarget } from "cheetah-grid/core/EventTarget";
    export class BaseStyle extends EventTarget implements ColumnStyle {
        static get EVENT_TYPE(): {
            CHANGE_STYLE: "change_style";
        };
        static get DEFAULT(): BaseStyle;
        constructor({ bgColor }?: BaseStyleOption);
        get bgColor(): ColorDef | undefined;
        set bgColor(bgColor: ColorDef | undefined);
        doChangeStyle(): void;
        clone(): BaseStyle;
    }
}

declare module 'cheetah-grid/columns/style/ButtonStyle' {
    import type { ButtonStyleOption, ColorDef } from "cheetah-grid/ts-types";
    import { Style } from "cheetah-grid/columns/style/Style";
    export class ButtonStyle extends Style {
        static get DEFAULT(): ButtonStyle;
        constructor(style?: ButtonStyleOption);
        get buttonBgColor(): ColorDef | undefined;
        set buttonBgColor(buttonBgColor: ColorDef | undefined);
        clone(): ButtonStyle;
    }
}

declare module 'cheetah-grid/columns/style/CheckStyle' {
    import type { CheckStyleOption, ColorDef } from "cheetah-grid/ts-types";
    import { StdBaseStyle } from "cheetah-grid/columns/style/StdBaseStyle";
    export class CheckStyle extends StdBaseStyle {
        static get DEFAULT(): CheckStyle;
        constructor(style?: CheckStyleOption);
        get uncheckBgColor(): ColorDef | undefined;
        set uncheckBgColor(uncheckBgColor: ColorDef | undefined);
        get checkBgColor(): ColorDef | undefined;
        set checkBgColor(checkBgColor: ColorDef | undefined);
        get borderColor(): ColorDef | undefined;
        set borderColor(borderColor: ColorDef | undefined);
        clone(): CheckStyle;
    }
}

declare module 'cheetah-grid/columns/style/IconStyle' {
    import type { IconStyleOption } from "cheetah-grid/ts-types";
    import { Style } from "cheetah-grid/columns/style/Style";
    export class IconStyle extends Style {
        static get DEFAULT(): IconStyle;
        constructor(style?: IconStyleOption);
        clone(): IconStyle;
    }
}

declare module 'cheetah-grid/columns/style/ImageStyle' {
    import type { ImageStyleOption } from "cheetah-grid/ts-types";
    import { StdBaseStyle } from "cheetah-grid/columns/style/StdBaseStyle";
    export class ImageStyle extends StdBaseStyle {
        static get DEFAULT(): ImageStyle;
        constructor(style?: ImageStyleOption);
        get imageSizing(): "keep-aspect-ratio" | undefined;
        set imageSizing(imageSizing: "keep-aspect-ratio" | undefined);
        get margin(): number;
        set margin(margin: number);
        clone(): ImageStyle;
    }
}

declare module 'cheetah-grid/columns/style/MenuStyle' {
    import type { MenuStyleOption } from "cheetah-grid/ts-types";
    import { Style } from "cheetah-grid/columns/style/Style";
    export class MenuStyle extends Style {
        static get DEFAULT(): MenuStyle;
        constructor(style?: MenuStyleOption);
        get appearance(): "menulist-button" | "none" | undefined;
        set appearance(appearance: "menulist-button" | "none" | undefined);
        clone(): MenuStyle;
    }
}

declare module 'cheetah-grid/columns/style/MultilineTextStyle' {
    import type { LineClamp, MultilineTextStyleOption } from "cheetah-grid/ts-types";
    import { Style } from "cheetah-grid/columns/style/Style";
    export class MultilineTextStyle extends Style {
        static get DEFAULT(): MultilineTextStyle;
        constructor(style?: MultilineTextStyleOption);
        clone(): MultilineTextStyle;
        get lineHeight(): string | number;
        set lineHeight(lineHeight: string | number);
        get lineClamp(): LineClamp | undefined;
        set lineClamp(lineClamp: LineClamp | undefined);
        get autoWrapText(): boolean;
        set autoWrapText(autoWrapText: boolean);
    }
}

declare module 'cheetah-grid/columns/style/NumberStyle' {
    import type { NumberStyleOption } from "cheetah-grid/ts-types";
    import { Style } from "cheetah-grid/columns/style/Style";
    export class NumberStyle extends Style {
        static get DEFAULT(): NumberStyle;
        constructor(style?: NumberStyleOption);
        clone(): NumberStyle;
    }
}

declare module 'cheetah-grid/columns/style/PercentCompleteBarStyle' {
    import type { ColorDef, PercentCompleteBarStyleOption } from "cheetah-grid/ts-types";
    import { Style } from "cheetah-grid/columns/style/Style";
    export class PercentCompleteBarStyle extends Style {
        static get DEFAULT(): PercentCompleteBarStyle;
        constructor(style?: PercentCompleteBarStyleOption);
        get barColor(): ColorDef | ((num: number) => ColorDef);
        set barColor(barColor: ColorDef | ((num: number) => ColorDef));
        get barBgColor(): ColorDef;
        set barBgColor(barBgColor: ColorDef);
        get barHeight(): number;
        set barHeight(barHeight: number);
        clone(): PercentCompleteBarStyle;
    }
}

declare module 'cheetah-grid/columns/style/RadioStyle' {
    import type { ColorDef, RadioStyleOption } from "cheetah-grid/ts-types";
    import { StdBaseStyle } from "cheetah-grid/columns/style/StdBaseStyle";
    export class RadioStyle extends StdBaseStyle {
        static get DEFAULT(): RadioStyle;
        constructor(style?: RadioStyleOption);
        get checkColor(): ColorDef | undefined;
        set checkColor(checkColor: ColorDef | undefined);
        get uncheckBorderColor(): ColorDef | undefined;
        set uncheckBorderColor(uncheckBorderColor: ColorDef | undefined);
        get checkBorderColor(): ColorDef | undefined;
        set checkBorderColor(checkBorderColor: ColorDef | undefined);
        get uncheckBgColor(): ColorDef | undefined;
        set uncheckBgColor(uncheckBgColor: ColorDef | undefined);
        get checkBgColor(): ColorDef | undefined;
        set checkBgColor(checkBgColor: ColorDef | undefined);
        clone(): RadioStyle;
    }
}

declare module 'cheetah-grid/columns/style/Style' {
    import type { ColorDef, StyleOption, TextOverflow } from "cheetah-grid/ts-types";
    import { StdBaseStyle } from "cheetah-grid/columns/style/StdBaseStyle";
    export class Style extends StdBaseStyle {
        static get DEFAULT(): Style;
        constructor(style?: StyleOption);
        get color(): ColorDef | undefined;
        set color(color: ColorDef | undefined);
        get font(): string | undefined;
        set font(font: string | undefined);
        get padding(): number | string | (number | string)[] | undefined;
        set padding(padding: number | string | (number | string)[] | undefined);
        get textOverflow(): TextOverflow;
        set textOverflow(textOverflow: TextOverflow);
        clone(): Style;
    }
}

declare module 'cheetah-grid/columns/type/BaseColumn' {
    import type { BaseColumnOption, CellAddress, CellContext, ColumnTypeAPI, EventListenerId, GridCanvasHelperAPI, LayoutObjectId, ListGridAPI, MaybePromise, Message } from "cheetah-grid/ts-types";
    import type { DrawCellInfo } from "cheetah-grid/ts-types-internal";
    import { BaseStyle } from "cheetah-grid/columns/style/BaseStyle";
    export abstract class BaseColumn<T, V> implements ColumnTypeAPI {
        constructor(option?: BaseColumnOption);
        get fadeinWhenCallbackInPromise(): boolean | undefined | null;
        get StyleClass(): typeof BaseStyle;
        onDrawCell(cellValue: MaybePromise<unknown>, info: DrawCellInfo<T>, context: CellContext, grid: ListGridAPI<T>): void | Promise<void>;
        abstract clone(): BaseColumn<T, V>;
        convertInternal(value: unknown): V;
        abstract drawInternal(value: V, context: CellContext, style: BaseStyle, helper: GridCanvasHelperAPI, grid: ListGridAPI<T>, info: DrawCellInfo<T>): void;
        drawMessageInternal(message: Message, context: CellContext, style: BaseStyle, helper: GridCanvasHelperAPI, grid: ListGridAPI<T>, info: DrawCellInfo<T>): void;
        bindGridEvent(_grid: ListGridAPI<T>, _cellId: LayoutObjectId): EventListenerId[];
        getCopyCellValue(value: V, _grid: ListGridAPI<T>, _cell: CellAddress): string;
    }
}

declare module 'cheetah-grid/columns/type/BranchGraphColumn' {
    import type { BranchGraphColumnOption, CellContext, GridCanvasHelperAPI, MaybePromise } from "cheetah-grid/ts-types";
    import type { DrawCellInfo, GridInternal } from "cheetah-grid/ts-types-internal";
    import { BaseColumn } from "cheetah-grid/columns/type/BaseColumn";
    import { BranchGraphStyle } from "cheetah-grid/columns/style/BranchGraphStyle";
    /**
      * BranchGraphColumn
      *
      * Data commands
      * - mastar branch or orphan branch
      *
      * ```js
      * {
      * 	command: 'branch',
      * 	branch: 'branch name A',
      * }
      * ```
      *
      * - commit
      *
      * ```js
      * {
      * 	command: 'commit',
      * 	branch: 'branch name A'
      * }
      * ```
      *
      * - branch
      *
      * ```js
      * {
      * 	command: 'branch',
      * 	branch: {
      * 		from: 'branch name A',
      * 		to: 'branch name B'
      * 	}
      * }
      * ```
      *
      * - merge
      *
      * ```js
      * {
      * 	command: 'merge',
      * 	branch: {
      * 		from: 'branch name B',
      * 		to: 'branch name A'
      * 	}
      * }
      * ```
      *
      * - tag
      *
      * ```js
      * {
      * 	command: 'tag',
      * 	branch: 'branch name A',
      * 	tag: 'tag name'
      * }
      * ```
      *
      * @memberof cheetahGrid.columns.type
      */
    export class BranchGraphColumn<T> extends BaseColumn<T, unknown> {
        constructor(option?: BranchGraphColumnOption);
        get StyleClass(): typeof BranchGraphStyle;
        clearCache(grid: GridInternal<T>): void;
        onDrawCell(cellValue: MaybePromise<unknown>, info: DrawCellInfo<T>, context: CellContext, grid: GridInternal<T>): void | Promise<void>;
        clone(): BranchGraphColumn<T>;
        drawInternal(_value: unknown, context: CellContext, style: BranchGraphStyle, helper: GridCanvasHelperAPI, grid: GridInternal<T>, { drawCellBase }: DrawCellInfo<T>): void;
    }
}

declare module 'cheetah-grid/columns/type/ButtonColumn' {
    import type { ButtonColumnOption, CellContext, GridCanvasHelperAPI } from "cheetah-grid/ts-types";
    import type { DrawCellInfo, GridInternal } from "cheetah-grid/ts-types-internal";
    import { ButtonStyle } from "cheetah-grid/columns/style/ButtonStyle";
    import { Column } from "cheetah-grid/columns/type/Column";
    export class ButtonColumn<T> extends Column<T> {
        constructor(option?: ButtonColumnOption);
        get StyleClass(): typeof ButtonStyle;
        get caption(): string | undefined;
        withCaption(caption: string): ButtonColumn<T>;
        clone(): ButtonColumn<T>;
        convertInternal(value: unknown): string;
        drawInternal(value: string, context: CellContext, style: ButtonStyle, helper: GridCanvasHelperAPI, grid: GridInternal<T>, { drawCellBase, getIcon }: DrawCellInfo<T>): void;
    }
}

declare module 'cheetah-grid/columns/type/CheckColumn' {
    import type { CellContext, GridCanvasHelperAPI } from "cheetah-grid/ts-types";
    import type { DrawCellInfo, GridInternal } from "cheetah-grid/ts-types-internal";
    import { BaseColumn } from "cheetah-grid/columns/type/BaseColumn";
    import { CheckStyle } from "cheetah-grid/columns/style/CheckStyle";
    export class CheckColumn<T> extends BaseColumn<T, boolean> {
        get StyleClass(): typeof CheckStyle;
        clone(): CheckColumn<T>;
        convertInternal(value: unknown): boolean;
        drawInternal(value: boolean, context: CellContext, style: CheckStyle, helper: GridCanvasHelperAPI, grid: GridInternal<T>, { drawCellBase }: DrawCellInfo<T>): void;
    }
}

declare module 'cheetah-grid/columns/type/Column' {
    import type { CellContext, GridCanvasHelperAPI, ListGridAPI } from "cheetah-grid/ts-types";
    import { BaseColumn } from "cheetah-grid/columns/type/BaseColumn";
    import type { DrawCellInfo } from "cheetah-grid/ts-types-internal";
    import { Style } from "cheetah-grid/columns/style/Style";
    export class Column<T> extends BaseColumn<T, string> {
        get StyleClass(): typeof Style;
        clone(): Column<T>;
        drawInternal(value: string, context: CellContext, style: Style, helper: GridCanvasHelperAPI, _grid: ListGridAPI<T>, { drawCellBase, getIcon }: DrawCellInfo<T>): void;
    }
}

declare module 'cheetah-grid/columns/type/IconColumn' {
    import type { CellContext, GridCanvasHelperAPI, IconColumnOption, ListGridAPI } from "cheetah-grid/ts-types";
    import { Column } from "cheetah-grid/columns/type/Column";
    import type { DrawCellInfo } from "cheetah-grid/ts-types-internal";
    import { IconStyle } from "cheetah-grid/columns/style/IconStyle";
    export class IconColumn<T> extends Column<T> {
        constructor(option?: IconColumnOption);
        get StyleClass(): typeof IconStyle;
        clone(): IconColumn<T>;
        drawInternal(value: string, context: CellContext, style: IconStyle, helper: GridCanvasHelperAPI, grid: ListGridAPI<T>, info: DrawCellInfo<T>): void;
    }
}

declare module 'cheetah-grid/columns/type/ImageColumn' {
    import type { CellContext, GridCanvasHelperAPI, ListGridAPI, MaybePromise } from "cheetah-grid/ts-types";
    import { BaseColumn } from "cheetah-grid/columns/type/BaseColumn";
    import type { DrawCellInfo } from "cheetah-grid/ts-types-internal";
    import { ImageStyle } from "cheetah-grid/columns/style/ImageStyle";
    export class ImageColumn<T> extends BaseColumn<T, HTMLImageElement> {
        get StyleClass(): typeof ImageStyle;
        onDrawCell(cellValue: MaybePromise<string>, info: DrawCellInfo<T>, context: CellContext, grid: ListGridAPI<T>): void | Promise<void>;
        clone(): ImageColumn<T>;
        drawInternal(value: HTMLImageElement, context: CellContext, style: ImageStyle, helper: GridCanvasHelperAPI, _grid: ListGridAPI<T>, { drawCellBase }: DrawCellInfo<T>): void;
    }
}

declare module 'cheetah-grid/columns/type/MenuColumn' {
    import type { CellContext, ColumnMenuItemOptions, GridCanvasHelperAPI, ListGridAPI, MenuColumnOption, SimpleColumnMenuItemOption } from "cheetah-grid/ts-types";
    import { BaseColumn } from "cheetah-grid/columns/type/BaseColumn";
    import type { DrawCellInfo } from "cheetah-grid/ts-types-internal";
    import { MenuStyle } from "cheetah-grid/columns/style/MenuStyle";
    export class MenuColumn<T> extends BaseColumn<T, unknown> {
        constructor(option?: MenuColumnOption);
        get StyleClass(): typeof MenuStyle;
        clone(): MenuColumn<T>;
        get options(): SimpleColumnMenuItemOption[];
        withOptions(options: ColumnMenuItemOptions): MenuColumn<T>;
        drawInternal(value: string, context: CellContext, style: MenuStyle, helper: GridCanvasHelperAPI, _grid: ListGridAPI<T>, { drawCellBase, getIcon }: DrawCellInfo<T>): void;
        convertInternal(value: unknown): unknown;
        _convertInternal(value: unknown): string;
        getCopyCellValue(value: unknown): string;
    }
}

declare module 'cheetah-grid/columns/type/MultilineTextColumn' {
    import type { CellContext, GridCanvasHelperAPI, ListGridAPI } from "cheetah-grid/ts-types";
    import { BaseColumn } from "cheetah-grid/columns/type/BaseColumn";
    import type { DrawCellInfo } from "cheetah-grid/ts-types-internal";
    import { MultilineTextStyle } from "cheetah-grid/columns/style/MultilineTextStyle";
    export class MultilineTextColumn<T> extends BaseColumn<T, string> {
        constructor(option?: {});
        get StyleClass(): typeof MultilineTextStyle;
        clone(): MultilineTextColumn<T>;
        drawInternal(value: string, context: CellContext, style: MultilineTextStyle, helper: GridCanvasHelperAPI, _grid: ListGridAPI<T>, { drawCellBase, getIcon }: DrawCellInfo<T>): void;
    }
}

declare module 'cheetah-grid/columns/type/NumberColumn' {
    import { Column } from "cheetah-grid/columns/type/Column";
    import type { NumberColumnOption } from "cheetah-grid/ts-types";
    import { NumberStyle } from "cheetah-grid/columns/style/NumberStyle";
    export class NumberColumn<T> extends Column<T> {
        static get defaultFotmat(): Intl.NumberFormat;
        static set defaultFotmat(fmt: Intl.NumberFormat);
        constructor(option?: NumberColumnOption);
        get StyleClass(): typeof NumberStyle;
        clone(): NumberColumn<T>;
        get format(): Intl.NumberFormat | undefined;
        withFormat(format: Intl.NumberFormat): NumberColumn<T>;
        convertInternal(value: undefined): string;
    }
}

declare module 'cheetah-grid/columns/type/PercentCompleteBarColumn' {
    import type { CellContext, GridCanvasHelperAPI, ListGridAPI, PercentCompleteBarColumnOption } from "cheetah-grid/ts-types";
    import { Column } from "cheetah-grid/columns/type/Column";
    import type { DrawCellInfo } from "cheetah-grid/ts-types-internal";
    import { PercentCompleteBarStyle } from "cheetah-grid/columns/style/PercentCompleteBarStyle";
    export class PercentCompleteBarColumn<T> extends Column<T> {
        constructor(option?: PercentCompleteBarColumnOption);
        get StyleClass(): typeof PercentCompleteBarStyle;
        clone(): PercentCompleteBarColumn<T>;
        drawInternal(value: string, context: CellContext, style: PercentCompleteBarStyle, helper: GridCanvasHelperAPI, grid: ListGridAPI<T>, info: DrawCellInfo<T>): void;
    }
}

declare module 'cheetah-grid/columns/type/RadioColumn' {
    import type { CellContext, GridCanvasHelperAPI } from "cheetah-grid/ts-types";
    import type { DrawCellInfo, GridInternal } from "cheetah-grid/ts-types-internal";
    import { BaseColumn } from "cheetah-grid/columns/type/BaseColumn";
    import { RadioStyle } from "cheetah-grid/columns/style/RadioStyle";
    export class RadioColumn<T> extends BaseColumn<T, boolean> {
        get StyleClass(): typeof RadioStyle;
        clone(): RadioColumn<T>;
        convertInternal(value: unknown): boolean;
        drawInternal(value: boolean, context: CellContext, style: RadioStyle, helper: GridCanvasHelperAPI, grid: GridInternal<T>, { drawCellBase }: DrawCellInfo<T>): void;
    }
}

declare module 'cheetah-grid/internal/EventHandler' {
    import type { AnyFunction, EventListenerId } from "cheetah-grid/ts-types";
    import type { EventTarget as CustomEventTarget } from "cheetah-grid/core/EventTarget";
    /** @private */
    type EventHandlerTarget = EventTarget | CustomEventTarget;
    /** @private */
    type Listener = AnyFunction;
    export class EventHandler {
        on<TYPE extends keyof GlobalEventHandlersEventMap>(target: EventHandlerTarget, type: TYPE, listener: (event: GlobalEventHandlersEventMap[TYPE]) => any, ...options: any[]): EventListenerId;
        on(target: EventHandlerTarget, type: string, listener: Listener, ...options: any[]): EventListenerId;
        once<TYPE extends keyof GlobalEventHandlersEventMap>(target: EventHandlerTarget, type: TYPE, listener: (event: GlobalEventHandlersEventMap[TYPE]) => any, ...options: any[]): EventListenerId;
        once(target: EventHandlerTarget, type: string, listener: Listener, ...options: (boolean | AddEventListenerOptions)[]): EventListenerId;
        tryWithOffEvents(target: EventHandlerTarget, type: string, call: () => void): void;
        off(id: EventListenerId | null | undefined): void;
        fire(target: EventTarget, type: string, ...args: any[]): void;
        hasListener(target: EventTarget, type: string): boolean;
        clear(): void;
        dispose(): void;
    }
    export {};
}

declare module 'cheetah-grid/core/EventTarget' {
    import type { AnyListener, EventListenerId } from "cheetah-grid/ts-types";
    /** @private */
    const _: "$$$$private symbol$$$$";
    /**
        * event target.
        */
    export class EventTarget {
            /**
                * Adds an event listener.
                * @param  {string} type The event type id.
                * @param  {function} listener Callback method.
                * @return {number} unique id for the listener.
                */
            listen(type: string, listener: AnyListener): EventListenerId;
            /**
                * Removes an event listener which was added with listen() by the id returned by listen().
                * @param  {number} id the id returned by listen().
                * @return {void}
                */
            unlisten(id: EventListenerId): void;
            addEventListener(type: string, listener: AnyListener): void;
            removeEventListener(type: string, listener: AnyListener): void;
            hasListeners(type: string): boolean;
            /**
                * Fires all registered listeners
                * @param  {string}    type The type of the listeners to fire.
                * @param  {...*} args fire arguments
                * @return {*} the result of the last listener
                */
            fireListeners(type: string, ...args: any[]): any;
            dispose(): void;
    }
    export {};
}

declare module 'cheetah-grid/internal/NumberMap' {
    export class NumberMap<T> {
        put(key: number, value: T): void;
        get(key: number): T | undefined;
        has(key: number): boolean;
        each(keyFrom: number, keyTo: number, fn: (t: T, k: number) => void): void;
    }
}

declare module 'cheetah-grid/internal/Rect' {
    import type { RectProps } from "cheetah-grid/ts-types";
    export class Rect implements RectProps {
        constructor(left: number, top: number, width: number, height: number);
        static bounds(left: number, top: number, right: number, bottom: number): Rect;
        static max(rect1: Rect, rect2: Rect): Rect;
        get left(): number;
        set left(left: number);
        get top(): number;
        set top(top: number);
        get width(): number;
        set width(width: number);
        get height(): number;
        set height(height: number);
        get right(): number;
        set right(right: number);
        get bottom(): number;
        set bottom(bottom: number);
        offsetLeft(offset: number): void;
        offsetTop(offset: number): void;
        copy(): Rect;
        intersection(rect: Rect): Rect | null;
        contains(another: Rect): boolean;
        inPoint(x: number, y: number): boolean;
    }
}

declare module 'cheetah-grid/internal/Scrollable' {
    export class Scrollable {
        constructor();
        calcTop(top: number): number;
        getElement(): HTMLDivElement;
        setScrollSize(width: number, height: number): void;
        get scrollWidth(): number;
        set scrollWidth(width: number);
        get scrollHeight(): number;
        set scrollHeight(height: number);
        get scrollLeft(): number;
        set scrollLeft(scrollLeft: number);
        get scrollTop(): number;
        set scrollTop(scrollTop: number);
        onScroll(fn: (evt: Event) => void): void;
        dispose(): void;
    }
}

declare module 'cheetah-grid/data/internal/types' {
    import type { MaybePromiseOrUndef } from "cheetah-grid/ts-types";
    export type PromiseCacheValue<V> = MaybePromiseOrUndef<V>;
}

declare module 'cheetah-grid/header/action/BaseAction' {
    import type { BaseActionOption, EventListenerId, LayoutObjectId, ListGridAPI } from "cheetah-grid/ts-types";
    export class BaseAction<T> {
        protected _disabled: boolean;
        constructor(option?: BaseActionOption);
        get disabled(): boolean;
        set disabled(disabled: boolean);
        clone(): BaseAction<T>;
        bindGridEvent(_grid: ListGridAPI<T>, _cellId: LayoutObjectId): EventListenerId[];
        onChangeDisabledInternal(): void;
    }
}

declare module 'cheetah-grid/list-grid/layout-map/api' {
    import type * as headerAction from "cheetah-grid/header/action";
    import type * as headerType from "cheetah-grid/header/type";
    import type { CellRange, ColumnActionOption, ColumnIconOption, ColumnStyleOption, ColumnTypeOption, FieldDef, HeaderActionOption, HeaderStyleOption, HeaderTypeOption, LayoutObjectId, ListGridAPI, Message } from "cheetah-grid/ts-types";
    import type { BaseAction } from "cheetah-grid/columns/action";
    import type { BaseColumn } from "cheetah-grid/columns/type/BaseColumn";
    import type { BaseStyle as HeaderBaseStyle } from "cheetah-grid/header/style";
    export type OldSortOption<T> = boolean | ((order: "asc" | "desc", col: number, grid: ListGridAPI<T>) => void);
    export interface BaseHeaderDefine<T> {
        caption?: string | (() => string);
        headerField?: string;
        headerStyle?: HeaderStyleOption | HeaderBaseStyle | null;
        headerType?: HeaderTypeOption | headerType.BaseHeader<T> | null;
        headerAction?: HeaderActionOption | headerAction.BaseAction<T> | null;
        sort?: OldSortOption<T>;
    }
    export interface HeaderDefine<T> extends BaseHeaderDefine<T> {
    }
    export interface ColumnDefine<T> extends BaseHeaderDefine<T> {
        field?: FieldDef<T>;
        width?: number | string;
        minWidth?: number | string;
        maxWidth?: number | string;
        icon?: ColumnIconOption<T> | ColumnIconOption<T>[];
        message?: Message | ((record: T) => Message) | keyof T | (Message | ((record: T) => Message) | keyof T)[];
        columnType?: ColumnTypeOption | BaseColumn<T, any> | null;
        action?: ColumnActionOption | BaseAction<T> | null;
        style?: ColumnStyleOption | null;
    }
    export interface HeaderData<T> {
        id: LayoutObjectId;
        caption?: string | (() => string);
        field?: any;
        style?: HeaderStyleOption | HeaderBaseStyle | null;
        headerType: headerType.BaseHeader<T>;
        action?: headerAction.BaseAction<T>;
        define: HeaderDefine<T>;
    }
    export interface WidthData {
        width?: number | string;
        minWidth?: number | string;
        maxWidth?: number | string;
    }
    export interface ColumnData<T> extends WidthData {
        id: LayoutObjectId;
        field?: FieldDef<T>;
        icon?: ColumnIconOption<T> | ColumnIconOption<T>[];
        message?: Message | ((record: T) => Message) | keyof T | (Message | ((record: T) => Message) | keyof T)[];
        columnType: BaseColumn<T, any>;
        action?: BaseAction<T>;
        style: ColumnStyleOption | null | undefined;
        define: ColumnDefine<T>;
    }
    export interface GroupHeaderDefine<T> extends HeaderDefine<T> {
        columns: HeadersDefine<T>;
    }
    export type HeadersDefine<T> = (GroupHeaderDefine<T> | ColumnDefine<T>)[];
    export interface HeaderCellDefine<T> extends HeaderDefine<T> {
        colSpan?: number;
        rowSpan?: number;
    }
    export interface CellDefine<T> extends ColumnDefine<T> {
        colSpan?: number;
        rowSpan?: number;
    }
    export type HeaderBodyLayoutDefine<T> = {
        header: HeaderCellDefine<T>[][];
        body: CellDefine<T>[][];
    };
    export type ArrayLayoutDefine<T> = CellDefine<T>[][];
    export type LayoutDefine<T> = HeaderBodyLayoutDefine<T> | ArrayLayoutDefine<T>;
    /** @internal */
    interface LayoutMapAPI<T> {
        readonly headerRowCount: number;
        readonly bodyRowCount: number;
        readonly colCount: number;
        readonly columnWidths: WidthData[];
        readonly headerObjects: HeaderData<T>[];
        readonly columnObjects: ColumnData<T>[];
        getHeader(col: number, row: number): HeaderData<T>;
        getBody(col: number, row: number): ColumnData<T>;
        getCellId(col: number, row: number): LayoutObjectId;
        getCellRange(col: number, row: number): CellRange;
        getBodyLayoutRangeById(id: LayoutObjectId): CellRange;
        getRecordIndexByRow(row: number): number;
        getRecordStartRowByRecordIndex(index: number): number;
    }
    export type { LayoutMapAPI };
}

declare module 'cheetah-grid/header/action/CheckHeaderAction' {
    import type { EventListenerId, LayoutObjectId } from "cheetah-grid/ts-types";
    import type { GridInternal } from "cheetah-grid/ts-types-internal";
    import { BaseAction } from "cheetah-grid/header/action/BaseAction";
    export class CheckHeaderAction<T> extends BaseAction<T> {
        clone(): CheckHeaderAction<T>;
        bindGridEvent(grid: GridInternal<T>, cellId: LayoutObjectId): EventListenerId[];
    }
}

declare module 'cheetah-grid/header/action/SortHeaderAction' {
    import type { EventListenerId, LayoutObjectId, ListGridAPI, SortHeaderActionOption, SortOption, SortState } from "cheetah-grid/ts-types";
    import { BaseAction } from "cheetah-grid/header/action/BaseAction";
    export class SortHeaderAction<T> extends BaseAction<T> {
        constructor(option?: SortHeaderActionOption<T>);
        get sort(): SortOption<T>;
        set sort(sort: SortOption<T>);
        clone(): SortHeaderAction<T>;
        _executeSort(newState: SortState, grid: ListGridAPI<T>): void;
        bindGridEvent(grid: ListGridAPI<T>, cellId: LayoutObjectId): EventListenerId[];
    }
}

declare module 'cheetah-grid/header/style/BaseStyle' {
    import type { BaseStyleOption, ColorDef, ColumnStyle } from "cheetah-grid/ts-types";
    import { EventTarget } from "cheetah-grid/core/EventTarget";
    export class BaseStyle extends EventTarget implements ColumnStyle {
        static get EVENT_TYPE(): {
            CHANGE_STYLE: string;
        };
        static get DEFAULT(): BaseStyle;
        constructor({ bgColor }?: BaseStyleOption);
        get bgColor(): ColorDef | undefined;
        set bgColor(bgColor: ColorDef | undefined);
        doChangeStyle(): void;
        clone(): BaseStyle;
    }
}

declare module 'cheetah-grid/header/style/CheckHeaderStyle' {
    import type { CheckHeaderStyleOption, ColorDef } from "cheetah-grid/ts-types";
    import { Style } from "cheetah-grid/header/style/Style";
    export class CheckHeaderStyle extends Style {
        static get DEFAULT(): CheckHeaderStyle;
        constructor(style?: CheckHeaderStyleOption);
        get uncheckBgColor(): ColorDef | undefined;
        set uncheckBgColor(uncheckBgColor: ColorDef | undefined);
        get checkBgColor(): ColorDef | undefined;
        set checkBgColor(checkBgColor: ColorDef | undefined);
        get borderColor(): ColorDef | undefined;
        set borderColor(borderColor: ColorDef | undefined);
        clone(): CheckHeaderStyle;
    }
}

declare module 'cheetah-grid/header/style/MultilineTextHeaderStyle' {
    import type { LineClamp, MultilineTextHeaderStyleOption } from "cheetah-grid/ts-types";
    import { Style } from "cheetah-grid/header/style/Style";
    export class MultilineTextHeaderStyle extends Style {
        static get DEFAULT(): MultilineTextHeaderStyle;
        constructor(style?: MultilineTextHeaderStyleOption);
        clone(): MultilineTextHeaderStyle;
        get lineHeight(): string | number;
        set lineHeight(lineHeight: string | number);
        get lineClamp(): LineClamp | undefined;
        set lineClamp(lineClamp: LineClamp | undefined);
        get autoWrapText(): boolean;
        set autoWrapText(autoWrapText: boolean);
    }
}

declare module 'cheetah-grid/header/style/SortHeaderStyle' {
    import type { ColorDef, SortHeaderStyleOption } from "cheetah-grid/ts-types";
    import { Style } from "cheetah-grid/header/style/Style";
    export class SortHeaderStyle extends Style {
        static get DEFAULT(): SortHeaderStyle;
        constructor(style?: SortHeaderStyleOption);
        get sortArrowColor(): ColorDef | undefined;
        set sortArrowColor(sortArrowColor: ColorDef | undefined);
        clone(): SortHeaderStyle;
    }
}

declare module 'cheetah-grid/header/style/Style' {
    import type { ColorDef, HeaderStdStyleOption, TextOverflow } from "cheetah-grid/ts-types";
    import { StdBaseStyle } from "cheetah-grid/header/style/StdBaseStyle";
    export class Style extends StdBaseStyle {
        static get DEFAULT(): Style;
        constructor(style?: HeaderStdStyleOption);
        get color(): ColorDef | undefined;
        set color(color: ColorDef | undefined);
        get font(): string | undefined;
        set font(font: string | undefined);
        get textOverflow(): TextOverflow;
        set textOverflow(textOverflow: TextOverflow);
        clone(): Style;
    }
}

declare module 'cheetah-grid/header/type/BaseHeader' {
    import type { CellContext, EventListenerId, GridCanvasHelperAPI, LayoutObjectId, ListGridAPI } from "cheetah-grid/ts-types";
    import { BaseStyle } from "cheetah-grid/header/style/BaseStyle";
    import type { DrawCellInfo } from "cheetah-grid/ts-types-internal";
    export abstract class BaseHeader<T> {
        constructor(_options?: {});
        get StyleClass(): typeof BaseStyle;
        onDrawCell(cellValue: unknown, info: DrawCellInfo<T>, context: CellContext, grid: ListGridAPI<T>): void;
        convertInternal(value: unknown): string;
        abstract drawInternal(value: string, context: CellContext, style: BaseStyle, helper: GridCanvasHelperAPI, grid: ListGridAPI<T>, info: DrawCellInfo<T>): void;
        bindGridEvent(_grid: ListGridAPI<T>, _cellId: LayoutObjectId): EventListenerId[];
    }
}

declare module 'cheetah-grid/header/type/CheckHeader' {
    import type { CellContext, GridCanvasHelperAPI } from "cheetah-grid/ts-types";
    import type { DrawCellInfo, GridInternal } from "cheetah-grid/ts-types-internal";
    import { BaseHeader } from "cheetah-grid/header/type/BaseHeader";
    import { CheckHeaderStyle } from "cheetah-grid/header/style/CheckHeaderStyle";
    export class CheckHeader<T> extends BaseHeader<T> {
        get StyleClass(): typeof CheckHeaderStyle;
        clone(): CheckHeader<T>;
        drawInternal(value: string, context: CellContext, style: CheckHeaderStyle, helper: GridCanvasHelperAPI, grid: GridInternal<T>, { drawCellBase }: DrawCellInfo<T>): void;
    }
}

declare module 'cheetah-grid/header/type/Header' {
    import type { CellContext, GridCanvasHelperAPI, ListGridAPI } from "cheetah-grid/ts-types";
    import { BaseHeader } from "cheetah-grid/header/type/BaseHeader";
    import type { DrawCellInfo } from "cheetah-grid/ts-types-internal";
    import { Style } from "cheetah-grid/header/style/Style";
    export class Header<T> extends BaseHeader<T> {
        get StyleClass(): typeof Style;
        drawInternal(value: string, context: CellContext, style: Style, helper: GridCanvasHelperAPI, _grid: ListGridAPI<T>, { drawCellBase }: DrawCellInfo<T>): void;
    }
}

declare module 'cheetah-grid/header/type/MultilineTextHeader' {
    import type { CellContext, GridCanvasHelperAPI } from "cheetah-grid/ts-types";
    import type { DrawCellInfo, GridInternal } from "cheetah-grid/ts-types-internal";
    import { BaseHeader } from "cheetah-grid/header/type/BaseHeader";
    import { MultilineTextHeaderStyle } from "cheetah-grid/header/style/MultilineTextHeaderStyle";
    export class MultilineTextHeader<T> extends BaseHeader<T> {
        get StyleClass(): typeof MultilineTextHeaderStyle;
        clone(): MultilineTextHeader<T>;
        drawInternal(value: string, context: CellContext, style: MultilineTextHeaderStyle, helper: GridCanvasHelperAPI, _grid: GridInternal<T>, { drawCellBase }: DrawCellInfo<T>): void;
    }
}

declare module 'cheetah-grid/header/type/SortHeader' {
    import type { CellContext, GridCanvasHelperAPI, ListGridAPI } from "cheetah-grid/ts-types";
    import { BaseHeader } from "cheetah-grid/header/type/BaseHeader";
    import type { DrawCellInfo } from "cheetah-grid/ts-types-internal";
    import { SortHeaderStyle } from "cheetah-grid/header/style/SortHeaderStyle";
    export class SortHeader<T> extends BaseHeader<T> {
        get StyleClass(): typeof SortHeaderStyle;
        drawInternal(value: string, context: CellContext, style: SortHeaderStyle, helper: GridCanvasHelperAPI, grid: ListGridAPI<T>, { drawCellBase }: DrawCellInfo<T>): void;
    }
}

declare module 'cheetah-grid/internal/canvases' {
    import type { RectProps } from "cheetah-grid/ts-types";
    export type PaddingOption = {
        left?: number;
        right?: number;
        top?: number;
        bottom?: number;
    };
    export function getFontSize(ctx: CanvasRenderingContext2D, font: string | null | undefined): {
        width: number;
        height: number;
    };
    export function calcBasePosition(ctx: CanvasRenderingContext2D, rect: RectProps, { offset, padding: { left: paddingLeft, right: paddingRight, top: paddingTop, bottom: paddingBottom, }, }?: {
        offset?: number;
        padding?: PaddingOption;
    }): {
        x: number;
        y: number;
    };
    export function calcStartPosition(ctx: CanvasRenderingContext2D, rect: RectProps, width: number, height: number, { offset, padding: { left: paddingLeft, right: paddingRight, top: paddingTop, bottom: paddingBottom, }, }?: {
        offset?: number;
        padding?: PaddingOption;
    }): {
        x: number;
        y: number;
    };
}

declare module 'cheetah-grid/list-grid/layout-map/internal/simple-header-layout' {
    import type { CellRange, LayoutObjectId } from "cheetah-grid/ts-types";
    import type { ColumnData, HeaderData, HeadersDefine, LayoutMapAPI } from "cheetah-grid/list-grid/layout-map/api";
    export class SimpleHeaderLayoutMap<T> implements LayoutMapAPI<T> {
        readonly bodyRowCount: number;
        constructor(header: HeadersDefine<T>);
        get columnWidths(): ColumnData<T>[];
        get headerRowCount(): number;
        get colCount(): number;
        get headerObjects(): HeaderData<T>[];
        get columnObjects(): ColumnData<T>[];
        getCellId(col: number, row: number): LayoutObjectId;
        getHeader(col: number, row: number): HeaderData<T>;
        getBody(col: number, _row: number): ColumnData<T>;
        getBodyLayoutRangeById(id: LayoutObjectId): CellRange;
        getCellRange(col: number, row: number): CellRange;
        getRecordIndexByRow(row: number): number;
        getRecordStartRowByRecordIndex(index: number): number;
    }
}

declare module 'cheetah-grid/list-grid/layout-map/internal/multi-layout' {
    import type { ColumnData, HeaderData, LayoutDefine, LayoutMapAPI, WidthData } from "cheetah-grid/list-grid/layout-map/api";
    import type { CellRange, LayoutObjectId } from "cheetah-grid/ts-types";
    export class MultiLayoutMap<T> implements LayoutMapAPI<T> {
        constructor(layout: LayoutDefine<T>);
        get columnWidths(): WidthData[];
        get headerRowCount(): number;
        get bodyRowCount(): number;
        get colCount(): number;
        get headerObjects(): HeaderData<T>[];
        get columnObjects(): ColumnData<T>[];
        getCellId(col: number, row: number): LayoutObjectId;
        getHeader(col: number, row: number): HeaderData<T>;
        getBody(col: number, row: number): ColumnData<T>;
        getBodyLayoutRangeById(id: LayoutObjectId): CellRange;
        getCellRange(col: number, row: number): CellRange;
        getRecordIndexByRow(row: number): number;
        getRecordStartRowByRecordIndex(index: number): number;
    }
}

declare module 'cheetah-grid/columns/message/BaseMessage' {
    import type { CellContext, ColumnStyle, GridCanvasHelperAPI, ListGridAPI, MessageObject } from "cheetah-grid/ts-types";
    import type { DrawCellInfo } from "cheetah-grid/ts-types-internal";
    import type { MessageElement } from "cheetah-grid/columns/message/internal/MessageElement";
    export abstract class BaseMessage<T> {
        constructor(grid: ListGridAPI<T>);
        dispose(): void;
        _getMessageElement(): MessageElement;
        abstract createMessageElementInternal(): MessageElement;
        abstract drawCellMessageInternal(message: MessageObject, context: CellContext, style: ColumnStyle, helper: GridCanvasHelperAPI, grid: ListGridAPI<T>, info: DrawCellInfo<T>): void;
        attachMessageElement(col: number, row: number, message: MessageObject): void;
        moveMessageElement(col: number, row: number): void;
        detachMessageElement(): void;
        drawCellMessage(message: MessageObject, context: CellContext, style: ColumnStyle, helper: GridCanvasHelperAPI, grid: ListGridAPI<T>, info: DrawCellInfo<T>): void;
    }
}

declare module 'cheetah-grid/tooltip/Tooltip' {
    import { BaseTooltip } from "cheetah-grid/tooltip/BaseTooltip";
    import { TooltipElement } from "cheetah-grid/tooltip/internal/TooltipElement";
    export class Tooltip<T> extends BaseTooltip<T> {
        createTooltipElementInternal(): TooltipElement<T>;
    }
}

declare module 'cheetah-grid/element/Inline' {
    import type { AnyFunction, ColorDef, InlineAPI, RectProps } from "cheetah-grid/ts-types";
    import type { Canvashelper } from "cheetah-grid/tools/canvashelper";
    export type InlineDrawOption = {
        ctx: CanvasRenderingContext2D;
        canvashelper: Canvashelper;
        rect: RectProps;
        offset: number;
        offsetLeft: number;
        offsetRight: number;
        offsetTop: number;
        offsetBottom: number;
    };
    export class Inline implements InlineAPI {
        constructor(content?: string);
        width({ ctx }: {
            ctx: CanvasRenderingContext2D;
        }): number;
        font(): string | null;
        color(): ColorDef | null;
        canDraw(): boolean;
        onReady(_callback: AnyFunction): void;
        draw({ ctx, canvashelper, rect, offset, offsetLeft, offsetRight, offsetTop, offsetBottom, }: InlineDrawOption): void;
        canBreak(): boolean;
        splitIndex(index: number): {
            before: Inline | null;
            after: Inline | null;
        };
        breakWord(ctx: CanvasRenderingContext2D, width: number): {
            before: Inline | null;
            after: Inline | null;
        };
        breakAll(ctx: CanvasRenderingContext2D, width: number): {
            before: Inline | null;
            after: Inline | null;
        };
        toString(): string;
    }
}

declare module 'cheetah-grid/ts-types-internal/grid-engine' {
    import type { CellAddress, FieldDef } from "cheetah-grid/ts-types/grid";
    import type { CellContext, GridCanvasHelperAPI, ListGridAPI } from "cheetah-grid/ts-types/grid-engine";
    import type { ColorPropertyDefine, ColumnIconOption } from "cheetah-grid/ts-types/define";
    import type { ColumnStyle, ColumnStyleOption, HeaderStyleOption } from "cheetah-grid/ts-types/column";
    import type { Message } from "cheetah-grid/ts-types/data";
    export interface MessageHandler<T> {
        drawCellMessage(message: Message, context: CellContext, style: ColumnStyle, helper: GridCanvasHelperAPI, grid: ListGridAPI<T>, info: DrawCellInfo<T>): void;
    }
    export interface DrawCellInfo<T> {
        getRecord(): unknown;
        getIcon(): ColumnIconOption<T> | ColumnIconOption<T>[] | null;
        getMessage(): Message;
        messageHandler: MessageHandler<T>;
        style: ColumnStyleOption | HeaderStyleOption | null | undefined;
        drawCellBase(arg?: {
            bgColor?: ColorPropertyDefine;
        }): void;
        drawCellBg(arg?: {
            bgColor?: ColorPropertyDefine;
        }): void;
        drawCellBorder(): void;
    }
    export type ColumnFadeinState = {
        activeFadeins?: ((point: number) => void)[];
        cells: {
            [key: string]: {
                opacity: number;
            };
        };
    };
    export type ButtonColumnState = {
        mouseActiveCell?: CellAddress;
    };
    export type CheckColumnState = {
        elapsed: {
            [key: string]: number;
        };
        block: {
            [key: string]: boolean;
        };
        mouseActiveCell?: CellAddress;
    };
    export type RadioColumnState = {
        elapsed: {
            [key: string]: number;
        };
        block: {
            [key: string]: boolean;
        };
        mouseActiveCell?: CellAddress;
    };
    interface BranchLine {
        readonly fromIndex?: number;
        toIndex?: number;
        readonly colorIndex: number;
        readonly point?: BranchPoint;
    }
    interface BranchPoint {
        readonly index: number;
        readonly commit: boolean;
        lines: BranchLine[];
        readonly tag?: string;
    }
    export type BranchGraphColumnState<T> = Map<FieldDef<T>, {
        timeline: BranchPoint[][];
        branches: string[];
    }>;
    export type InputEditorState = {
        element?: any;
    };
    export type CheckHeaderState = {
        elapsed: {
            [key: string]: number;
        };
        block: {
            [key: string]: boolean;
        };
        mouseActiveCell?: CellAddress;
    };
    export interface GridInternal<T> extends ListGridAPI<T> {
        "$$$$col.fadein_stateID symbol$$$$"?: ColumnFadeinState;
        "$$$$btncol.stateID symbol$$$$"?: ButtonColumnState;
        "$$$$chkcol.stateID symbol$$$$"?: CheckColumnState;
        "$$$$rdcol.stateID symbol$$$$"?: RadioColumnState;
        "$$$$branch_graph_col.stateID symbol$$$$"?: BranchGraphColumnState<T>;
        "$$$$inline_menu_editor.stateID symbol$$$$"?: InputEditorState;
        "$$$$inline_input_editor.stateID symbol$$$$"?: InputEditorState;
        "$$$$small_dialog_input_editor.stateID symbol$$$$"?: InputEditorState;
        "$$$$check_header.stateID symbol$$$$"?: CheckHeaderState;
    }
    export {};
}

declare module 'cheetah-grid/columns/action/BaseInputEditor' {
    import type { CellAddress, EditorOption, EventListenerId, LayoutObjectId, ListGridAPI } from "cheetah-grid/ts-types";
    import { Editor } from "cheetah-grid/columns/action/Editor";
    export abstract class BaseInputEditor<T> extends Editor<T> {
        constructor(option?: EditorOption);
        abstract clone(): BaseInputEditor<T>;
        abstract onInputCellInternal(grid: ListGridAPI<T>, cell: CellAddress, inputValue: string): void;
        abstract onOpenCellInternal(grid: ListGridAPI<T>, cell: CellAddress): void;
        abstract onChangeSelectCellInternal(grid: ListGridAPI<T>, cell: CellAddress, selected: boolean): void;
        abstract onSetInputAttrsInternal(grid: ListGridAPI<T>, cell: CellAddress, input: HTMLInputElement): void;
        abstract onGridScrollInternal(grid: ListGridAPI<T>): void;
        bindGridEvent(grid: ListGridAPI<T>, cellId: LayoutObjectId): EventListenerId[];
        onPasteCellRangeBox(grid: ListGridAPI<T>, cell: CellAddress, value: string): void;
        onDeleteCellRangeBox(grid: ListGridAPI<T>, cell: CellAddress): void;
    }
}

declare module 'cheetah-grid/columns/style/StdBaseStyle' {
    import { BaseStyle } from "cheetah-grid/columns/style/BaseStyle";
    import type { StdBaseStyleOption } from "cheetah-grid/ts-types";
    export class StdBaseStyle extends BaseStyle {
        static get DEFAULT(): StdBaseStyle;
        constructor(style?: StdBaseStyleOption);
        get textAlign(): CanvasTextAlign;
        set textAlign(textAlign: CanvasTextAlign);
        get textBaseline(): CanvasTextBaseline;
        set textBaseline(textBaseline: CanvasTextBaseline);
        clone(): StdBaseStyle;
    }
}

declare module 'cheetah-grid/columns/style/BranchGraphStyle' {
    import type { BranchGraphStyleOption, ColorDef } from "cheetah-grid/ts-types";
    import { BaseStyle } from "cheetah-grid/columns/style/BaseStyle";
    export class BranchGraphStyle extends BaseStyle {
        static get DEFAULT(): BranchGraphStyle;
        constructor(style?: BranchGraphStyleOption);
        get branchColors(): ColorDef | ((name: string, index: number) => ColorDef);
        set branchColors(branchColors: ColorDef | ((name: string, index: number) => ColorDef));
        get margin(): number;
        set margin(margin: number);
        get circleSize(): number;
        set circleSize(circleSize: number);
        get branchLineWidth(): number;
        set branchLineWidth(branchLineWidth: number);
        get mergeStyle(): "straight" | "bezier";
        set mergeStyle(mergeStyle: "straight" | "bezier");
        clone(): BranchGraphStyle;
    }
}

declare module 'cheetah-grid/header/style/StdBaseStyle' {
    import { BaseStyle } from "cheetah-grid/header/style/BaseStyle";
    import type { StdBaseStyleOption } from "cheetah-grid/ts-types";
    export class StdBaseStyle extends BaseStyle {
        static get DEFAULT(): StdBaseStyle;
        constructor(style?: StdBaseStyleOption);
        get textAlign(): CanvasTextAlign;
        set textAlign(textAlign: CanvasTextAlign);
        get textBaseline(): CanvasTextBaseline;
        set textBaseline(textBaseline: CanvasTextBaseline);
        clone(): StdBaseStyle;
    }
}

declare module 'cheetah-grid/columns/message/internal/MessageElement' {
    import type { ListGridAPI, MessageObject } from "cheetah-grid/ts-types";
    export class MessageElement {
        protected _rootElement: HTMLElement;
        protected _messageElement: HTMLElement;
        constructor();
        dispose(): void;
        attach<T>(grid: ListGridAPI<T>, col: number, row: number, message: MessageObject): void;
        move<T>(grid: ListGridAPI<T>, col: number, row: number): void;
        detach(): void;
        _detach(): void;
        _attachCell<T>(grid: ListGridAPI<T>, col: number, row: number): boolean;
    }
}

declare module 'cheetah-grid/tooltip/BaseTooltip' {
    import type { ListGridAPI } from "cheetah-grid/ts-types";
    import type { TooltipElement } from "cheetah-grid/tooltip/internal/TooltipElement";
    export abstract class BaseTooltip<T> {
        constructor(grid: ListGridAPI<T>);
        dispose(): void;
        abstract createTooltipElementInternal(): TooltipElement<T>;
        attachTooltipElement(col: number, row: number, content: string): void;
        moveTooltipElement(col: number, row: number): void;
        detachTooltipElement(): void;
    }
}

declare module 'cheetah-grid/tooltip/internal/TooltipElement' {
    import type { ListGridAPI } from "cheetah-grid/ts-types";
    export class TooltipElement<T> {
        constructor();
        dispose(): void;
        attach(grid: ListGridAPI<T>, col: number, row: number, content: string): void;
        move(grid: ListGridAPI<T>, col: number, row: number): void;
        detach(): void;
        _detach(): void;
        _attachCell(grid: ListGridAPI<T>, col: number, row: number): boolean;
    }
}

