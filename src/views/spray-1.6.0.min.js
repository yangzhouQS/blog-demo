// https://www.yuque.com/khth0u/dsz7nf/ayilv9

!function (t, e) {
  'object' == typeof exports && 'undefined' != typeof module ? e(exports) : 'function' == typeof define && define.amd ? define(['exports'], e) : e((t = 'undefined' != typeof globalThis ? globalThis : t || self).spray = {})
}(this, (function (t) {
  'use strict';
  const e = new Map;
  var s = {
    registAdapter(t, s) {
      e.set(t, s)
    }, newComponent(t, s, i) {
      let n = null;
      return t && s && i ? e.has(t) ? (e.get(t).factory && (n = e.get(t).factory(s, i)), n) : (console.warn(`名称为${ t }的组件适配器不存在，请检查`), n) : (console.warn('创建组件参数有问题，请检查后再创建'), n)
    }, getAdapterAll: () => e
  };

  /**
   * 系统事件监听队列
   */
  class Eventbus {
    constructor() {
      this._events = {}
    }

    static factory() {
      return this.instance || (this.instance = new Eventbus), this.instance
    }

    on(t, e, s) {
      t in this._events || (this._events[t] = []), this._events[t].push({ handle: e, ctx: s })
    }

    off(t, e, s) {
      const i = this._events[t];
      Array.isArray(i) && (this._events[t] = s ? i.filter(t => t.handle !== e || t.ctx !== s) : i.filter(t => t.handle !== e))
    }

    emit(t, ...e) {
      this._events[t] && this._events[t].forEach(t => {
        t.ctx ? t.handle.call(t.ctx, ...e) : t.handle(...e)
      })
    }

    once(t, e) {
      const s = this, i = function (...n) {
        e(...n), s.off(t, i)
      };
      this.on(t, i)
    }
  }

  class TransitionFilter {
    constructor(t) {
      this.parent = t
    }

    static factory(t) {
      return new TransitionFilter(t)
    }

    runEnterAnimator(t) {
      const e = [];
      this.getAnimatorList(this.parent, 'enter', e);
      const s = e.length;
      let i = 0;
      i === s && t && t(), e.forEach(e => {
        e.spr.sceneTransition.start(e, e.sceneAnimator.enter.name, e.sceneAnimator.enter.duration, () => {
          i += 1, i === s && (e.spr.eventbus.emit('enterAnimationComplete', this.parent), t && t())
        })
      })
    }

    runLeaveAnimator() {
      return new Promise((t, e) => {
        const s = [];
        this.getAnimatorList(this.parent, 'leave', s);
        const i = s.length;
        let n = 0;
        n === i && t(), s.forEach(e => {
          e.spr.sceneTransition.start(e, e.sceneAnimator.leave.name, e.sceneAnimator.leave.duration, () => {
            n += 1, n === i && t()
          })
        })
      })
    }

    getAnimatorList(t, e, s) {
      t && 'Group' !== t.constructor.name && (t.children.forEach(t => {
        this.getAnimatorList(t, e, s)
      }), t.sceneAnimator[e] && !t.ignoreStatus && s.push(t))
    }
  }

  function i(t, e, s = !0) {
    Object.getOwnPropertyNames(e.prototype).forEach(i => {
      'constructor' !== i && s && (t.prototype[i] = e.prototype[i])
    })
  }

  function n(t, e, s) {
    Array.isArray(e) ? e.forEach(e => {
      i(t, e, s)
    }) : i(t, e, s)
  }

  class Loading {
    constructor(t) {
      this.parent = t, this.radius = 40, this.lineWidth = 8, this.strokeStyle = '#fff', this.degreeStart = -90, this.degreeEnd = 180, this.stepStart = 8, this.stepEnd = 2, this.size = {}, this.dom = null, this.ctx = null
    }

    static factory(t) {
      return new Loading(t)
    }

    _createDom() {
      this.dom = document.createElement('canvas'),
        this.dom.width = this.size.width,
        this.dom.height = this.size.height,
        this.ctx = this.dom.getContext('2d'),
        this.dom.style.backgroundColor = 'rgba(0,0,0,0.2)',
        this.dom.style.position = 'absolute'
    }

    _render() {
      this.ctx && (this.degreeStart = this.degreeStart + this.stepStart, this.degreeEnd = this.degreeEnd + this.stepEnd, this.degreeStart - 360 > this.degreeEnd && (this.degreeStart -= 720), this.ctx.clearRect(0, 0, this.size.width, this.size.height), this.ctx.lineWidth = this.lineWidth, this.ctx.beginPath(), this.ctx.strokeStyle = this.strokeStyle, this.ctx.arc(this.size.width / 2, this.size.height / 2, this.radius - this.lineWidth / 2, (this.degreeStart < this.degreeEnd ? this.degreeStart : this.degreeEnd) * Math.PI / 180, (this.degreeStart < this.degreeEnd ? this.degreeEnd : this.degreeStart) * Math.PI / 180, !1), this.ctx.stroke())
    }

    start() {
      this.size = this.parent.getSize(), this._createDom(), this.dom && this.parent.getRoot().appendChild(this.dom), this.renderLoop()
    }

    stop() {
      const t = this.parent.getRoot();
      Array.from(t.children).filter(t => t === this.dom)[0] && this.parent.getRoot().removeChild(this.dom), this.parent = null
    }

    renderLoop() {
      let t = this;
      this._render(), requestAnimationFrame((function () {
        t.renderLoop()
      }))
    }
  }

  var r = 2020;

  function o(t = 'spray') {
    return t + '-' + r++
  }

  class Tick {
    constructor(t, e) {
      this.parent = t, this.animator = e.animator, this.attribute = e.attribute, this.startTime = 0, this.pauseTime = 0, this.stopped = !1, this.ended = !1, this.startValue = this.getValue(this.attribute), this.nowValue = g(this.startValue, 'Array') ? Object.assign([], this.startValue) : this.startValue, this.endValue = this.getEndValue(e.endValue), this.duration = e.duration
    }

    start() {
      this.stopped && (this.startTime = this.startTime + this.getNowDate() - this.pauseTime, this.stopped = !1), !this.startTime && (this.startTime = this.getNowDate());
      this.parent.spr.addTick(() => {
        if (this.stopped) return !1;
        const t = 1 - (Math.max(0, this.startTime + this.duration - this.getNowDate()) / this.duration || 0);
        return this.run(t), t < 1 || (this.ended = !0, this.parent.spr.addTick(this.animator.finally.bind(this.animator)), !1)
      })
    }

    pause() {
      this.stopped = !0, this.pauseTime = this.getNowDate()
    }

    stop() {
      this.stopped = !0
    }

    getNowDate() {
      return Date.now()
    }

    run(t) {
      'translate' === this.attribute || 'scale' === this.attribute || 'skew' === this.attribute ? (this.nowValue[0] = (this.endValue[0] - this.startValue[0]) * t + this.startValue[0], this.nowValue[1] = (this.endValue[1] - this.startValue[1]) * t + this.startValue[1]) : this.nowValue = (this.endValue - this.startValue) * t + this.startValue, this.parent.style[this.attribute] = this.nowValue
    }

    getValue(t) {
      return 'translate' === t ? this.parent.style.translate && this.parent.style.translate.length ? this.parent.style.translate : [0, 0] : 'scale' === t ? this.parent.style.scale && this.parent.style.scale.length ? this.parent.style.scale : [1, 1] : 'skew' === t ? this.parent.style.skew && this.parent.style.skew.length ? this.parent.style.skew : [0, 0] : this.parent.style[this.attribute]
    }

    getEndValue(t) {
      if ('translate' === this.attribute || 'scale' === this.attribute || 'skew' === this.attribute) {
        if (g(t, 'String') && g(+t, 'Number')) return [+t, +t];
        if (g(t, 'Number')) return [t, t];
        if (g(t, 'Array') && g(t[0], 'Number') && g(t[1], 'Number')) return [t[0], t[1]]
      }
      return g(t, 'String') && g(+t, 'Number') ? +t : t
    }
  }

  class Animator {
    constructor(t, e, s, i) {
      this.parent = t, this.id = o('animator'), this._name = '', this.props = y({}, e), this.duration = s || Animator.defaultDuration, this.callback = i, this.tweens = [], this.paused = !1, this.init()
    }

    static factory(t, e, s, i) {
      return new Animator(t, e, s, i)
    }

    init() {
      if ('none' === this.props.transform) {
        const t = {};
        this.parent.translate.length && (t.translate = 0), this.parent.rotate && (t.rotate = 0), this.parent.scale.length && (t.scale = 1), this.parent.skew.length && (t.skew = 0), this.props = t
      }
      for (const t in this.props) if (Object.prototype.hasOwnProperty.call(this.props, t)) {
        const e = { attribute: t, animator: this, endValue: this.props[t], duration: this.duration },
          s = new Tick(this.parent, e);
        this.tweens.push(s)
      }
    }

    start() {
      for (const t of this.tweens) t.start();
      return this.tweens.length && (this.paused = !1), this
    }

    pause() {
      for (const t of this.tweens) t.pause();
      this.tweens.length && (this.paused = !0)
    }

    stop() {
      for (const t of this.tweens) t.stop();
      return this.finally(), !0
    }

    finally() {
      return this.tweens.every(t => t) && (this.tweens = [], this.parent && this.parent.animator && (this.parent.animator = null), this.parent = null, this.callback && this.callback()), !1
    }

    get name() {
      return this._name
    }

    set name(t) {
      this._name = t
    }

    static get defaultDuration() {
      return 500
    }
  }

  var a = ['click', 'dblclick', 'mousewheel', 'mouseout', 'mouseup', 'mousedown', 'mousemove', 'contextmenu', 'mouseover'];
  const h = ['position', 'top', 'left', 'width', 'height', 'transform', 'transformOrigin', 'filter', 'right', 'bottom', 'outline', 'backgroundImage', 'backgroundColor', 'background', 'backgroundPosition', 'flex', 'padding', 'margin', 'display', 'border', 'opacity', 'zIndex', 'pointerEvents', 'cursor', 'flexDirection', 'justifyContent', 'alignItems', 'backgroundRepeat', 'backgroundSize', 'backdropFilter'];

  function l(t) {
    return function (e) {
      this._setTransform(t, e)
    }
  }

  const d = { translate: l('translate'), scale: l('scale'), skew: l('skew'), rotate: l('rotate'), matrix: l('matrix') };
  ['padding', 'margin'].forEach(t => {
    ['Top', 'Right', 'Bottom', 'Left'].forEach((e, s) => d[t + e] = function (t, e) {
      return function (s) {
        this._setDistance(t, e, s)
      }
    }(e, s))
  });

  class Style {
    constructor(t) {
      return this.parent = t, this._style = {}, this.dirtyMap = {}, new Proxy(this, {
        get(t, e, s) {
          if (-1 !== h.indexOf(e) || Reflect.has(d, e)) return t._style[e];
          return Reflect.get(t, e, s)
        },
        set: (t, e, s, i) => -1 !== h.indexOf(e) ? (t._setStyle(e, s), !0) : d[e] ? (d[e].call(t, s), !0) : Reflect.set(t, e, s, i)
      })
    }

    static factory(t) {
      return new Style(t)
    }

    setOption(t) {
      return !!g(t, 'Object') && (Object.keys(t).forEach(e => {
        this[e] = t[e]
      }), !0)
    }

    getValue(t) {
      return 'backgroundImage' === t && this._style[t] ? `url(${ this._style[t] })` : 'transform' === t ? this._getTransformStyleValue() : 'width' !== t && 'height' !== t || Number.isNaN(Number(this._style[t])) ? 'margin' !== t && 'padding' !== t || !g(this._style[t], 'Array') ? g(this._style[t], 'Array') ? this._style[t].join(' ') : 'top' !== t && 'left' !== t && 'right' !== t && 'bottom' !== t || !g(this._style[t], 'Number') ? this._style[t] : this._style[t] + 'px' : this._style[t].join('px ') + 'px' : this._style[t] + 'px'
    }

    _getTransformStyleValue() {
      let t = '';
      return this._style.translate && 2 === this._style.translate.length && (t += `translate(${ this._style.translate[0] }px, ${ this._style.translate[1] }px)`), this._style.scale && 2 === this._style.scale.length && (t.length && (t += ' '), t += `scale(${ this._style.scale[0] }, ${ this._style.scale[1] })`), this._style.rotate && (t.length && (t += ' '), t += `rotate(${ this._style.rotate }deg)`), this._style.skew && 2 === this._style.skew.length && (t.length && (t += ' '), t += `skew(${ this._style.skew[0] }deg, ${ this._style.skew[1] }deg)`), this._style.matrix && 6 === this._style.matrix.length && (t.length && (t += ' '), t += `matrix(${ this._style.matrix.join(',') })`), t
    }

    getDirtyStyleList() {
      const t = [];
      for (const e in this.dirtyMap) {
        const s = this.getValue(e);
        this.dirtyMap[e] = !1, null != s && t.push({ name: e, value: s })
      }
      return t
    }

    toJSON() {
      return { ...this._style }
    }

    _setStyle(t, e) {
      g(e, 'Object') ? this._style[e.name] = e.value : this._style[t] = e, this.dirtyMap[t] = !0, this.parent.dirty = !0
    }

    _setDistance(t, e, s) {
      if ('margin' !== t || 'padding' !== t) return;
      let i = this[t];
      g(i, 'Array') || (i = [0, 0, 0, 0]), i[e] = s, this._setStyle(t, i)
    }

    _setTransform(t, e) {
      const s = ['translate', 'scale', 'skew'].includes(t) ? this.formatValue(e) : e;
      this._setStyle('transform', { name: t, value: s })
    }

    formatValue(t) {
      let e = '';
      return g(t, 'Number') && (e = [t, t]), g(t, 'Array') && g(t[0], 'Number') && g(t[1], 'Number') && (e = [t[0], t[1]]), e
    }

    set dirty(t) {
      this.parent.dirty = t
    }
  }

  /**
   * 元素基类
   */
  class Displayable {
    constructor(t, e) {
      return this.parent = t, this._options = e || {}, this.opts = null, this.dom = null, this.style = Style.factory(this), this._spr = null, this.ignore = !1, this._isSlected = !1, this._isMouseOver = !1, this._handlers = new Map, this._trigger = null, this.children = [], this._dirty = !1, this.loadingComponent = null, this.adapter = null, this.adapterPromise = null, this.animator = null, this._typeName = '', this.sceneAnimator = {
        enter: null,
        leave: null
      }, this.dataInfo = {
        url: null,
        type: null,
        condition: null,
        level: null,
        data: null
      }, this.bizData = null, this.staticData = null, this.initEventHandlers(), this.beforeMount = function () {
      }, this.afterMount = function () {
      }, this.beforeUpdate = function () {
      }, this.afterUpdate = function () {
      }, S(this)
    }

    initDom() {
      this.addSelfToStorage(), this.initOrder(), this.dom = this._createDom(), this.mount()
    }

    initId(t) {
      this.opts.id || (this.id = A(t || this.constructor.name))
    }

    initOrder() {
      const t = this.spr.storage._displayables.indexOf(this);
      this.order = t
    }

    verifyOpts() {
    }

    setOptsBySprayPS(t) {
      if (!g(t, 'Object')) return;
      Object.keys(t).forEach(e => {
        if ('style' !== e && 'lock' !== e && 'id' !== e && (this[e] = t[e]), 'style' === e) {
          Object.keys(t.style).forEach(e => {
            'filter' !== e && (this.style[e] = t.style[e], 'width' !== e && 'height' !== e || (this[e] = t.style[e]))
          })
        }
      })
    }

    _createDom(t = '') {
      const e = t && g(t, 'String') ? document.createElement(t) : document.createElement('div');
      return e.dataset.id = this.id, e
    }

    _buildStyle() {
      return []
    }

    _buildBoundingRect() {
      const t = [], e = { name: 'outline', value: '' };
      return this.isMouseOver && !this.isSelected && (e.value = '#007AFF solid thin'), t.push(e), t
    }

    _buildOrderStyle() {
      return 'FunctionLayer' === this.id ? [{ name: 'zIndex', value: 9999 }] : [{ name: 'zIndex', value: this.order }]
    }

    _updateStyle() {
      if (!this.dom) return;
      [...this._buildStyle(), ...this._buildOrderStyle(), ...this._buildBoundingRect(), ...this.style.getDirtyStyleList()].forEach(t => {
        this.dom.style[t.name] = t.value
      })
    }

    getRoot() {
      return this.dom
    }

    getBoundingRect() {
      return !!this.dom && this.dom.getBoundingClientRect()
    }

    getBoundingRectFromCanvas() {
      if (!this.dom) return !1;
      const t = this.dom.getBoundingClientRect(), e = this._spr.canvas.dom.getBoundingClientRect(),
        s = this._spr.canvas.ratio;
      let i = t.width / s, n = t.height / s, r = t.x / s - e.x / s, o = t.y / s - e.y / s;
      return { bottom: n + o, height: n, left: r, right: r + i, top: o, width: i, x: r, y: o }
    }

    contain(t, e) {
      const s = this.dom.getBoundingClientRect();
      return t > s.left && t < s.right && e > s.top && e < s.bottom && s
    }

    getSpray() {
      return this.parent instanceof Spray ? this.parent : this.parent.getSpray()
    }

    getRootLayer() {
      return 'Canvas' === this.constructor.name ? null : this.parent && 'Canvas' === this.parent.constructor.name ? this : this.parent ? this.parent.getRootLayer() : null
    }

    getIgnoreStatus() {
      return !(this instanceof Spray) && ('Canvas' !== this.constructor.name && ('Layer' === this.constructor.name ? this.ignoreRendering : this.parent.getIgnoreStatus()))
    }

    addSelfToStorage() {
      this._spr = this.getSpray(), this._spr && this._spr.storage.addElToStorage(this)
    }

    mount() {
      this.ignoreStatus || (this.beforeMount.call(), this.root.appendChild(this.dom), this.afterMount.call())
    }

    loadAdapter() {
      if (this.opts.adapter) {
        const t = this.opts.adapter;
        this.createAdapter(t.type, t.name), new Promise((t, e) => {
          t()
        }).then(() => {
          this.initAdapter(t.option), 'Text' === t.name && this.adapter.setData(t.data), this.adapter && (this.adapter.subsDataChain = t.dataChain || [])
        })
      }
    }

    async unmount(t = !1) {
      g(t, 'Boolean') && t && await TransitionFilter.factory(this).runLeaveAnimator(), this.root && this.root.removeChild(this.dom)
    }

    unmountSync() {
      this.root && this.root.removeChild(this.dom)
    }

    update() {
      this.beforeUpdate.call(), this._updateStyle(), this.afterUpdate.call()
    }

    resize() {
    }

    async hidden(t = !0) {
      this.isShow && (t && 'matrix' !== T().canvasMode && await TransitionFilter.factory(this).runLeaveAnimator(), this.style.display = 'none', this.dirty = !0)
    }

    show() {
      this.isShow || ('matrix' !== T().canvasMode && TransitionFilter.factory(this).runEnterAnimator(), this.style.display = '', this.dirty = !0)
    }

    toggle() {
      this.isShow ? this.hidden() : this.show()
    }

    select() {
      this.isSelected = !0
    }

    deselect() {
      this.isSelected = !1
    }

    toJSON() {
      const t = (() => {
        let t = {};
        for (let e in this.opts.lock) this.opts.lock[e] && (t[e] = !0);
        return t
      })(), e = {
        option: {
          name: this.name,
          id: this.id,
          width: this.width,
          height: this.height,
          order: this.order,
          groupId: this.groupId,
          sceneAnimator: { enter: null, leave: null }
        }
      };
      if (Object.keys(t).length > 0 && (e.option.lock = t), e.option.style = this.style.toJSON(), this.adapter) {
        const t = this.adapter.type, s = this.adapter.name, i = this.adapter.opts,
          n = this.adapter.subsDataChain.filter(t => !g(t[1], 'Funtion'));
        let r = null;
        'Text' === s && (r = this.adapter.bizData), e.option.adapter = {
          type: t,
          name: s,
          option: i,
          dataChain: n
        }, r && (e.option.adapter.data = r)
      }
      if (this.sceneAnimator.enter) {
        const t = this.sceneAnimator.enter.name, s = this.sceneAnimator.enter.duration;
        e.option.sceneAnimator.enter = { name: t, duration: s }
      }
      if (this.sceneAnimator.leave) {
        const t = this.sceneAnimator.leave.name, s = this.sceneAnimator.leave.duration;
        e.option.sceneAnimator.leave = { name: t, duration: s }
      }
      return e
    }

    addChildren(t) {
      this.children.push(t)
    }

    removeChildren(t) {
      this.children = this.children.filter(e => e !== t)
    }

    duplicate(t = !0) {
      if ('Canvas' === this.constructor.name) return console.warn('画布不可以进行复制，一个Spray实例中只能存在一个画布'), null;
      let e = null, s = null;
      if (t) {
        if ('FreeContainer' === this.constructor.name && (e = this.toJSON()), 'Layer' === this.constructor.name) {
          let t = this.spr.storage.findStructrueDataByLayer(this);
          t = t.flat(1 / 0);
          const s = t.filter(t => 'Group' === t.constructor.name), i = {};
          if (s.forEach(t => {
            const e = A('group');
            i[t.id] = e
          }), g(t, 'Array')) {
            const s = t.splice(0, 1)[0];
            s && (e = s.toJSON()), s && this._findLayerChildrenWithNewIds(s, e, t, i)
          }
        }
      } else e = this.toJSON();
      return e && (s = this.parent.addChildrenFromJSON(e, !0)), s
    }

    getJSONWithChild() {
      let t = null;
      if ('FreeContainer' === this.constructor.name && (t = this.toJSON()), 'Layer' === this.constructor.name) {
        let e = this.spr.storage.findStructrueDataByLayer(this);
        if (e = e.flat(1 / 0), g(e, 'Array')) {
          const s = e.splice(0, 1)[0];
          s && (t = s.toJSON()), s && this._findLayerChildren(s, t, e)
        }
      }
      return t
    }

    _findLayerChildrenWithNewIds(t, e, s, i) {
      s.forEach(n => {
        if (n.parent === t) {
          let t = n.toJSON();
          if ('Group' === t.type) {
            const e = i[t.option.id];
            e && (t.option.id = e)
          }
          if ('FreeContainer' === t.type) {
            const e = i[t.option.groupId];
            e && (t.option.groupId = e)
          }
          if ('Group' === t.type) {
            const e = i[t.option.groupId];
            e && (t.option.groupId = e)
          }
          e.children || (e.children = []), e.children.push(t), this._findLayerChildrenWithNewIds(n, t, s, i)
        }
      })
    }

    _findLayerChildren(t, e, s) {
      s.forEach(i => {
        if (i.parent === t) {
          let t = i.toJSON();
          e.children || (e.children = []), e.children.push(t), this._findLayerChildren(i, t, s)
        }
      })
    }

    addChildrenFromJSON(t, e = !1) {
      if (!t) return;
      let s = null, i = t;
      if ('string' == typeof t) try {
        i = JSON.parse(t)
      } catch (t) {
        console.warn('场景定义文件被损坏造成无法正常读取')
      }
      return s = g(i, 'Array') ? x(this, i, e) : x(this, [i], e), this.spr.eventbus.emit('addFromTemplate', this.id), s
    }

    addEnterTransition(t, e) {
      this.spr.sceneTransition.enter(this, t, e)
    }

    removeEnterTransition() {
      this.spr.sceneTransition.enter(this)
    }

    addLeaveTransition(t, e) {
      this.spr.sceneTransition.leave(this, t, e)
    }

    removeLeaveTransition() {
      this.spr.sceneTransition.leave(this)
    }

    async destroy(t = !0) {
      this.spr.selector.deselect(this), this.spr.storage.mouseOverElement && (this.spr.storage.mouseOverElement = null), t && 'matrix' !== T().canvasMode && await TransitionFilter.factory(this).runLeaveAnimator(), this.spr.alignmentLineStorage && this.spr.alignmentLineStorage.removeLine && this.spr.alignmentLineStorage.removeLine({ id: this.id }), this.children.sort((t, e) => e.order - t.order);
      for (let t of this.children) await t.destroy();
      this.children = [], this.destroyAdapter(), !this.ignoreStatus && await this.unmount(), this._spr && this._spr.storage.deleteElFromStorage(this), this.parent !== this.spr && this.parent.removeChildren(this), 'Canvas' === this.constructor.name && (this.parent.canvas = null), this._spr.eventbus.off('canvasResizeOnPlayMode', this.resize, this), this.groupId = null, this.id = null, this.parent = null, this.style = null, this._spr = null
    }

    setSize(t, e) {
      this.width = t, this.height = e
    }

    getSize() {
      return { width: this._getWidth(), height: this._getHeight() }
    }

    _getWidth() {
      return 'inherit' === this.width || null === this.width ? this.parent._getWidth() : this.width
    }

    _getHeight() {
      return 'inherit' === this.height || null === this.height ? this.parent._getHeight() : this.height
    }

    setBackgroundImage(t) {
      this.style.backgroundImage = t
    }

    getSelectedChildren(t = []) {
      this.children.forEach(e => {
        e.isSelected ? t.push(e) : e.getSelectedChildren(t)
      })
    }

    get root() {
      return this.parent.getRoot()
    }

    get groupId() {
      return this.opts.groupId
    }

    set groupId(t) {
      this.opts.groupId = t
    }

    set width(t) {
      this.style.width = t, this.opts.width = t, this.adapter && this.adapter.resize()
    }

    get width() {
      return this.style.width
    }

    set height(t) {
      this.style.height = t, this.opts.height = t, this.adapter && this.adapter.resize()
    }

    get height() {
      return this.style.height
    }

    set order(t) {
      g(t, 'Number') ? t !== this.order && (this.opts.order = t, this.dirty = !0) : console.warn('元素显示顺序必须是一个数字')
    }

    get order() {
      return this.opts.order
    }

    set name(t) {
      g(t, 'String') ? t && this.opts.name !== t && (this.opts.name = t, this._pubPropChange('name', t)) : console.warn('元素名称必须是一个字符串')
    }

    get name() {
      return this.opts.name
    }

    get originalId() {
      return this.opts.originalId
    }

    set typeName(t) {
      g(t, 'String') ? t && (this._typeName = t) : console.warn('元素类型名称必须是一个字符串')
    }

    get typeName() {
      return this._typeName
    }

    set isSelected(t) {
      g(t, 'Boolean') && this._isSlected !== t && (this._isSlected = t, this.dirty = !0)
    }

    get isSelected() {
      return this._isSlected
    }

    set isMouseOver(t) {
      g(t, 'Boolean') && this._isMouseOver !== t && (this._isMouseOver = t, this._spr && this._spr.storage && (this._spr.storage.mouseOverElement = t ? this : null), this._updateStyle())
    }

    get isMouseOver() {
      return this._isMouseOver
    }

    set dirty(t) {
      if (!0 === t) return this._dirty = t, this.adapter && (this.adapter.dirty = t), void (this._spr && this._spr.refresh());
      this._dirty = !1
    }

    get dirty() {
      return this._dirty
    }

    get spr() {
      return this._spr
    }

    get app() {
      let t = null;
      return this.adapter && this.adapter.componentInstance && (t = this.adapter.componentInstance), t
    }

    get ignoreStatus() {
      return this.getIgnoreStatus()
    }

    get id() {
      return this.opts.id
    }

    set id(t) {
      this.opts.id = t
    }

    get isShow() {
      let t = !1;
      return t = 'none' !== this.style.display, t
    }

    getLockStatusByPropName(t) {
      return !0 === this.opts.lock[t]
    }

    setLockStatusByPropName(t, e) {
      g(e, 'Boolean') ? this.opts.lock[t] !== e && (this.opts.lock[t] = e) : console.warn('锁定项必须赋布尔类型值')
    }

    setLockStatusByObject(t) {
      if (!g(t, 'Object')) return void console.warn('参数必须是Object类型');
      Object.values(t).every(t => g(t, 'Boolean')) ? this.opts.lock = { ...this.opts.lock, ...t } : console.warn('锁定项必须赋布尔类型值')
    }

    saveInfoPreMouseAction() {
      this.oldOptsRecord = {
        top: this.opts.top,
        left: this.opts.left,
        width: this.opts.width,
        height: this.opts.height
      }
    }

    _pubPropChange(t, e) {
      this.spr.eventbus.emit('elementPropChange', { key: t, value: e })
    }
  }

  n(Displayable, [class {
    constructor() {
    }

    initEventHandlers() {
      a.forEach(t => {
        this._handlers.set(t, { list: [], isBind: !1 })
      }), this._trigger = this.trigger.bind(this)
    }

    on(t, e, s) {
      if (arguments.length < 2) throw new Error('参数数量不够');
      if (!this.dom || !this._handlers.get(t) || !g(e, 'Function')) return;
      const i = this._handlers.get(t);
      i.list.some(t => t.handler === e) || (i.list.push({
        ctx: s,
        handler: e
      }), i.isBind || (i.isBind = !0, this.dom.addEventListener(t, this._trigger)))
    }

    trigger(t) {
      this._handlers.get(t.type).list.forEach(e => {
        e.handler.call(e.ctx, t)
      })
    }

    triggerByName(t) {
      this._handlers.get(t).list.forEach(t => {
        t.handler.call(t.ctx)
      })
    }

    once(t, e, s) {
      if (this.dom) {
        const i = function () {
          e(), this.off(t, i)
        };
        this.on(t, i.bind(this), s)
      }
    }

    off(t, e = null) {
      let s = this._handlers.get(t);
      s.length <= 1 || !e ? (this.dom.removeEventListener(t, this._trigger), s.list = [], s.isBind = !1) : s.list = s.list.filter(t => t.handler !== e)
    }

    initDevEvent() {
      console.log(this), this.on('mouseover', (function () {
        console.log('触发了鼠标移出事件')
      }))
    }
  }, class {
    constructor() {
    }

    initAnimator() {
      'play' !== T().canvasMode ? 'FreeContainer' === this.constructor.name ? (this.style.translate = [this.opts.left, this.opts.top], this.loadAdapter()) : this.loadAdapter() : this._initAnimator()
    }

    _initAnimator() {
      const t = this.sceneAnimator;
      if (!t.enter || !t.enter.name) return 'FreeContainer' === this.constructor.name && D(this, {
        width: this.spr.canvas.rawWidth,
        height: this.spr.canvas.rawHeight
      }), void this.loadAdapter();
      this.spr.sceneTransition.start(this, t.enter.name, t.enter.duration, () => {
        this.spr.eventbus.emit('enterAnimationComplete', this), this.loadAdapter()
      })
    }

    _getOptsValue(t, e = '') {
      let s, i = t, n = e;
      return 1 === arguments.length && (n = t, i = this), s = i.style[n], s && 'inherit' !== s ? s : this._getOptsValue(i.parent, n)
    }

    _getParentsMargin(t = null) {
      let e = t, s = [0, 0, 0, 0];
      e || (e = this);
      const i = e.style && e.style.margin ? e.style.margin : [0, 0, 0, 0];
      if (g(i, 'Array') && (s[0] += i[0], s[1] += i[1], s[2] += i[2], s[3] += i[3]), e.parent) {
        const t = this._getParentsMargin(e.parent);
        g(t, 'Array') && (s[0] += t[0], s[1] += t[1], s[2] += t[2], s[3] += t[3])
      }
      return s
    }

    animate(t, e = 0, s = null) {
      return g(t, 'String') ? Animator[t] ? (g(e, 'String') && g(+e, 'Number') && (e = +e), g(e, 'Number') || (e = Animator.defaultDuration), this.animator = Animator[t].call(this, e), this.animator) : void 0 : g(t, 'Object') && g(e, 'Number') ? (this.animator && this.animator.stop(), this.animator = Animator.factory(this, t, e, s), this.animator) : void console.error('animator参数错误')
    }
  }, class {
    constructor() {
    }

    createAdapter(t, e) {
      return this.adapter = s.newComponent(t, this, e), this.adapter && this.startLoading(), this.adapter.type = t, this.adapter
    }

    initAdapter(t) {
      this.adapter ? (this.adapter.init(t), this.spr && this.spr.storage.addAdapterToStorage(this.adapter)) : console.warn(`容器${ this.name }中无组件适配器，请检查createAdapter阶段type和name参数是否正确`)
    }

    createText(t, e = '这是单行文本') {
      return 'FreeContainer' !== this.constructor.name ? (console.warn('系统内置的文本组件只能创建在容器中'), null) : g(t, 'Object') ? (this.createAdapter('SysAdapter', 'Text'), this.initAdapter(t), this.adapter && this.adapter.setData(e), this.adapter) : (console.error('createText第一个参数必须是样式属性，如果不设置请传{}'), null)
    }

    setDataToAdapter(t) {
      this.staticData = t, this.adapter && this.adapter.setData(t)
    }

    subsDataToAdapter(t, e) {
      this.adapter && this.adapter.subsData(t, e)
    }

    unSubsDataToAdapter(t) {
      this.adapter && this.adapter.unSubsData(t)
    }

    setOptionToAdapter(t) {
      this.adapter && this.adapter.setOption(t)
    }

    resizeAdapter(t) {
      this.adapter && this.adapter.resize(t)
    }

    destroyAdapter() {
      this.adapter && this.adapter.destroy(), this.spr.storage.deleteAdapterFromStorage(this.adapter), this.adapter = null
    }

    transferAdapterTo(t) {
      if (!this.adapter) return console.log(`容器${ this.name }中无组件适配器，所以没有要迁移的内容`), null;
      this.adapter.transferTo(t)
    }

    transferAdapterToImmediately(t) {
      if (!this.adapter) return console.log(`容器${ this.name }中无组件适配器，所以没有要迁移的内容`), null;
      this.adapter.transferToImmediately(t)
    }

    exchangeAdapterTo(t) {
      if (!this.adapter) return null;
      this.adapter.exchangeTo(t)
    }

    startLoading() {
      this.loadingComponent = Loading.factory(this), this.loadingComponent.start()
    }

    stopLoading() {
      this.loadingComponent && this.loadingComponent.stop(), this.loadingComponent = null
    }
  }, class {
    constructor() {
    }

    getData() {
      return this.bizData
    }

    setData(t) {
      let e = this.bizData = t, s = { id: this.id, bizData: e };
      this.spr && this.spr.eventbus.emit('dataChange', s)
    }

    openDataWindow() {
      this.spr.whale && this.spr.whale.showModal(this.id)
    }
  }]);
  const c = new Map;

  function p(t, e, s) {
    if (!c.has(t)) return console.warn(`注册名词为${ t }的对象不存在，请检查对象注册时所使用的名称`), !1;
    let i = c.get(t).factory(e, s);
    return 'Canvas' !== t && (i instanceof Displayable || 'Group' === i.constructor.name) && (e.children.some(t => t === i) || e.addChildren(i)), i
  }

  function u(t, e) {
    c.has(t) ? console.warn('对象已经存在，请使用新的名词注册') : c.set(t, e)
  }

  var m = Object.freeze({
    __proto__: null, newFromRegistedClazz: p, registClazz: u, getRegisteClazzList: function () {
      return c
    }
  });

  function f(t) {
    if (g(t, 'HTMLDivElement')) return t;
    if (g(t, 'String')) {
      let e = document.getElementById(t);
      if (e && g(e, 'HTMLDivElement')) return e
    }
    return console.warn('传入的DOM节点参数不符合规范'), !1
  }

  function g(t, e) {
    return Object.prototype.toString.call(t).includes(e)
  }

  function y(t, e) {
    let s = e || {};
    return g(t, 'Object') ? { ...t, ...s } : s
  }

  function v(t, ...e) {
    if (!g(t, 'Object')) return console.error('参数错误: ' + t);
    if (!e.length) return t;
    return e.every(t => g(t, 'Object')) ? (e.forEach(e => {
      !function t(e, s) {
        Object.keys(s).forEach(i => {
          g(s[i], 'Object') ? (e[i] || (e[i] = {}), t(e[i], s[i])) : e[i] = s[i]
        })
      }(t, e)
    }), t) : console.error('source参数错误: ' + e)
  }

  function A(t = 'spray') {
    return `${ t.toLowerCase() }-${ Math.random().toString(36).slice(-8) }`
  }

  function b(t = '') {
    return document.createElement(t || 'div')
  }

  let E = {
    TOPLEFT: 1,
    TOPCENTER: 2,
    TOPRIGHT: 3,
    CENTERLEFT: 4,
    CENTERCENTER: 5,
    CENTERRIGHT: 6,
    BOTTOMLEFT: 7,
    BOTTOMCENTER: 8,
    BOTTOMRIGHT: 9
  }, w = { HORIZ: 0, VERTI: 1, ALL: 2, NONE: 3 }, C = {
    CREATEGROUP: 'CREATEGROUP',
    SETOPT: 'SETOPT',
    MOVEDISPLAYABLE: 'MOVEDISPLAYABLE',
    REMOVE: 'REMOVE',
    CREATE: 'CREATE',
    DUPLICATE: 'DUPLICATE'
  };

  function S(t, e) {
    return new Proxy(t, {
      _filters: e || [], get: (t, e, s) => Reflect.get(t, e, s), set(t, e, s, i) {
        return 'Style' === i.constructor.name && (this._filters.includes(e) || i.parent.id && _(i.parent.id)), 'FreeContainer' === i.constructor.name && 'width,height,top,left'.includes(e) && _(i.id), Reflect.set(t, e, s, i)
      }
    })
  }

  function _(t, e, s) {
    new Promise((t, e) => {
      t()
    }).then(() => {
    })
  }

  function L(t, e, s = !1) {
    let i = null;
    return e && e.forEach((e, n) => {
      s && 'Group' !== e.type && (e.option.id = A(e.type));
      const r = p(e.type, t, e.option);
      0 === n && (i = e.option.id), e.children && L(r, e.children, s)
    }), i
  }

  function x(t, e, s = !1) {
    let i = null;
    return e && g(e, 'Array') && e.forEach((e, n) => {
      s && 'Group' !== e.type && (e.option.originalId = e.option.id, e.option.id = A(e.type));
      const r = p(e.type, t, e.option);
      r && r.spr && 'FreeContainer' === r.constructor.name && r.spr.eventbus.emit('rebuildContainer', r.id), 0 === n && (i = e.option.id), e.children && x(r, e.children, s)
    }), i
  }

  function M(t) {
    if (!g(t, 'Object')) return console.error('样式参数有误请检查后尝试'), '';
    let e = '';
    return Object.keys(t).forEach(s => {
      let i = s.replace(/[A-Z]/, (function (t) {
        return '-' + t.toLowerCase()
      }));
      e += i + ':' + t[s] + ';'
    }), e
  }

  var I = Object.freeze({
    __proto__: null,
    getDomObject: f,
    isType: g,
    getDeviceRatio: function () {
      return window.devicePixelRatio
    },
    mixinOpts: y,
    deepMixinOpts: v,
    excutionJavascript: function (t, e, s, i = !1) {
      const n = document.body;
      let r = s ? n.querySelector(s) : null;
      r && n.removeChild(r), r && (r = null), r = document.createElement('script'), r.type = 'text/javascript', e && 'function' == typeof e && (r.onload = e), s && (r.id = s), n.appendChild(r), i ? r.appendChild(document.createTextNode(t)) : r.src = t
    },
    createElementName: A,
    normalizeCssArray: function (t) {
      let e = [0, 0, 0, 0];
      'number' == typeof t && (e = [t, t, t, t]);
      const s = t.length;
      return 2 === s && t.every(t => 'number' == typeof t) && (e = [t[0], t[1], t[0], t[1]]), 3 === s && t.every(t => 'number' == typeof t) && (e = [t[0], t[1], t[2], t[1]]), 4 === s && t.every(t => 'number' == typeof t) && (e = [t[0], t[1], t[2], t[3]]), e
    },
    createDom: b,
    containerConstraints: E,
    scaleConstraints: w,
    commandType: C,
    createProxyObject: S,
    buildChildElements: L,
    buildChildElementsWithMessage: x,
    getStyleStringFromStyleObject: M
  });
  let O = {
    extendManage: !0,
    zoomBar: !0,
    boundingRect: !0,
    canvasMode: 'matrix',
    appMode: !1,
    enableEsc: !0,
    enableAlignmentLine: !0,
    enableMouseWheel: !0
  }, B = Eventbus.factory();

  function T() {
    return O
  }

  function R(t, e) {
    return !(!g(e, 'Boolean') && !g(e, 'String')) && (O[t] = e, B.emit('configChange', { key: t, value: e }), !0)
  }

  var z = Object.freeze({ __proto__: null, getConfig: T, setConfig: R });

  function D(t, e) {
    if ('matrix' === T().canvasMode) return t.style.translate = [t.opts.left, t.opts.top], t.style.scale = 1, void (t.style.transformOrigin = ['top', 'left']);
    if (t.style.transformOrigin = ['top', 'left'], t.constraints) {
      const s = F(t, e);
      !function (t, e, s, i) {
        t.style.translate = [s, e], t.style.scale = i
      }(t, s.top, s.left, s.ratio)
    }
  }

  function F(t, e) {
    const s = t.constraints, i = { width: t.spr.width, height: t.spr.height }, n = function (t, e, s) {
      let i = [1, 1], n = e.width / s.width, r = e.height / s.height;
      return 0 === t && (i = [n, n]), 1 === t && (i = [r, r]), 2 === t && (i = [e.width / s.width, e.height / s.height]), i
    }(t.scaleConstraints || t.spr.canvas.scaleConstraints, i, e), [r, o] = (a = t.spr.width, h = t.spr.height, l = e.width, d = e.height, [k(l, d), k(a, h)]);
    var a, h, l, d;
    const c = (r[s - 1][1] - t.opts.top) * n[0], p = (r[s - 1][0] - t.opts.left) * n[1], u = o[s - 1][1] - c;
    return { left: o[s - 1][0] - p, top: u, ratio: n }
  }

  function k(t, e) {
    return [[0, 0], [t / 2, 0], [t, 0], [0, e / 2], [t / 2, e / 2], [t, e / 2], [0, e], [t / 2, e], [t, e]]
  }

  class SceneTransition {
    constructor(t) {
      this._spr = t, this.animateList = new Map, this.animateList.set('fromTop', {
        main: this.fromTop.bind(this),
        reverse: 'toTop'
      }), this.animateList.set('fromRight', {
        main: this.fromRight.bind(this),
        reverse: 'toRight'
      }), this.animateList.set('fromBottom', {
        main: this.fromBottom.bind(this),
        reverse: 'toBottom'
      }), this.animateList.set('fromLeft', {
        main: this.fromLeft.bind(this),
        reverse: 'toLeft'
      }), this.animateList.set('toTop', {
        main: this.toTop.bind(this),
        reverse: 'fromTop'
      }), this.animateList.set('toRight', {
        main: this.toRight.bind(this),
        reverse: 'fromRight'
      }), this.animateList.set('toBottom', {
        main: this.toBottom.bind(this),
        reverse: 'fromBottom'
      }), this.animateList.set('toLeft', { main: this.toLeft.bind(this), reverse: 'fromLeft' })
    }

    static factory(t) {
      return new SceneTransition(t)
    }

    enter(t, e = '', s = 500) {
      if (!e) return t.sceneAnimator.enter = null, !0;
      t.sceneAnimator.enter || (t.sceneAnimator.enter = {});
      const i = this.animateList.get(e);
      if (!i) return console.error('没有对应转场动画');
      t.sceneAnimator.enter.name = e, t.sceneAnimator.enter.duration = s, t.sceneAnimator.leave || (t.sceneAnimator.leave = {}, t.sceneAnimator.leave.name = i.reverse, t.sceneAnimator.leave.duration = s), t.initAnimator()
    }

    leave(t, e = '', s = 500) {
      if (!e) return t.sceneAnimator.leave = null, !0;
      t.sceneAnimator.leave || (t.sceneAnimator.leave = {});
      const i = this.animateList.get(e);
      if (!i) return console.error('没有对应转场动画');
      t.sceneAnimator.leave.name = e, t.sceneAnimator.leave.duration = s, t.sceneAnimator.enter || (t.sceneAnimator.enter = {}, t.sceneAnimator.enter.name = i.reverse, t.sceneAnimator.enter.duration = s)
    }

    start(t, e, s, i) {
      if (!this.animateList.has(e)) return i && i(), void console.warn('没有对应的组合动画');
      this.animateList.get(e).main(t, s, i)
    }

    _start(t, e, s, i = 500) {
      return t.animator = t.animate(s, i).start(), t.animator.name = e, t.animator
    }

    fromTop(t, e, s) {
      const i = t._getOptsValue('height');
      return 'FreeContainer' !== t.constructor.name ? (t.style.translate = [0, -i], t.animator = t.animate({ translate: [0, 0] }, e, s).start()) : this._createFCAnimator(t, e, s, 'height', 'fromTop'), t.animator
    }

    fromRight(t, e, s) {
      const i = t._getOptsValue('width');
      return 'FreeContainer' !== t.constructor.name ? (t.style.translate = [i, 0], t.animator = t.animate({ translate: [0, 0] }, e, s).start()) : this._createFCAnimator(t, e, s, 'width', 'fromRight'), t.animator
    }

    fromBottom(t, e, s) {
      const i = t._getOptsValue('height');
      return 'FreeContainer' !== t.constructor.name ? (t.style.translate = [0, i], t.animator = t.animate({ translate: [0, 0] }, e, s).start()) : this._createFCAnimator(t, e, s, 'height', 'fromBottom'), t.animator
    }

    fromLeft(t, e, s) {
      const i = t._getOptsValue('width');
      return 'FreeContainer' !== t.constructor.name ? (t.style.translate = [-i, 0], t.animator = t.animate({ translate: [0, 0] }, e, s).start()) : this._createFCAnimator(t, e, s, 'width', 'fromLeft'), t.animator
    }

    toTop(t, e, s) {
      if ('FreeContainer' !== t.constructor.name) {
        const i = t._getOptsValue('height');
        t.animator = t.animate({ translate: [0, -i] }, e, s).start()
      } else this._createFCAnimator(t, e, s, 'height', 'toTop');
      return t.animator
    }

    toRight(t, e, s) {
      if ('FreeContainer' !== t.constructor.name) {
        const i = t._getOptsValue('width');
        t.animator = t.animate({ translate: [i, 0] }, e, s).start()
      } else this._createFCAnimator(t, e, s, 'width', 'toRight');
      return t.animator
    }

    toBottom(t, e, s) {
      if ('FreeContainer' !== t.constructor.name) {
        const i = t._getOptsValue('height');
        t.animator = t.animate({ translate: [0, i] }, e, s).start()
      } else this._createFCAnimator(t, e, s, 'height', 'toBottom');
      return t.animator
    }

    toLeft(t, e, s) {
      if ('FreeContainer' !== t.constructor.name) {
        const i = t._getOptsValue('width');
        t.animator = t.animate({ translate: [-i, 0] }, e, s).start()
      } else this._createFCAnimator(t, e, s, 'width', 'toLeft');
      return t.animator
    }

    _createFCAnimator(t, e, s, i, n) {
      const r = t._getOptsValue(i),
        o = (a = t, h = { width: t.spr.canvas.rawWidth, height: t.spr.canvas.rawHeight }, F(a, h));
      var a, h;
      if (t.style.transformOrigin = ['top', 'left'], 0 === n.indexOf('from') && (t.style.translate = this._createTranslate(t, r, o, n), t.style.scale = o.ratio, t.animator = t.animate({ translate: [o.left, o.top] }, e, s).start()), 0 === n.indexOf('to')) {
        const i = this._createTranslate(t, r, o, n);
        t.animator = t.animate({ translate: i }, e, s).start()
      }
    }

    _createTranslate(t, e, s, i) {
      const n = [0, 0];
      return 'fromLeft' !== i && 'toLeft' !== i || (n[0] = -e * s.ratio, n[1] = s.top), 'fromRight' !== i && 'toRight' !== i || (n[0] = e * s.ratio + t.spr.canvas.width, n[1] = s.top), 'fromTop' !== i && 'toTop' !== i || (n[0] = s.left, n[1] = -e * s.ratio), 'fromBottom' !== i && 'toBottom' !== i || (n[0] = s.left, n[1] = e * s.ratio + t.spr.canvas.height), n
    }
  }

  var N = 'undefined' == typeof Float32Array ? Array : Float32Array;

  function G() {
    var t = new N(6);
    return P(t), t
  }

  function P(t) {
    return t[0] = 1, t[1] = 0, t[2] = 0, t[3] = 1, t[4] = 0, t[5] = 0, t
  }

  function H(t, e, s) {
    var i = e[0] * s[0] + e[2] * s[1], n = e[1] * s[0] + e[3] * s[1], r = e[0] * s[2] + e[2] * s[3],
      o = e[1] * s[2] + e[3] * s[3], a = e[0] * s[4] + e[2] * s[5] + e[4], h = e[1] * s[4] + e[3] * s[5] + e[5];
    return t[0] = i, t[1] = n, t[2] = r, t[3] = o, t[4] = a, t[5] = h, t
  }

  /*
  * 全局实例
  * */
  class Canvas extends Displayable {
    constructor(t, e) {
      super(t, e), this.defaultFilter = { hueRotate: 0, contrast: 1, opacity: 1, saturate: 1, brightness: 1 };
      let s = {
        id: null,
        name: null,
        width: 1920,
        height: 1080,
        order: 0,
        scaleConstraints: w.HORIZ,
        lock: { left: !1, top: !1, width: !1, height: !1 },
        filter: { ...this.defaultFilter },
        style: {
          backgroundColor: 'black',
          backgroundRepeat: 'no-repeat',
          backgroundSize: 'cover',
          backgroundPosition: 'center',
          transformOrigin: [0, 0],
          matrix: [1, 0, 0, 1, 0, 0]
        }
      };
      this.opts = v(s, this._options),
        this.typeName = '画布',
        this.style.setOption(this.opts.style),
        this.style.filter = this._buildFilterStyle(),
      this.opts.sceneAnimator && (this.sceneAnimator.enter = this.opts.sceneAnimator.enter, this.sceneAnimator.leave = this.opts.sceneAnimator.leave),
        this.style.pointerEvents = 'all',
        this.initId('canvas'),
        this._ratio = 1,
        this._origin = null,
        this.width = this.opts.width,
        this.height = this.opts.height,
        this.rawWidth = this.opts.width,
        this.rawHeight = this.opts.height,
        this.initDom(),
        this._initMatrix(),
        this.initAnimator(),
        this.ignoreBoundingActiveReg = /^(Canvas|Layer|Flex|Free)$/,
        this.ignoreBoundingFocusReg = /^(Canvas|Layer|Flex|Free)$/,
        this.bindEventList = {},
        this.mouseMoveResizeHander = null,
        this.mouseMoveInfo = {
          x: 0,
          y: 0,
          oldX: 0,
          oldY: 0,
          oldWidth: 0,
          oldHeight: 0
        },
        this.canvasMoveFlag = !1,
        this.resizeHandlerMoveFlag = !1,
        this.sysEventList = a,
        this._initBindEventList(),
        this._onCanvasEvent(),
        this.spr.eventbus.on('configChange', this._onConfigChange, this),
        this.keyDownTimer = null
    }

    static factory(t, e) {
      return new Canvas(t, e)
    }

    _initRatio() {
      const t = this.spr.width, e = this.spr.height;
      let s = (t - 400) / this.width;
      return this.width / this.height < t / e && (s = (e - 300) / this.height), s > 1 && (s = 1), s
    }

    _initOrigin() {
      return [this.spr.width / 2, this.spr.height / 2]
    }

    _initMatrix() {
      let t = G();
      P(t), t[4] = (this.spr.width - this.width) / 2, t[5] = (this.spr.height - this.height) / 2, this.matrix = t;
      const e = this._origin = this._initOrigin(), s = this._ratio = this._initRatio();
      this.zoomCanvas(e, s)
    }

    _buildFilterStyle() {
      return `hue-rotate(${ this.opts.filter.hueRotate }deg) contrast(${ 100 * this.opts.filter.contrast }%) \n    opacity(${ 100 * this.opts.filter.opacity }%)  saturate(${ 100 * this.opts.filter.saturate }%)  brightness(${ 100 * this.opts.filter.brightness }%)`
    }

    /**
     * 将画布放缩到当前视窗中心点位置，并放缩到一个合适的比例
     * @param t
     * @param e
     */
    zoomCanvas(t, e) {
      let s = [e, e], i = [...this.matrix];
      if (i || (i = G(), P(i)), i[0] <= .04 && s[0] < 1) return;
      if (i[0] >= 4 && s[0] > 1) return;
      let n = t;
      n ? this._origin = [...n] : n = [...this._origin];
      let r = G();
      var o, a, h, l, d;
      r[4] -= n[0], r[5] -= n[1], o = r, a = r, l = (h = [s[0], s[1]])[0], d = h[1], o[0] = a[0] * l, o[1] = a[1] * d, o[2] = a[2] * l, o[3] = a[3] * d, o[4] = a[4] * l, o[5] = a[5] * d, r[4] += n[0], r[5] += n[1], H(i, r, i), this.matrix = i, this._ratio = i[0], this.parent.extendManage && this.parent.extendManage.zoomBar && (this.parent.extendManage.zoomBar.ratioText = this._ratio), this.spr.eventbus.emit('zoomCanvas', this)
    }

    zoomCanvasToCenter() {
      this._initMatrix()
    }

    createLayer(t) {
      let e;
      return e = p('Layer', this, t), e
    }

    toJSON() {
      const t = super.toJSON();
      t.type = 'Canvas';
      const e = this._getFilterDef();
      return Object.keys(e).length > 0 && (t.option.filter = e), t
    }

    _getFilterDef() {
      const t = { ...this.defaultFilter }, e = {};
      return Object.keys(this.opts.filter).forEach(s => {
        this.opts.filter[s] !== t[s] && (e[s] = this.opts.filter[s])
      }), e
    }

    setFilter(t, e) {
      void 0 !== this.defaultFilter[t] && this.opts.filter[t] !== e && g(e, 'Number') && (this.opts.filter = {
        ...this.defaultFilter, ...this.opts.filter,
        [t]: e
      }, this.style.filter = this._buildFilterStyle())
    }

    resetFilter() {
      this.opts.filter = { ...this.defaultFilter }, this.style.filter = this._buildFilterStyle()
    }

    deleteFilter() {
      this.opts.filter = {}, this.style.filter = 'none'
    }

    async destroy() {
      this._offCanvasEvent(), this.spr.eventbus.off('configChange', this._onConfigChange, this), await super.destroy()
    }

    get ratio() {
      return this._ratio
    }

    set ratio(t) {
      g(t, 'Number') && this.zoomCanvas(null, t / this._ratio)
    }

    get matrix() {
      return this.style.matrix
    }

    set matrix(t) {
      this.style.matrix = t
    }

    get scaleConstraints() {
      return this.opts.scaleConstraints
    }

    set scaleConstraints(t) {
      this.opts.scaleConstraints = t
    }
  }

  n(Canvas, [class {
    constructor() {
    }

    _initBindEventList() {
      this.bindEventList.documentKeyDown = this._keyDown.bind(this), this.bindEventList.documentKeyUp = this._keyUp.bind(this), this.bindEventList.windowResize = this._windowResize.bind(this), this.bindEventList.rootClick = this._rootClick.bind(this), this.bindEventList.mouseMoveDisplayable = this._moveDisplayable.bind(this), this.bindEventList.stopMove = this._stopMove.bind(this), this.bindEventList.mouseMoveDisplayableOnPlay = this._mouseMoveDisplayableOnPlay.bind(this), this.bindEventList.stopMoveOnPlay = this._stopMoveOnPlay.bind(this), this.bindEventList.thingjsKeyDown = this._thingjsKeyDown.bind(this), this.bindEventList.mouseDown = this._mouseDown.bind(this), this.bindEventList.mouseMove = this._mouseMove.bind(this), this.parent.eventbus.on('configChange', t => {
        'enableMouseWheel' === t.key && (this.off('mousewheel', this._zoomCanvas, this), t.value && this.on('mousewheel', this._zoomCanvas, this))
      })
    }

    _onSysEventProxy() {
      this.sysEventList.forEach(t => {
        this.on(t, this.eventProxy, this)
      })
    }

    _offSysEventProxy() {
      this.sysEventList.forEach(t => {
        this.off(t, this.eventProxy, this)
      })
    }

    eventProxy(t) {
      const e = this._getContainDisplayable(t.clientX, t.clientY).reverse()[0];
      e && e instanceof Displayable && e.trigger(t)
    }

    _onCanvasEvent() {
      this._onCanvasBaseEvent(), document.addEventListener('keydown', this.bindEventList.documentKeyDown), document.addEventListener('keyup', this.bindEventList.documentKeyUp), window.addEventListener('resize', this.bindEventList.windowResize), this.spr.root.addEventListener('click', this.bindEventList.rootClick)
    }

    _onCanvasBaseEvent() {
      this.spr.root.addEventListener('mousedown', this.bindEventList.mouseDown), this.spr.root.addEventListener('mousemove', this.bindEventList.mouseMove), T().enableMouseWheel && this.on('mousewheel', this._zoomCanvas, this), this.on('dblclick', this._dblClick, this)
    }

    _offCanvasEvent() {
      this._offCanvasBaseEvent(), document.removeEventListener('keydown', this.bindEventList.documentKeyDown), document.removeEventListener('keyup', this.bindEventList.documentKeyUp), window.removeEventListener('resize', this.bindEventList.windowResize), this.spr.root.removeEventListener('click', this.bindEventList.rootClick)
    }

    _offCanvasBaseEvent() {
      this.spr.root.removeEventListener('mousedown', this.bindEventList.mouseDown), this.spr.root.removeEventListener('mousemove', this.bindEventList.mouseMove), T().enableMouseWheel && this.off('mousewheel', this._zoomCanvas, this), this.off('dblclick', this._dblClick, this)
    }

    _dblClick(t) {
      this.selectElByMouseSite(t.clientX, t.clientY, !0)
    }

    _mouseMove(t) {
      const e = this._getContainDisplayable(t.clientX, t.clientY).reverse().filter(t => !this.ignoreBoundingFocusReg.test(t.constructor.name))[0];
      e ? e.isMouseOver = !0 : this.spr.storage.mouseOverElement = null
    }

    _mouseDown(t) {
      const e = this.spr.functionLayer.contain(t.clientX, t.clientY);
      e && !this.canvasMoveFlag && (this.resizeHandlerMoveFlag = !0, this.mouseMoveResizeHander = e, this._saveElsInfoPreMouseAction()), this.canvasMoveFlag || this.resizeHandlerMoveFlag || (this.devicePixelRatio = window.devicePixelRatio || 1, this.selectElByMouseSite(t.clientX, t.clientY), this._saveElsInfoPreMouseAction()), document.addEventListener('mousemove', this.bindEventList.mouseMoveDisplayable), document.addEventListener('mouseup', this.bindEventList.stopMove)
    }

    _saveElsInfoPreMouseAction() {
      this.spr.selector.getSelectElements().forEach(t => {
        'FreeContainer' === t.constructor.name && t.saveInfoPreMouseAction(), 'Group' === t.constructor.name && t.saveInfoPreMouseAction()
      })
    }

    _stopMove(t) {
      if (this.spr.selector.showResizeHandler(), this.resizeHandlerMoveFlag && (this.resizeHandlerMoveFlag = !1, this.spr.eventbus.emit('resizeHandlerMoveEnd', {})), document.removeEventListener('mousemove', this.bindEventList.mouseMoveDisplayable), document.removeEventListener('mouseup', this.bindEventList.stopMove), this.spr.eventbus.emit('containerMoveEnd', {}), !this.canvasMoveFlag && !this.resizeHandlerMoveFlag) {
        const t = this.spr.selector.getSelectFreeContainers(), e = [], s = [];
        t && t.forEach(t => {
          const i = { id: t.id, opts: { top: t.oldOptsRecord.top, left: t.oldOptsRecord.left } },
            n = { id: t.id, opts: { top: t.top, left: t.left } };
          i.opts.top === n.opts.top && i.opts.left === n.opts.left || (e.push(i), s.push(n))
        }), e.length > 0 && s.length > 0 && this.spr.commandManager.doCommand(C.SETOPT, s, e)
      }
      this.mouseMoveInfo.x = 0, this.mouseMoveInfo.y = 0
    }

    _moveDisplayable(t) {
      return this.canvasMoveFlag ? void this._moveCanvas(t) : this.resizeHandlerMoveFlag ? void this._moveResizeHandler(t) : void this._moveContainer(t)
    }

    _moveCanvas(t) {
      let e = t.movementX, s = t.movementY;
      const i = G();
      P(i), i[4] = e, i[5] = s;
      const n = (r = this.matrix, h = G(), a = r, (o = h)[0] = a[0], o[1] = a[1], o[2] = a[2], o[3] = a[3], o[4] = a[4], o[5] = a[5], h);
      var r, o, a, h;
      this.matrix = H(n, i, n)
    }

    _moveContainer(t) {
      this._cumulationMoveDist(t), this.spr.selector.hiddenResizeHandler();
      const e = this.spr.selector.getSelectElements(), s = this.spr.alignmentLineStorage,
        i = s && s.getAdsorbStatus('top'), n = s && s.getAdsorbStatus('left');
      e.forEach(t => {
        if ('FreeContainer' === t.constructor.name) {
          const e = t.oldOptsRecord;
          !i && e && !t.getLockStatusByPropName('top') && (t.top = Math.floor(this.mouseMoveInfo.y + e.top)), !n && e && !t.getLockStatusByPropName('left') && (t.left = Math.floor(this.mouseMoveInfo.x + e.left))
        }
        'Group' === t.constructor.name && t.moveGroupElsByMouse(this.mouseMoveInfo.x, this.mouseMoveInfo.y)
      }), this.spr.selector.moveBoundRect(), this.spr.eventbus.emit('containerMove', { event: t })
    }

    _moveResizeHandler(t) {
      this._cumulationMoveDist(t), 'ResizeHandler' === this.mouseMoveResizeHander.constructor.name && this.mouseMoveResizeHander.moveHandler(t)
    }

    _cumulationMoveDist(t) {
      let e = 0, s = 0;
      window.navigator.userAgent.indexOf('Mac OS X') > -1 ? (e = t.movementX, s = t.movementY) : (e = t.movementX / this.devicePixelRatio, s = t.movementY / this.devicePixelRatio), this.mouseMoveInfo.x += e / this.ratio, this.mouseMoveInfo.y += s / this.ratio
    }

    _zoomCanvas(t) {
      let e, s;
      if (e = t.deltaY < 0 ? 1.1 : .9, T().appMode) {
        const e = this.spr.root.getBoundingClientRect();
        s = [t.clientX - e.left, t.clientY - e.top]
      } else s = [t.clientX, t.clientY];
      this.zoomCanvas(s, e)
    }

    _keyDown(t) {
      if ('Escape' === t.key) {
        if (!T().enableEsc) return;
        if ('matrix' === T().canvasMode) {
          const t = this.spr.storage;
          t.mouseOverElement && (t.mouseOverElement = null), this.spr.selector.clear()
        } else R('canvasMode', 'matrix'), this.setSize(this.rawWidth, this.rawHeight), this.spr.eventbus.emit('canvasResizeOnPlayMode', {
          width: this.rawWidth,
          height: this.rawHeight
        }), this.zoomCanvasToCenter(), this._resizeWindowManul()
      }
      ' ' === t.key && 'matrix' === T().canvasMode && (this.canvasMoveFlag = !0, this.spr.canvas.style.cursor = 'pointer'), 'Control' !== t.key && 'Meta' !== t.key || this.spr.selector.setMultiSelect(!0), 'Shift' === t.key && (this.shiftDown = !0), 37 === t.keyCode && (t.shiftKey ? this._moveContainerOnepx(-10, 'left', t) : this._moveContainerOnepx(-1, 'left', t)), 38 === t.keyCode && (t.shiftKey ? this._moveContainerOnepx(-10, 'top', t) : this._moveContainerOnepx(-1, 'top', t)), 39 === t.keyCode && (t.shiftKey ? this._moveContainerOnepx(10, 'left', t) : this._moveContainerOnepx(1, 'left', t)), 40 === t.keyCode && (t.shiftKey ? this._moveContainerOnepx(10, 'top', t) : this._moveContainerOnepx(1, 'top', t))
    }

    _moveContainerOnepx(t, e, s) {
      if ('matrix' === T().canvasMode) {
        const i = this.spr.selector.getSelectElements();
        if (!(i.length > 0)) return;
        window.clearTimeout(this.keyDownTimer), this.keyDownTimer = null, this.spr.selector.hiddenResizeHandler(), i.forEach(s => {
          'FreeContainer' === s.constructor.name && !s.getLockStatusByPropName(e) && (s[e] += t), 'Group' === s.constructor.name && s.moveGroupElsByKeyboard(e, t)
        }), this.spr.selector.moveBoundRect(), this.spr.eventbus.emit('containerMove', { event: s })
      }
    }

    _keyUp(t) {
      this.canvasMoveFlag = !1, this.spr.canvas.style.cursor = 'default', this.spr.selector.setMultiSelect(!1), 'Shift' === t.key && (this.shiftDown = !1), 37 !== t.keyCode && 38 !== t.keyCode && 39 !== t.keyCode && 40 !== t.keyCode || (this.keyDownTimer = setTimeout(() => {
        this.spr.selector.showResizeHandler(), this.spr.eventbus.emit('containerMoveEnd', {})
      }, 500))
    }

    _windowResize() {
      this.spr.resize(), 'matrix' !== T().canvasMode && this._resizeCanvas()
    }

    _resizeWindowManul() {
      const t = new Event('resize');
      window.dispatchEvent(t)
    }

    _resizeCanvas() {
      this.matrix = [1, 0, 0, 1, 0, 0], this.setSize(this.spr.width, this.spr.height), this.spr.eventbus.emit('canvasResizeOnPlayMode', {
        width: this.rawWidth,
        height: this.rawHeight
      })
    }

    _rootClick(t) {
      this.spr.storage.mouseOverElement || t.target === this.spr.root && (this.spr.selector.clear(), this.spr.storage.mouseOverElement = null)
    }

    _onConfigChange(t) {
      'canvasMode' === t.key && ('matrix' === t.value && (this._offPlayEvent(), this._onCanvasBaseEvent()), 'play' === t.value && (this._offCanvasBaseEvent(), this._onPlayEvent(), function () {
        this.spr.selector.clear(), this.spr.storage.mouseOverElement = null
      }.call(this), this.zoomCanvasToCenter(), this.ratio = 1, this._resizeCanvas(), this._resizeWindowManul()))
    }

    _getContainDisplayable(t, e) {
      let s = [];
      return this.spr.storage._displayables.forEach(i => {
        'Canvas' !== i.constructor.name && i.isShow && !i.ignoreStatus && i.contain(t, e) && s.push(i)
      }), s
    }

    selectElByMouseSite(t, e, s = !1) {
      const i = this._getContainDisplayable(t, e);
      let n = null,
        r = i.reverse().filter(t => ('thingjsLayer' === t.id && (n = t), !this.ignoreBoundingActiveReg.test(t.constructor.name)))[0];
      if (s && !r && n && this.enterThingjsPreview(n), r && r.groupId) {
        const t = this.spr.storage.findForefatherByEl(r);
        this.shiftDown ? this.spr.selector.deselect(t) : r = t
      }
      this.spr.selector.isMultSelect ? this.spr.selector.select(r) : this.spr.selector.getSelectStatus(r) || this.spr.selector.select(r)
    }

    enterThingjsPreview(t) {
      R('enableMouseWheel', !1), this._offCanvasEvent(), this.thingjsOrder = t.order, this.thinggsDispalyable = t, t.order = 9999, t.style.pointerEvents = 'all', this.thingjsPreview = !0, document.addEventListener('keydown', this.bindEventList.thingjsKeyDown)
    }

    _thingjsKeyDown(t) {
      'Escape' === t.key && this.thingjsPreview && this.exitThingjsPreview()
    }

    exitThingjsPreview() {
      R('enableMouseWheel', !0), this._onCanvasEvent(), this.thinggsDispalyable.order = this.thingjsOrder, this.thinggsDispalyable.style.pointerEvents = 'none', this.thinggsDispalyable = null, this.thingjsPreview = !1, document.removeEventListener('keydown', this.bindEventList.thingjsKeyDown)
    }

    _onPlayEvent() {
      this.on('mousedown', this._mouseDownOnPlay, this)
    }

    _offPlayEvent() {
      this.off('mousedown', this._mouseDownOnPlay, this), this.canMoveContainerOnPlay = null
    }

    _mouseDownOnPlay(t) {
      this.devicePixelRatio = window.devicePixelRatio || 1;
      const e = this._getContainDisplayable(t.clientX, t.clientY).reverse().filter(t => !this.ignoreBoundingActiveReg.test(t.constructor.name))[0];
      e && 'FreeContainer' === e.constructor.name && e.freeOnPlay && (this.canMoveContainerOnPlay = e, document.addEventListener('mousemove', this.bindEventList.mouseMoveDisplayableOnPlay), document.addEventListener('mouseup', this.bindEventList.stopMoveOnPlay))
    }

    _mouseMoveDisplayableOnPlay(t) {
      if (this.canMoveContainerOnPlay) {
        let e = 0, s = 0;
        window.navigator.userAgent.indexOf('Mac OS X') > -1 ? (e = t.movementX, s = t.movementY) : (e = t.movementX / this.devicePixelRatio, s = t.movementY / this.devicePixelRatio), this.canMoveContainerOnPlay.top += s, this.canMoveContainerOnPlay.left += e
      }
    }

    _stopMoveOnPlay(t) {
      this.canMoveContainerOnPlay = null, document.removeEventListener('mousemove', this.bindEventList.mouseMoveDisplayableOnPlay), document.removeEventListener('mouseup', this.bindEventList.stopMoveOnPlay)
    }
  }]), u('Canvas', Canvas);

  class Layer extends Displayable {
    constructor(t, e) {
      super(t, e);
      this.typeName = '图层', this.opts = v({
        id: null,
        name: null,
        width: 'inherit',
        height: 'inherit',
        order: 0,
        ignoreRendering: !1,
        lock: { left: !1, top: !1, width: !1, height: !1 },
        style: {
          position: 'absolute',
          top: 0,
          left: 0,
          backgroundRepeat: 'no-repeat',
          backgroundSize: 'cover',
          backgroundPosition: 'center',
          pointerEvents: 'none'
        }
      }, this._options), this.style.setOption(this.opts.style), this.opts.sceneAnimator && (this.sceneAnimator.enter = this.opts.sceneAnimator.enter, this.sceneAnimator.leave = this.opts.sceneAnimator.leave), this.opts.width && (this.width = this.opts.width), this.opts.height && (this.height = this.opts.height), this.initId('layer'), this.layoutManager = null, this.initDom(), this.initAnimator()
    }

    reSizeToCanvas() {
      this.width = this.parent.width, this.height = this.parent.height
    }

    static factory(t, e) {
      return new Layer(t, e)
    }

    setInheritAll(t) {
      this.setInheritWidth(t), this.setInheritHeight(t)
    }

    setInheritWidth(t) {
      this.inheritWidth = t
    }

    setInheritHeight(t) {
      this.inheritHeight = t
    }

    setIgnore(t) {
      this.ignoreRendering = t
    }

    createLayout(t, e) {
      return this.layoutManager && console.warn('该图层已经创建了一个布局对象，如果需要创建新布局，请将原来的布局destroy'), this.layoutManager = p(t, this, e), this.layoutManager
    }

    createContainer(t) {
      this.children[0] && (this.layoutManager = this.children[0]), this.layoutManager.createContainer(t)
    }

    toJSON() {
      const t = super.toJSON();
      return t.type = 'Layer', t.option.order = this.order, t.option.ignoreRendering = this.opts.ignoreRendering, t
    }

    async destroy(t = !0) {
      if (this.spr.selector.deselect(this), t && !this.ignoreRendering && 'matrix' !== T().canvasMode && await TransitionFilter.factory(this).runLeaveAnimator(), this.layoutManager) await this.layoutManager.destroy(!1), this.layoutManager = null; else for (let t of this.children) await t.destroy();
      this.children = [], this.destroyAdapter(), !this.ignoreRendering && await this.unmount(), this._spr && this._spr.storage.deleteElFromStorage(this), this.parent && this.parent.removeChildren(this), this.parent = null, this._spr = null
    }

    set inheritWidth(t) {
      g(t, 'Boolean') && (this.opts.inheritWidth = t, this.dirty = !0)
    }

    get inheritWidth() {
      return this.opts.inheritWidth
    }

    set inheritHeight(t) {
      g(t, 'Boolean') && (this.opts.inheritHeight = t, this.dirty = !0)
    }

    get inheritHeight() {
      return this.opts.inheritHeight
    }

    set ignoreRendering(t) {
      g(t, 'Boolean') && this.opts.ignoreRendering !== t && (t ? this._doUnmount(t) : (this.opts.ignoreRendering = t, this.spr.painter.mountFromDisplayable(this)))
    }

    async _doUnmount(t) {
      await this.unmount(!0), this.opts.ignoreRendering = t
    }

    get ignoreRendering() {
      return this.opts.ignoreRendering
    }
  }

  u('Layer', Layer);

  class Painter {
    constructor(t, e) {
      this.parent = t, this.storage = e, this._reDrawId = null, this.isRunning = !1
    }

    static factory(t, e) {
      return new Painter(t, e)
    }

    refresh() {
      if (this.isRunning) return;
      this.isRunning = !0;
      const t = this.storage.getDisplayable(), e = this.storage.getAdapters();
      this._reDrawId = Math.random(), this._paintList(t, this._reDrawId), this._paintList(e, this._reDrawId), this.isRunning = !1
    }

    _paintList(t, e) {
      this._reDrawId === e && this._doPaintList(t)
    }

    _doPaintList(t) {
      t.forEach(t => {
        t.dirty = !1, t.update()
      })
    }

    mountFromDisplayable(t) {
      if (t.getRoot().children.length > 0) return t.hidden(!1), t.mount(), t.show(), void this.parent.eventbus.emit('layerReload', t.id);
      this._doChildrenMount(t)
    }

    _doChildrenMount(t) {
      g(t.children, 'Array') && t.children.length > 0 && t.children.forEach(t => {
        this.mountFromDisplayable(t)
      }), t.mount(), t.dirty = !0
    }

    paintFromDisplayable(t) {
      t.dirty = !0, t.adapter && t.adapter.repaint(), t.children && t.children.forEach(t => {
        this.paintFromDisplayable(t)
      })
    }
  }

  class Selector {
    constructor(t) {
      this.parent = t, this.boundRect = null, this.selectElements = [], this.isMultSelect = !1
    }

    static factory(t) {
      return this.instance || (this.instance = new Selector(t)), this.instance
    }

    select(t) {
      this.isMultSelect || this.clear();
      const e = [];
      if (g(t, 'Array')) t.forEach(t => {
        const s = this._selectSingle(t);
        s && e.push(s)
      }); else {
        const s = this._selectSingle(t);
        s && e.push(s)
      }
      this.selectElements = [...this.selectElements, ...e], this.selectElements.length > 0 ? this.showBoundRect() : this.hiddenBoundRect(), this.parent.eventbus.emit('selectChange')
    }

    _selectSingle(t) {
      return this.selectElements.some(e => e === t) ? (this.isMultSelect && this.deselect(t), null) : t && t.select ? (t.select(), t) : null
    }

    deselect(t) {
      const e = [];
      if (g(t, 'Array')) t.forEach(t => {
        const s = this._deselectSingle(t);
        s && e.push(s)
      }); else {
        const s = this._deselectSingle(t);
        s && e.push(s)
      }
      e.forEach(t => {
        const e = this.selectElements.indexOf(t);
        this.selectElements.splice(e, 1)
      }), this.selectElements.length > 0 ? this.showBoundRect() : this.hiddenBoundRect()
    }

    _deselectSingle(t) {
      return this.selectElements.some(e => e === t) && t && t.deselect ? (t.deselect(), t) : null
    }

    clear() {
      this.deselect([...this.selectElements])
    }

    createGroupBySelected() {
      const t = this.selectElements.filter(t => 'FreeContainer' === t.constructor.name || 'Group' === t.constructor.name);
      return t.sort((t, e) => t.order - e.order), this.parent.commandManager.doCommand(C.CREATEGROUP, t, '未命名组')
    }

    removeSelectedEl() {
      let t = null;
      const e = [...this.selectElements];
      return e.sort((t, e) => t.order - e.order), t = this.parent.commandManager.doCommand(C.REMOVE, e), this.selectElements = [], this.hiddenBoundRect(), t
    }

    getSelectElements() {
      return [...this.selectElements]
    }

    getSelectFreeContainers() {
      let t = [];
      return this.selectElements.forEach(e => {
        if ('FreeContainer' === e.constructor.name && t.push(e), 'Group' === e.constructor.name) {
          const s = e.getAllElsInGroups();
          t = [...t, ...s]
        }
      }), t
    }

    getSelectStatus(t) {
      let e = !1;
      if (this.selectElements.includes(t)) return !0;
      if (t && t.groupId) {
        const s = this.parent.getElementById(t.groupId);
        e = this.getGroupSelectStatus(s)
      }
      return e
    }

    getGroupSelectStatus(t) {
      let e = !1;
      return !(!t || !this.selectElements.includes(t)) || (t.groupId && (e = this.getGroupSelectStatus(this.parent.getElementById(t.groupId))), e)
    }

    getSelectLockStatus() {
      let t = !1;
      return this.selectElements.forEach(e => {
        'FreeContainer' === e.constructor.name && (t = e.getLockStatusByPropName('top') || e.getLockStatusByPropName('left')), 'Group' === e.constructor.name && (t = e.getSelectLockStatus())
      }), t
    }

    getSelectBoundRect() {
      if (0 === this.selectElements.length) return null;
      const t = [], e = [], s = [], i = [];
      this.selectElements.forEach(n => {
        if (n && 'FreeContainer' === n.constructor.name && (t.push(n.top), e.push(n.left), s.push(n.left + n.width), i.push(n.top + n.height)), n && 'Group' === n.constructor.name) {
          const r = n.getBoundRect();
          t.push(r.top), e.push(r.left), s.push(r.right), i.push(r.bottom)
        }
        !n || 'Layer' !== n.constructor.name && 'Canvas' !== n.constructor.name || (t.push(0), e.push(0), s.push(0), i.push(0))
      });
      const n = Math.min(...t) || 0, r = Math.min(...e) || 0, o = Math.max(...s) || 0, a = Math.max(...i) || 0;
      return { top: n, left: r, right: o, bottom: a, width: o - r || 0, height: a - n || 0 }
    }

    setBoundRect(t) {
      this.boundRect = t
    }

    setMultiSelect(t) {
      this.isMultSelect !== t && g(t, 'Boolean') && (this.isMultSelect = t)
    }

    hiddenBoundRect() {
      this.boundRect && this.boundRect.show(null)
    }

    showBoundRect() {
      const t = this.getSelectBoundRect();
      this.boundRect && this.boundRect.show(t)
    }

    hiddenResizeHandler() {
      this.parent && this.parent.functionLayer.hiddenResizeHandler()
    }

    showResizeHandler() {
      this.parent && this.parent.functionLayer.resetResizeHandler()
    }

    moveBoundRect() {
      const t = this.getSelectBoundRect();
      this.boundRect && this.boundRect.moveBoundRect(t)
    }
  }

  n(Selector, [class {
    constructor() {
    }

    alignLeft() {
      this.alignHorizDiffByType('left')
    }

    alignRight() {
      this.alignHorizDiffByType('right')
    }

    vertiCenter() {
      this.alignHorizDiffByType('center')
    }

    alignHorizDiffByType(t) {
      const e = this.getSelectElements(), s = [], i = [];
      e.forEach(e => {
        if ('FreeContainer' === e.constructor.name && ('left' === t && s.push(e.left), 'right' === t && s.push(e.left + e.width), 'center' === t && s.push(e.left) && i.push(e.left + e.width)), 'Group' === e.constructor.name) {
          const n = e.getBoundRect();
          let r = null, o = null;
          'left' === t && (r = n.left), 'right' === t && (r = n.left + n.width), 'center' === t && (r = n.left) && (o = n.left + n.width) && i.push(o), s.push(r)
        }
      });
      let n = null;
      'left' === t && (n = Math.min(...s)), 'right' === t && (n = Math.max(...s)), 'center' === t && (n = (Math.max(...i) - Math.min(...s)) / 2 + Math.min(...s)), g(n, 'Number') && e.forEach(e => {
        if ('FreeContainer' === e.constructor.name && ('left' === t && (e.left = n), 'right' === t && (e.left = n - e.width), 'center' === t && (e.left = n - e.width / 2)), 'Group' === e.constructor.name) {
          const s = e.getBoundRect();
          let i = null;
          'left' === t && (i = s.left), 'right' === t && (i = s.left + s.width), 'center' === t && (i = s.left + s.width / 2);
          const r = n - i;
          e.moveGroupElsByKeyboard('left', r)
        }
      }), this.showBoundRect()
    }

    alignTop() {
      this.alignVertiDiffByType('top')
    }

    alignBottom() {
      this.alignVertiDiffByType('bottom')
    }

    horizCenter() {
      this.alignVertiDiffByType('center')
    }

    alignVertiDiffByType(t) {
      const e = this.getSelectElements(), s = [], i = [];
      e.forEach(e => {
        if ('FreeContainer' === e.constructor.name && ('top' === t && s.push(e.top), 'bottom' === t && s.push(e.top + e.height), 'center' === t && s.push(e.top) && i.push(e.top + e.height)), 'Group' === e.constructor.name) {
          const n = e.getBoundRect();
          let r = null, o = null;
          'top' === t && (r = n.top), 'bottom' === t && (r = n.top + n.height), 'center' === t && (r = n.top) && (o = n.top + n.height) && i.push(o), s.push(r)
        }
      });
      let n = null;
      'top' === t && (n = Math.min(...s)), 'bottom' === t && (n = Math.max(...s)), 'center' === t && (n = (Math.max(...i) - Math.min(...s)) / 2 + Math.min(...s)), g(n, 'Number') && e.forEach(e => {
        if ('FreeContainer' === e.constructor.name && ('top' === t && (e.top = n), 'bottom' === t && (e.top = n - e.height), 'center' === t && (e.top = n - e.height / 2)), 'Group' === e.constructor.name) {
          const s = e.getBoundRect();
          let i = null;
          'top' === t && (i = s.top), 'bottom' === t && (i = s.top + s.height), 'center' === t && (i = s.top + s.height / 2);
          const r = n - i;
          e.moveGroupElsByKeyboard('top', r)
        }
      }), this.showBoundRect()
    }

    horizDistributionByValue(t) {
      if (!g(t, 'Number')) return;
      const e = this.getSelectElements().filter(t => 'FreeContainer' === t.constructor.name || 'Group' === t.constructor.name);
      e.sort((t, e) => t.left - e.left), e.forEach((s, i) => {
        if (i > 0 && ('FreeContainer' === s.constructor.name && (s.left = e[i - 1].left + e[i - 1].width + t), 'Group' === s.constructor.name)) {
          const n = s.left, r = e[i - 1].left + e[i - 1].width + t - n;
          s.moveGroupElsByKeyboard('left', r)
        }
      }), this.showBoundRect()
    }

    vertiDistributionByValue(t) {
      if (!g(t, 'Number')) return;
      const e = this.getSelectElements().filter(t => 'FreeContainer' === t.constructor.name || 'Group' === t.constructor.name);
      e.sort((t, e) => t.top - e.top), e.forEach((s, i) => {
        if (i > 0 && ('FreeContainer' === s.constructor.name && (s.top = e[i - 1].top + e[i - 1].height + t), 'Group' === s.constructor.name)) {
          const n = s.top, r = e[i - 1].top + e[i - 1].height + t - n;
          s.moveGroupElsByKeyboard('top', r)
        }
      }), this.showBoundRect()
    }
  }]);

  class Storage {
    constructor(t) {
      this.spr = t, this.displayableStructure = [], this._displayables = [], this._adapters = [], this._selectedElement = null, this._selectedFlag = !1, this._mouseOverElement = null, this._mouseOverFlag = !1
    }

    static factory(t) {
      return new Storage(t)
    }

    addElToStorage(t) {
      this.addElToStructure(t), this._updateElOrder()
    }

    addElToStructure(t) {
      if (t.dirty = !0, 'Canvas' === t.constructor.name && this.displayableStructure.unshift(t), 'Layer' === t.constructor.name) {
        const e = this._findParentArr(t);
        e && e.push([t])
      }
      if ('Free' === t.constructor.name) {
        const e = this._findParentArr(t);
        e && e.push(t)
      }
      if ('FreeContainer' === t.constructor.name) {
        const e = this._findParentArr(t);
        e && e.push(t)
      }
      if ('Group' === t.constructor.name) {
        const e = this._findParentArr(t);
        e && e.splice(t.order, 0, [t])
      }
      this._displayables = this.displayableStructure.flat(1 / 0)
    }

    findStructrueDataByLayer(t) {
      let e = null;
      return t ? 'Layer' !== t.constructor.name ? null : (e = this.displayableStructure.find(e => e[0] && e[0] === t), e) : null
    }

    findForefatherByEl(t) {
      let e = null;
      if (t) {
        const s = this._displayables.find(e => e.id === t.groupId);
        s && (e = s.groupId ? this.findForefatherByEl(s) : s)
      }
      return e
    }

    _findParentArr(t) {
      if (this._displayables.includes(t)) console.warn('不可重复添加元素对象'); else {
        if ('Layer' === t.constructor.name) return this.displayableStructure;
        if ('Free' === t.constructor.name) {
          return this.displayableStructure.find(e => e[0] === t.parent)
        }
        if ('FreeContainer' === t.constructor.name || 'Group' === t.constructor.name) {
          if (t.groupId) {
            const e = this.displayableStructure.find(e => e[1] === t.parent);
            if (e[2]) {
              return this._findGroupArr(t, e[2])
            }
            return console.warn('没有找到Group，已将容器添加到父图层'), e.push([]), e[2]
          }
          {
            const e = this.displayableStructure.find(e => e[1] === t.parent);
            return e[2] || e.push([]), e[2]
          }
        }
      }
    }

    _findGroupArr(t, e) {
      if (!g(e, 'Array')) return null;
      let s = null;
      return e[0].id === t.groupId ? (s = e, s) : (e.forEach(e => {
        if (g(e, 'Array')) {
          const i = this._findGroupArr(t, e);
          i && (s = i)
        }
      }), s)
    }

    findGroupParentArr(t) {
      let e = null;
      if (t && 'Group' === t.constructor.name) {
        const s = this.displayableStructure.find(e => e[1] === t.parent);
        e = t.groupId ? this._findGroupArr(t, s) : s[2]
      }
      return e
    }

    _updateElOrder() {
      this._displayables.forEach(t => {
        const e = this._displayables.indexOf(t);
        t.order = e
      })
    }

    addAdapterToStorage(t) {
      t.dirty = !0, this._adapters.push(t)
    }

    deleteElFromStorage(t) {
      if (t) {
        if ('Canvas' === t.constructor.name && (this.displayableStructure = []), 'Layer' === t.constructor.name) {
          const e = this.displayableStructure.findIndex(e => e[0] && e[0].id === t.id);
          this.displayableStructure.splice(e, 1)
        }
        if ('FreeContainer' === t.constructor.name) {
          const e = this.displayableStructure.find(e => e[1] === t.parent)[2];
          if (e) if (t.groupId) {
            const s = this._findGroupArr(t, e);
            if (s) {
              const e = s.indexOf(t);
              s.splice(e, 1)
            }
          } else {
            const s = e.indexOf(t);
            e.splice(s, 1)
          }
        }
        if ('Group' === t.constructor.name) {
          const e = this.displayableStructure.find(e => e[1] === t.parent)[2];
          if (e) if (t.groupId) {
            const s = this._findGroupArr(t, e), i = s.findIndex(e => e[0] && e[0].id === t.id);
            s[i] && 1 === s[i].length ? s.splice(i, 1) : console.warn('请先移除组内所有成员后再移除组')
          } else {
            const s = e.findIndex(e => e[0] && e[0].id === t.id);
            e[s] && 1 === e[s].length ? e.splice(s, 1) : console.warn('请先移除组内所有成员后再移除组')
          }
        }
        this._displayables = this.displayableStructure.flat(1 / 0), this._updateElOrder()
      }
    }

    moveDisplayables(t, e, s = 'front') {
      g(t, 'Array') ? t.forEach(t => {
        this.moveDisplayable(t, e, s)
      }) : this.moveDisplayable(t, e, s)
    }

    moveDisplayable(t, e, s = 'front') {
      if ('Layer' === t.constructor.name && 'Layer' === e.constructor.name) {
        const i = this.displayableStructure.findIndex(e => e[0] && e[0].id === t.id);
        if ('front' === s) {
          const t = this.displayableStructure.splice(i, 1),
            s = this.displayableStructure.findIndex(t => t[0] && t[0].id === e.id);
          this.displayableStructure.splice(s, 0, ...t)
        }
        if ('behind' === s) {
          const t = this.displayableStructure.splice(i, 1),
            s = this.displayableStructure.findIndex(t => t[0] && t[0].id === e.id);
          this.displayableStructure.splice(s + 1, 0, ...t)
        }
      }
      'FreeContainer' === t.constructor.name && this._moveFreeContainer(t, e, s), 'Group' === t.constructor.name && this._moveGroup(t, e, s), this._displayables = this.displayableStructure.flat(1 / 0), this._updateElOrder()
    }

    _moveFreeContainer(t, e, s = 'front') {
      if (t === e) return;
      if ('FreeContainer' !== t.constructor.name) return;
      const i = this.displayableStructure.find(e => e[1] === t.parent)[2];
      if (t.groupId) {
        const e = this._findGroupArr(t, i), s = e.indexOf(t);
        e.splice(s, 1), t.groupId = null
      } else {
        const e = i.indexOf(t);
        i.splice(e, 1)
      }
      this._addElToNewSite(t, e, t, s), t.parent !== e.parent && this._changeParent(t, e)
    }

    _moveGroup(t, e, s = 'front') {
      if (t === e) return;
      if ('Group' !== t.constructor.name) return;
      const i = this.displayableStructure.find(e => e[1] === t.parent)[2];
      let n = null;
      if (t.groupId) {
        const e = this._findGroupArr(t, i), s = e.findIndex(e => !(!e[0] || e[0].id !== t.id) && (n = e, !0));
        e.splice(s, 1), t.groupId = null
      } else {
        const e = i.findIndex(e => !(!e[0] || e[0].id !== t.id) && (n = e, !0));
        i.splice(e, 1)
      }
      n ? (this._addElToNewSite(t, e, n, s), t.parent !== e.parent && this._changeParent(n, e)) : console.warn('没有找到需要移动的组')
    }

    _addElToNewSite(t, e, s, i = 'front') {
      if ('Layer' === e.constructor.name) {
        const t = this.displayableStructure.find(t => t[0] && t[0].id === e.id);
        return void (t && (t[2] && g(t[2], 'Array') ? 'infront' === i ? t[2].unshift(s) : t[2].push(s) : t.push([s])))
      }
      const n = this.displayableStructure.find(t => t[1] === e.parent)[2];
      if (e.groupId) {
        if ('FreeContainer' === e.constructor.name) {
          const r = this._findGroupArr(e, n), o = r.indexOf(e);
          o >= 0 && (t.groupId = e.groupId, this._addElFrontBehind(s, r, o, i))
        }
        if ('Group' === e.constructor.name) {
          const r = this._findGroupArr(e, n), o = r.findIndex(t => t[0] && t[0].id === e.id);
          if (o >= 0) {
            if ('front' !== i && 'behind' !== i || (t.groupId = e.groupId, this._addElFrontBehind(s, r, o, i)), 'in' === i) {
              const i = r[o];
              g(i, 'Array') && (t.groupId = e.id, i.push(s))
            }
            if ('infront' === i) {
              const i = r[o];
              g(i, 'Array') && (t.groupId = e.id, i.splice(1, 0, s))
            }
          }
        }
      } else {
        if ('FreeContainer' === e.constructor.name) {
          const t = n.indexOf(e);
          t >= 0 && this._addElFrontBehind(s, n, t, i)
        }
        if ('Group' === e.constructor.name) {
          const r = n.findIndex(t => t[0] && t[0].id === e.id);
          if (r >= 0) {
            if ('front' !== i && 'behind' !== i || this._addElFrontBehind(s, n, r, i), 'in' === i) {
              const i = n[r];
              g(i, 'Array') && (t.groupId = e.id, i.push(s))
            }
            if ('infront' === i) {
              const i = n[r];
              g(i, 'Array') && (t.groupId = e.id, i.splice(1, 0, s))
            }
          }
        }
      }
    }

    _addElFrontBehind(t, e, s, i) {
      switch (i) {
        case'front':
          e.splice(s, 0, t);
          break;
        case'behind':
          e.splice(s + 1, 0, t);
          break;
        default:
          e.splice(s, 0, t)
      }
    }

    _changeParent(t, e) {
      if (g(t, 'Array')) this._loopChangeParent(t, e); else {
        if (t.unmountSync(), t.parent.removeChildren(t), 'Layer' !== e.constructor.name) t.parent = e.parent, e.parent.addChildren(t); else {
          const s = e.children[0];
          s && (t.parent = s), s.addChildren(t)
        }
        t.mount()
      }
    }

    _loopChangeParent(t, e) {
      t.forEach(t => {
        if (g(t, 'Array')) this._loopChangeParent(t, e); else {
          if ('FreeContainer' === t.constructor.name) {
            if (t.unmountSync(), t.parent.removeChildren(t), 'Layer' !== e.constructor.name) t.parent = e.parent, e.parent.addChildren(t); else {
              const s = e.children[0];
              s && (t.parent = s), s.addChildren(t)
            }
            t.mount()
          }
          if ('Group' === t.constructor.name) if (t.parent.removeChildren(t), 'Layer' !== e.constructor.name) t.parent = e.parent, e.parent.addChildren(t); else {
            const s = e.children[0];
            s && (t.parent = s), s.addChildren(t)
          }
        }
      })
    }

    findIndexAtParent(t) {
      let e = -1;
      const s = this.displayableStructure.find(e => e[1] === t.parent)[2];
      if (t.groupId) {
        if ('FreeContainer' === t.constructor.name) {
          e = this._findGroupArr(t, s).indexOf(t)
        }
        if ('Group' === t.constructor.name) {
          e = this._findGroupArr(t, s).findIndex(e => e[0] && e[0].id === t.id)
        }
      } else 'FreeContainer' === t.constructor.name && (e = s.findIndex(e => e.id === t.id)), 'Group' === t.constructor.name && (e = s.findIndex(e => e[0] && e[0].id === t.id));
      return e
    }

    deleteAdapterFromStorage(t) {
      this._adapters = this._adapters.filter(e => e !== t)
    }

    getDisplayable() {
      return this._displayables.filter(t => !0 === t.dirty && !t.ignoreStatus && 'Group' !== t.constructor.name)
    }

    getAdapters() {
      return this._adapters.filter(t => !0 === t.dirty)
    }

    getElementById(t) {
      return this._displayables.filter(e => e.id === t)
    }

    getElementByGroup(t) {
      let e = [];
      if (t && 'Group' === t.constructor.name) {
        const s = t.id;
        e = this._displayables.filter(t => t.groupId === s)
      }
      return e
    }

    getAllElementByGroupExcludeGroup(t) {
      let e = [];
      if (t && 'Group' === t.constructor.name) {
        const s = this.displayableStructure.find(e => e[1] === t.parent);
        if (s && g(s, 'Array')) {
          const i = s[2];
          if (t.groupId) {
            e = this._findGroupArr(t, i).find(e => e[0] && e[0].id === t.id)
          } else e = i.find(e => e[0] && e[0].id === t.id)
        }
      }
      return e = e.flat(1 / 0).filter(t => 'FreeContainer' === t.constructor.name), e
    }

    getAllElementByGroupIncludeGroup(t) {
      let e = [];
      if (t && 'Group' === t.constructor.name) {
        const s = this.displayableStructure.find(e => e[1] === t.parent);
        if (s && g(s, 'Array')) {
          const i = s[2];
          if (t.groupId) {
            e = this._findGroupArr(t, i).find(e => e[0] && e[0].id === t.id)
          } else e = i.find(e => e[0] && e[0].id === t.id)
        }
      }
      return e = e.flat(1 / 0), e
    }

    getElementByName(t) {
      return this._displayables.filter(e => e.name === t)
    }

    getDisplayableListByClassName(t) {
      return t ? g(t, 'String') ? this._displayables.filter(e => new RegExp(`^(${ t })$`).test(e.constructor.name)) : console.error('参数不是字符串：' + t) : this._displayables
    }

    getFrontIdByEl(t) {
      if (!t) return null;
      let e = null, s = -1;
      const i = t.constructor.name;
      if ('Layer' === t.constructor.name) {
        const n = this._displayables.filter(t => t.constructor.name === i);
        s = n.indexOf(t), s >= 0 && n[s - 1] && (e = n[s - 1])
      }
      if ('FreeContainer' === t.constructor.name || 'Group' === t.constructor.name) {
        const s = this.displayableStructure.find(e => e[1] === t.parent)[2];
        if (t.groupId) {
          const i = this._findGroupArr(t, s);
          let n = null;
          if ('FreeContainer' === t.constructor.name) {
            const s = i.indexOf(t);
            n = i[s - 1], n && n.id !== t.groupId && (n && !g(n, 'Array') && (e = n), n && g(n, 'Array') && n[0] && (e = n[0]))
          }
          if ('Group' === t.constructor.name) {
            const s = i.findIndex(e => e && e[0] && e[0].id === t.id);
            s >= 0 && (n = i[s - 1]), n && (n && !g(n, 'Array') && (e = n), n && g(n, 'Array') && n[0] && (e = n[0]))
          }
        } else {
          let i = -1;
          'FreeContainer' === t.constructor.name && (i = s.indexOf(t)), 'Group' === t.constructor.name && (i = s.findIndex(e => e && e[0] && e[0].id === t.id));
          const n = s[i - 1];
          n && !g(n, 'Array') && (e = n), n && g(n, 'Array') && n[0] && (e = n[0])
        }
      }
      return e && (e = e.id), e
    }

    toJSON() {
      let t = {};
      const e = this._displayables[0];
      e instanceof Canvas && (t = e.toJSON()), this._findChildren(e, t);
      let s = null;
      return this.spr.whale && (s = this.spr.whale.getDef()), s && g(s, 'Array') && s.length > 0 && (t.dataIntergrationInfos = s), t
    }

    _findChildren(t, e) {
      this._displayables.forEach(s => {
        if ('FunctionLayer' !== s.id && s.parent === t) {
          let t = s.toJSON();
          e.children || (e.children = []), e.children.push(t), this._findChildren(s, t)
        }
      })
    }

    async fromJSON(t) {
      let e = t;
      if ('string' == typeof t) try {
        e = JSON.parse(t)
      } catch (t) {
        console.warn('场景定义文件被损坏造成无法正常读取')
      }
      g(e, 'Object') && 'Canvas' === e.type && (await this.spr.createCanvas(e.option), e.children && L(this.spr.canvas, e.children, !1));
      const s = e.dataIntergrationInfos;
      s && this.spr.whale && this.spr.whale.setDef(s)
    }

    _pubElementChange(t, e) {
      this.spr.eventbus.emit(t, { displayable: e })
    }

    set mouseOverElement(t) {
      this._mouseOverElement !== t && (this._mouseOverFlag || (this._mouseOverElement && (this._mouseOverFlag = !0, this._mouseOverElement.isMouseOver = !1), this._mouseOverElement = t, this._mouseOverFlag = !1, this._pubElementChange('mouseOverChange', t)))
    }

    get mouseOverElement() {
      return this._mouseOverElement
    }
  }

  class Text {
    constructor(t, e) {
      this.parent = t, this.opts = v({
        color: '#ffffff',
        fontSize: '20px',
        textAlign: 'left',
        boxSizing: 'border-box'
      }, e), this.data = null, this.dom = null
    }

    render() {
      this.dom || (this.dom = document.createElement('div'), this.parent && this.parent.appendChild(this.dom)), this._renderOpts(), this._renderData()
    }

    setOption(t = {}) {
      this.opts = v(this.opts, t)
    }

    setData(t) {
      g(t, 'String') && (this.data = t), g(t, 'Object') && Reflect.has(t, 'text') && (this.data = t.text)
    }

    getOption() {
      return this.opts
    }

    getConfig() {
    }

    getData() {
      return this.data
    }

    resize() {
    }

    destroy() {
      this.dom && this.parent.removeChild(this.dom), this.dom = null
    }

    _renderOpts() {
      if (!this.dom) return null;
      const t = M(this.opts);
      this.dom.style.cssText = t
    }

    _renderData() {
      this.dom.innerText = this.data
    }
  }

  class Adsorb {
    constructor(t) {
      this.parent = t, this.spr = t.spr, this.canvas = t.spr.canvas, this.adsorbDistance = 4, this.isAdsorbedX = !1, this.isAdsorbedY = !1, this.adsorbInfo = {
        target: null,
        adsorbMap: {}
      }, this.adsorbMovementX = 0, this.adsorbMovementY = 0, this.resizeAdsorbIndex = {}, this.resizeAdsorbMovement = [0, 0, 0, 0]
    }

    static factory(t) {
      return new Adsorb(t)
    }

    setAdsorbInfo(t = [], e, s) {
      t.forEach(t => {
        !t.opts.lock[s] && (t[s] += e)
      });
      const i = 'left' === s ? 'x' : 'y';
      this.canvas.mouseMoveInfo[i] += e, 'left' === s ? this.isAdsorbedX = !0 : this.isAdsorbedY = !0
    }

    adsorb() {
    }

    resetAdsorbMovement() {
      this.adsorbMovementX = 0, this.adsorbMovementY = 0, this.isAdsorbedX = !1, this.isAdsorbedY = !1, this.resizeAdsorbIndex = {}, this.resizeAdsorbMovement = [0, 0, 0, 0]
    }

    cancelAdsorb(t = {}) {
      'movementX' in t && 'movementY' in t && (this.isAdsorbedX && (this.adsorbMovementX += t.movementX, Math.abs(this.adsorbMovementX) > this.adsorbDistance && (this.adsorbMovementX = 0, this.isAdsorbedX = !1, this.resizeAdsorbIndex[2] = !1, this.resizeAdsorbIndex[3] = !1)), this.isAdsorbedY && (this.adsorbMovementY += t.movementY, Math.abs(this.adsorbMovementY) > this.adsorbDistance && (this.adsorbMovementY = 0, this.isAdsorbedY = !1, this.resizeAdsorbIndex[0] = !1, this.resizeAdsorbIndex[1] = !1)))
    }

    cancelResizeAdsorb(t = {}) {
      const { event: e, ctx: s } = t, i = s.index;
      s.handlerFnArr[i].forEach(t => {
        this.resizeAdsorbIndex[t] && (0 !== t && 1 !== t || (this.resizeAdsorbMovement[t] += e.movementY, Math.abs(this.resizeAdsorbMovement[t]) > this.adsorbDistance && (this.resizeAdsorbIndex[t] = !1, this.resizeAdsorbMovement[t] = 0)), 2 !== t && 3 !== t || (this.resizeAdsorbMovement[t] += e.movementX, Math.abs(this.resizeAdsorbMovement[t]) > this.adsorbDistance && (this.resizeAdsorbIndex[t] = !1, this.resizeAdsorbMovement[t] = 0)))
      })
    }

    destroy() {
      this.parent = null, this.spr = null, this.canvas = null, this.adsorbDistance = null, this.isAdsorbedX = null, this.isAdsorbedY = null, this.adsorbMovementX = null, this.adsorbMovementY = null, this.resizeAdsorbIndex = null, this.resizeAdsorbMovement = null, this.adsorbInfo = null
    }
  }

  class AlignmentLine {
    constructor(t, e) {
      this.spr = t._spr, this.lines = this._setLines(e)
    }

    static factory(t, e) {
      return new AlignmentLine(t, e)
    }

    _setLines(t) {
      if (!t) return [];
      const { left: e, top: s, height: i, width: n } = t;
      return {
        v: [{ type: 'vl', pos: e, start: s, end: s + i, displayable: t }, {
          type: 'vm',
          pos: e + n / 2,
          start: s,
          end: s + i,
          displayable: t
        }, { type: 'vr', pos: e + n, start: s, end: s + i, displayable: t }],
        h: [{ type: 'ht', pos: s, start: e, end: e + n, displayable: t }, {
          type: 'hm',
          pos: s + i / 2,
          start: e,
          end: e + n,
          displayable: t
        }, { type: 'hb', pos: s + i, start: e, end: e + n, displayable: t }]
      }
    }

    updateAlimentLines(t = {}, e) {
      let s = 'FreeContainer' === t.constructor.name ? t : { ...t };
      e && (s = Object.assign(e, s)), this.lines = this._setLines(s)
    }

    getShowLines(t = []) {
      const e = t.sort((t, e) => t.val - e.val), s = [];
      return e.forEach((t, e) => {
        0 !== e && 0 !== t.val || s.push(t)
      }), s
    }

    calcNearLine(t = {}) {
      if (!this.lines.v || !this.lines.h) return [];
      const e = [...this.lines.v, ...this.lines.h], s = { v: [], h: [] };
      e.forEach(e => {
        if (e.type.includes('v')) {
          const i = this.findLine(e, t.v);
          i && s.v.push({ val: Math.abs(Math.round(i.pos) - Math.round(e.pos)), from: e, ...i })
        } else {
          const i = this.findLine(e, t.h);
          i && s.h.push({ val: Math.abs(Math.round(i.pos) - Math.round(e.pos)), from: e, ...i })
        }
      });
      return {
        vLines: this.getShowLines(s.v) || [],
        hLines: this.getShowLines(s.h) || [],
        vLinesAll: s.v || [],
        hLinesAll: s.h || []
      }
    }

    findLine(t = {}, e = []) {
      if (e.length <= 0) return;
      let s = 0, i = e.length - 1;
      for (; s <= i;) {
        let n = Math.round(i - (i - s) / 2);
        if (Math.round(t.pos) < Math.round(e[n].pos)) i = n - 1; else {
          if (!(Math.round(t.pos) > Math.round(e[n].pos))) return e[n];
          s = n + 1
        }
      }
      if (s === i) return e[s];
      if (s > i) {
        if (s >= e.length) return e[i];
        if (i < 0) return e[0];
        return Math.abs(Math.round(e[i].pos) - Math.round(t.pos)) < Math.abs(Math.round(e[s].pos) - Math.round(t.pos)) ? e[i] : e[s]
      }
    }
  }

  class DistanceTip {
    constructor(t) {
      this.parent = t, this.spr = t.spr, this.left = [], this.right = [], this.top = [], this.bottom = [], this.compareLines = this._compareLines()
    }

    static factory(t) {
      return new DistanceTip(t)
    }

    setLines(t = []) {
      const e = { ht: 0, hm: 1, hb: 2 }, s = { vl: 0, vm: 1, vr: 2 };
      t.forEach(t => {
        const i = t.from.type;
        i.includes('v') ? (t.start < t.from.start && (this.top[s[i]] = this.setDistanceItem({
          target: this.top[s[i]],
          line: t,
          index: 0
        })), t.end > t.from.end && (this.bottom[s[i]] = this.setDistanceItem({
          target: this.bottom[s[i]],
          line: t,
          index: 1
        }))) : (t.start < t.from.start && (this.left[e[i]] = this.setDistanceItem({
          target: this.left[e[i]],
          line: t,
          index: 2
        })), t.end > t.from.end && (this.right[e[i]] = this.setDistanceItem({
          target: this.right[e[i]],
          line: t,
          index: 3
        })))
      })
    }

    showLines(t = {}) {
      const e = this.spr && this.spr.functionLayer && this.spr.functionLayer.distanceLineElement || [],
        s = [this.top, this.bottom, this.left, this.right];
      e.forEach((t, e) => {
        t.resetStyle();
        const i = this.getLine(s[e], e);
        t.show.get(e)(i)
      })
    }

    getLine(t, e) {
      t.forEach(t => {
        t.distance = Math.round(Math.abs(this.compareLines.get(e)(t)))
      });
      return t.sort((t, e) => t.distance - e.distance)[0]
    }

    _compareLines() {
      const t = new Map;
      return t.set(0, t => t.end >= t.from.start ? t.from.start - t.start : t.from.start - t.end), t.set(1, t => t.start <= t.from.end ? t.from.end - t.end : t.from.end - t.start), t.set(2, t => t.end >= t.from.start ? t.from.start - t.start : t.from.start - t.end), t.set(3, t => t.start <= t.from.end ? t.from.end - t.end : t.from.end - t.start), t
    }

    setDistanceItem(t = {}) {
      const { target: e, index: s, line: i } = t;
      return e && Math.abs(this.compareLines.get(s)(e)) <= Math.abs(this.compareLines.get(s)(i)) ? e : i
    }

    init() {
      this.left = [], this.right = [], this.top = [], this.bottom = []
    }
  }

  class AlignmentLineStorage {
    constructor(t) {
      this.spr = t, this.canvas = null, this.alimentLines = {
        v: [],
        h: []
      }, this.alimentLineMap = {}, this.updated = !1, this.functionLayer = this.spr && this.spr.functionLayer || {}, this.selectBoundRect = null, this.line = null, this.selectedContainers = [], this.adsorb = Adsorb.factory(this), this.distanceTip = DistanceTip.factory(this), this.distanceLineElement = this.functionLayer && this.functionLayer.distanceLineElement || [], this.alignmentLineElement = this.functionLayer && this.spr.functionLayer.alignmentLineElement || [], this.spr.eventbus.on('selectChange', this.resetAlimentLinesStore, this), this.spr.eventbus.on('containerMove', t => this.updateAlimentLines(t, 'move'), this), this.spr.eventbus.on('containerMoveEnd', this.hiddenAlimentLines, this), this.spr.eventbus.on('resizeHandlerMove', t => this.updateAlimentLines(t, 'resize'), this), this.spr.eventbus.on('resizeHandlerMoveEnd', this.hiddenAlimentLines, this)
    }

    static factory(t) {
      return new AlignmentLineStorage(t)
    }

    init() {
      return this.canvas = this.spr.canvas, this
    }

    addLine(t = {}, e = {}) {
      e && (this.updated = !1, this.alimentLineMap[t.id] = e)
    }

    removeLine(t = {}) {
      const { id: e } = t;
      e && (this.updated = !1, t.id in this.alimentLineMap && delete this.alimentLineMap[t.id])
    }

    destroy() {
      this.canvas = null, this.alimentLines = null, this.alimentLineMap = null, this.updated = null, this.distanceLineElement = null, this.functionLayer = null, this.alignmentLineElement = null, this.spr.eventbus.off('selectChange', this.resetAlimentLinesStore, this), this.spr.eventbus.off('containerMove', this.updateAlimentLines, this), this.spr.eventbus.off('resizeHandlerMove', this.updateAlimentLines, this), this.spr.eventbus.off('containerMoveEnd', this.hiddenAlimentLines, this), this.spr.eventbus.off('resizeHandlerMoveEnd', this.hiddenAlimentLines, this), this.spr = null
    }

    getSelectedContainer() {
      return this.spr.selector.getSelectFreeContainers()
    }

    getSelectedContainerIds(t = []) {
      return t.map(t => t.id)
    }

    resetAlimentLinesStore(t = {}) {
      if (this.selectBoundRect = this.spr.selector.getSelectBoundRect(), this.line = AlignmentLine.factory(this.spr, this.selectBoundRect), this.selectedContainers = this.getSelectedContainer(), this.selectedContainers.length <= 0) return;
      const e = this.getSelectedContainerIds(this.selectedContainers), s = [];
      this.alimentLines = { v: [], h: [] };
      for (let t in this.alimentLineMap) e.find(e => e === t) || s.push(this.alimentLineMap[t]);
      s.forEach(t => {
        this.alimentLines.v = [...this.alimentLines.v, ...t.lines.v], this.alimentLines.h = [...this.alimentLines.h, ...t.lines.h]
      }), this.alimentLines.v = this.combineAlignmentLines(this.alimentLines.v), this.alimentLines.h = this.combineAlignmentLines(this.alimentLines.h), this.adsorb.resetAdsorbMovement(), this.updated = !0
    }

    combineAlignmentLines(t = []) {
      const e = {}, s = this;
      return t.forEach(t => {
        if (e[t.pos]) {
          const i = e[t.pos], n = [i.start, i.end, t.start, t.end].sort((t, e) => t - e);
          e[t.pos] = { ...t, start: n[0], end: n[3], isCombine: !0, before: [...s.getBefore(i), ...s.getBefore(t)] }
        } else e[t.pos] = t
      }), Object.values(e).sort((t, e) => t.pos - e.pos)
    }

    getBefore(t = {}) {
      const e = t.before;
      return !e || e.length < 1 ? [t] : [...e]
    }

    updateAlimentLines(t = {}, e = 'move') {
      if (!this.updated) return;
      if (!T().enableAlignmentLine) return void this.updateContainerAlignmentLines(this.selectedContainers);
      const { displayable: s, event: i, ctx: n } = t, r = this.line, o = this.spr.selector.getSelectBoundRect();
      if (!o) return;
      r.updateAlimentLines(o), this.updateContainerAlignmentLines(this.selectedContainers);
      const a = r.calcNearLine(this.alimentLines), h = this.showLine(a, o, i, e);
      'move' === e && i && ![37, 38, 39, 40].includes(i.keyCode) && (this.moveAdsorb(h), this.adsorb.cancelAdsorb(i)), 'resize' === e && (this.resizeAdsorb(h, n), this.adsorb.cancelResizeAdsorb({
        event: i,
        displayable: s,
        ctx: n
      })), this.showDistanceTips({ needAdsorbLines: h })
    }

    updateContainerAlignmentLines(t = []) {
      t.forEach(t => {
        t.alimentLines.updateAlimentLines(t)
      })
    }

    showLine(t = {}, e = {}, s = {}, i = 'move') {
      const n = this.spr.canvas.ratio;
      if (!Array.isArray(t.vLines) || !Array.isArray(t.hLines)) return [];
      t.vLines.length <= 0 && this.distanceLineElement[0].isShow && this.distanceLineElement[0].resetStyle(), t.hLines.length <= 0 && this.distanceLineElement[1].isShow && this.distanceLineElement[1].resetStyle();
      const r = [...t.vLines, ...t.hLines], o = [...t.vLinesAll, ...t.hLinesAll];
      let a = [];
      const h = [37, 38, 39, 40];
      return this.alignmentLineElement.forEach((t, l) => {
        const d = t.dom, c = 'move' === i ? r[l] : o[l];
        if (d.style = t.initStyle, !c || c.val > this.adsorb.adsorbDistance / n || 'resize' === i && c.from.type.includes('m') || s && h.includes(s.keyCode) && 0 !== c.val) return void (d.style.display = 'none');
        d.style.display = 'block';
        const p = [c.start, c.end, c.from.start, c.from.end].sort((t, e) => t - e);
        c.type.includes('v') ? (d.style.left = c.pos + ('vl' === c.from.type ? -1 : 0) + 'px', d.style.top = p[0] + 'px', d.style.transform = `scaleX(${ 1 / n })`, d.style.height = Math.abs(p[3] - p[0]) + 'px') : (d.style.top = c.pos + ('ht' === c.from.type ? -1 : 0) + 'px', d.style.left = p[0] + 'px', d.style.transform = `scaleY(${ 1 / n })`, d.style.width = Math.abs(p[3] - p[0]) + 'px'), a.push({
          displayable: e,
          line: c,
          event: s,
          ele: t
        })
      }), a
    }

    moveAdsorb(t = []) {
      t.forEach(t => {
        const { line: e } = t, s = e.pos - e.from.pos, i = this.adsorb;
        e.type.includes('v') ? i.setAdsorbInfo(this.selectedContainers, s, 'left') : i.setAdsorbInfo(this.selectedContainers, s, 'top')
      })
    }

    resizeAdsorb(t = [], e = {}) {
      if (!e.adsorbContainer) return;
      const s = this.adsorb, i = ['ht', 'hb', 'vl', 'vr'], n = e.handlerFnArr[e.index].map(t => i[t]);
      t.forEach(t => {
        const { line: r } = t, o = r.pos - r.from.pos;
        if (r.from && r.from.type && !r.from.type.includes('m')) {
          const t = i.indexOf(r.from.type);
          r.type.includes('v') && n.includes(r.from.type) && !s.resizeAdsorbIndex[t] && (s.resizeAdsorbIndex[t] = !0, e.adsorbContainer(o, 0)), r.type.includes('h') && n.includes(r.from.type) && !s.resizeAdsorbIndex[t] && (s.resizeAdsorbIndex[t] = !0, e.adsorbContainer(0, o))
        }
      })
    }

    showDistanceTips(t = {}) {
      const { needAdsorbLines: e, displayable: s } = t;
      let i = [];
      e.forEach(t => {
        const e = t.line;
        let s;
        if (e && e.before) {
          let t = {};
          e.before.forEach(i => {
            t = { ...i, from: { ...e.from } }, s = s ? [...s, t] : [t]
          })
        }
        i = s ? [...s, ...i] : [e, ...i]
      });
      const n = this.distanceTip;
      n.init(), n.setLines(i), n.showLines({ displayable: s })
    }

    getAdsorbStatus(t = 'left') {
      return 'left' === t ? this.adsorb.isAdsorbedX : this.adsorb.isAdsorbedY
    }

    hiddenAlimentLines() {
      if (!T().enableAlignmentLine) return;
      const t = this.adsorb;
      this.alignmentLineElement && this.alignmentLineElement.forEach(t => {
        t.resetStyle()
      }), this.distanceLineElement && this.distanceLineElement.forEach(t => {
        t.resetStyle()
      }), t.resetAdsorbMovement(), this.isAdsorbedX = !1, this.isAdsorbedY = !1
    }
  }

  class CommandManager {
    constructor(t) {
      this.spr = t, this.history = [null], this.position = 0, this.maximum = 100, this.commands = {
        [C.CREATEGROUP]: W,
        [C.SETOPT]: V,
        [C.MOVEDISPLAYABLE]: j,
        [C.REMOVE]: J,
        [C.CREATE]: $,
        [C.DUPLICATE]: Y
      }
    }

    static factory(t) {
      return this.instance || (this.instance = new CommandManager(t)), this.instance
    }

    setMaximum(t) {
      g(t, 'Number') && t !== this.maximum && (this.maximum = t)
    }

    doCommand(t, ...e) {
      if (this.position < this.history.length - 1 && this.position < this.maximum && (this.history = this.history.slice(0, this.position + 1)), this.commands[t]) {
        const s = this.commands[t](this.spr, e);
        if (s) return this.history.push(s), this.position += 1, s.execute()
      }
      return null
    }

    undo() {
      this.position > 0 && (this.history[this.position].undo(), this.position -= 1)
    }

    redo() {
      this.position < this.history.length - 1 && (this.position += 1, this.history[this.position].execute())
    }
  }

  const j = (t, e) => {
    const s = e[0], i = e[1], n = e[2], r = [], o = i.id, a = [];
    return s.forEach(e => {
      const s = { el: e.id, groupId: e.groupId, frontId: t.storage.getFrontIdByEl(e) };
      a.push(s), r.push(e.id)
    }), {
      execute() {
        const e = [];
        r.forEach(s => {
          const i = t.getElementById(s);
          i && e.push(i)
        });
        const s = t.getElementById(o);
        return e.length > 0 && s && t && t.storage.moveDisplayables(e, i, n), t.selector.select(e), e
      }, undo() {
        t.selector.clear();
        let e = [];
        return a.forEach(s => {
          let i = null, n = null;
          s.frontId ? (i = t.getElementById(s.frontId), n = t.getElementById(s.el), i && n && t.storage.moveDisplayable(n, i, 'behind')) : s.groupId ? (i = t.getElementById(s.groupId), n = t.getElementById(s.el), i && n && t.storage.moveDisplayable(n, i, 'infront')) : (n = t.getElementById(s.el), n && (i = n.parent.parent), i && n && t.storage.moveDisplayable(n, i, 'infront')), n && e.push(n)
        }), t.selector.select(e), e
      }
    }
  }, W = (t, e) => {
    const s = e[0], i = [], n = e[1];
    let r = null;
    const o = [];
    return g(s, 'Array') && s.forEach(e => {
      const s = { el: e.id, groupId: e.groupId, frontId: t.storage.getFrontIdByEl(e) };
      o.push(s), i.push(e.id)
    }), {
      execute() {
        let e = null;
        if (!g(s, 'Array')) return void console.warn('单个元素对象无法打组，目前只能为一组元素打组');
        let o = t.getElementById(i[0]);
        if (o) {
          const s = t.storage.findIndexAtParent(o);
          if (s >= 0) {
            const t = { name: n, order: s, groupId: o.groupId };
            r && (t.id = r), e = p('Group', o.parent, t)
          }
        }
        return e && e.add(i), r = e.id, t.selector.select(e), r
      }, undo() {
        t.selector.clear();
        let e = [];
        o.forEach(s => {
          let i = null, n = null;
          s.frontId ? (i = t.getElementById(s.frontId), n = t.getElementById(s.el), i && n && t.storage.moveDisplayable(n, i, 'behind')) : s.groupId ? (i = t.getElementById(s.groupId), n = t.getElementById(s.el), i && n && t.storage.moveDisplayable(n, i, 'infront')) : (n = t.getElementById(s.el), n && (i = n.parent.parent), i && n && t.storage.moveDisplayable(n, i, 'infront')), n && e.push(n)
        });
        const s = t.getElementById(r);
        return s && s.destroy(), t.selector.select(e), r
      }
    }
  }, V = (t, e) => {
    const s = e[0], i = e[1], n = JSON.parse(JSON.stringify(s));
    let r = null;
    return r = i ? JSON.parse(JSON.stringify(i)) : function (t, e) {
      const s = [];
      return t.forEach(t => {
        const i = function (t, e) {
          const s = { id: t.id, opts: {} }, i = t.opts, n = Object.keys(i), r = e.getElementById(t.id);
          r && n.forEach(t => {
            s.opts[t] = r.opts[t]
          });
          return s
        }(t, e);
        s.push(i)
      }), s
    }(n, t), { execute: () => (X(n, t), n), undo: () => (X(r, t), r) }
  }, J = (t, e) => {
    let s = [...e[0]], i = [], n = [];
    return g(s, 'Array') && s.forEach(t => {
      i.push(t.id)
    }), {
      async execute() {
        t.selector.clear(), n = function (t, e) {
          let s = [], i = [];
          if (!g(t, 'Array')) return;
          if (0 === t.length) return;
          return t.forEach(t => {
            const s = e.getElementById(t);
            s && i.push(s)
          }), i.sort((t, e) => t.order - e.order), i.forEach(t => {
            const i = t.getJSONWithChild(), n = t.parent, r = e.storage.getFrontIdByEl(t);
            s.push({ json: i, parent: n, fronter: r })
          }), s
        }(i, t);
        let e = [];
        i.forEach(s => {
          const i = t.getElementById(s);
          e.push(i)
        }), e.reverse();
        for (let t of e) t.destroy && await t.destroy();
        return i
      }, undo() {
        if (n) {
          const e = [];
          return n.forEach(s => {
            let i = null;
            s.parent && s.json && (i = s.parent.addChildrenFromJSON(s.json, !1));
            const n = t.getElementById(i), r = t.getElementById(s.fronter);
            if (n && r && t.storage.moveDisplayable(n, r, 'behind'), n && !r && 'Layer' !== n.constructor.name) if (n.groupId) {
              const e = t.getElementById(n.groupId);
              t.storage.moveDisplayable(n, e, 'infront')
            } else {
              const e = n.parent.parent;
              t.storage.moveDisplayable(n, e, 'infront')
            }
            n && e.push(n)
          }), t.selector.select(e), s = [...e], i
        }
        return null
      }
    }
  };
  const $ = (t, e) => {
    let s = null, i = null, n = null;
    const r = e[0];
    if (!r) return;
    const o = r.parent, a = r.type, h = r.opts, l = r.fronter, d = !g(r.isSelected, 'Boolean') || r.isSelected,
      c = r.opts.adapter;
    return {
      execute() {
        if (o && a && h) {
          if (i && (h.id = i), s = p(a, o, h), !i && (i = s.id), 'Layer' === a) {
            let t = !1;
            if (c && Reflect.has(c, 'type') && 'ThingJSAdapter' === c.type && (t = !0), !t) {
              let t = {};
              n && (t.id = n);
              const e = p('Free', s, t);
              !n && (n = e.id)
            }
          }
          if (l) {
            const e = l[0], i = l[1] || 'behind', n = t.getElementById(e);
            n && i && t.storage.moveDisplayable(s, n, i)
          }
          return d && t.selector.select(s), i
        }
      }, undo() {
        if (i) {
          const e = t.getElementById(i);
          e && e.destroy && e.destroy()
        }
      }
    }
  }, Y = (t, e) => {
    const s = e[0];
    let i = e[1], n = [], r = [], o = null;
    return g(s, 'Array') && (o = s[s.length - 1].id, s.sort((t, e) => t.order - e.order), s.forEach(t => {
      const e = t.id;
      e && n.push(e)
    })), i && (o = i.id), {
      execute() {
        n.length > 0 && (r = [], n.forEach(e => {
          const s = function (t, e) {
            const s = e.getElementById(t);
            let i = null;
            s && s.duplicate && (i = s.duplicate());
            return i
          }(e, t);
          s && r.push(s)
        }));
        const e = function (t, e, s = null) {
          let i = [];
          s && t.forEach((n, r) => {
            const o = e.getElementById(n);
            let a = null;
            a = 0 === r ? e.getElementById(s) : e.getElementById(t[r - 1]), a && e.storage.moveDisplayable(o, a, 'behind'), o && i.push(o)
          });
          return i
        }(r, t, o);
        return t.selector.select(e), r
      }, undo: () => r ? (r.forEach(e => {
        const s = t.getElementById(e);
        s && s.destroy && s.destroy()
      }), r) : null
    }
  };

  function X(t, e) {
    g(t, 'Array') ? t.forEach(t => {
      K(t, e)
    }) : K(t, e)
  }

  function K(t, e) {
    const s = t.id, i = t.opts, n = e.getElementById(s);
    if (n) {
      Object.keys(i).forEach(t => {
        if ('style' !== t && 'lock' !== t && (n[t] = i[t]), 'style' === t) {
          Object.keys(i.style).forEach(t => {
            n.style[t] = i.style[t]
          })
        }
        if ('lock' === t) if ('Group' === n.constructor.name) {
          n.getAllElsInGroups().forEach(t => {
            t.setLockStatusByObject && t.setLockStatusByObject(i.lock)
          })
        } else n.setLockStatusByObject && n.setLockStatusByObject(i.lock)
      });
      const t = { top: n.top, left: n.left, height: n.height, width: n.width };
      'FreeContainer' === n.constructor.name && n.alimentLines && n.alimentLines.updateAlimentLines && n.alimentLines.updateAlimentLines(i, t)
    }
    e.selector.showBoundRect()
  }

  const Q = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAAXNSR0IArs4c6QAAAERlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAA6ABAAMAAAABAAEAAKACAAQAAAABAAAAIKADAAQAAAABAAAAIAAAAACshmLzAAAAhElEQVRYCe2WQQ7AIAgES9O38ig+257ogaQuxDR7WS/GiLgMopq738eiRYQtpuEU8n9CDz8bWCrcjXSqM/elE5AAEYA1nqd1esrTHlUXPQVXKkU9iqSu75KjE5AAERABERCB9lvQvdvrm4DG9BToV0xPgQTQCbxV8FWv079g9YPuDzqBB5fnIzU9m9lWAAAAAElFTkSuQmCC',
    U = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAAXNSR0IArs4c6QAAAERlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAA6ABAAMAAAABAAEAAKACAAQAAAABAAAAIKADAAQAAAABAAAAIAAAAACshmLzAAAAiUlEQVRYCe2VQQ7AIAgES9O3+ig+28Ym23AhUUncHtYLHFDWQcFaa/dBXCcx95v6ggB3N/g7LMjTCUhAiUCvI2q5+m5KAlaTxn0SIAIiQCfwDaP4N7s/02BGYrNh918CmeJICjcfiY37ok8nIAEiIAJ0Amkrjs0i8ysNCGfSCUiAYaCgJrstvQQPuNYa2g9vFhwAAAAASUVORK5CYII=',
    Z = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAAXNSR0IArs4c6QAAAERlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAA6ABAAMAAAABAAEAAKACAAQAAAABAAAAIKADAAQAAAABAAAAIAAAAACshmLzAAAAaklEQVRYCe3VMQrAIBBE0WzIWfdQe9kEAmshTCOSSfFt1AVxeM1EZt6HcZ3Gv9+vrw5QVdHnL/aWtwsQAAEEEEDALjDKaC6gLot5vnpXZfdfAZV4VUC9swsQAAEEEEDALhC7a1eVjprbBR73VA52QhaevQAAAABJRU5ErkJggg==',
    q = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAAXNSR0IArs4c6QAAAERlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAA6ABAAMAAAABAAEAAKACAAQAAAABAAAAIKADAAQAAAABAAAAIAAAAACshmLzAAABY0lEQVRYCWNMT0//yDCAgOX///98A2g/AwvM8lmzZjHC2PSg09LS/oPsYaKHZfjsGHXAaAgMeAjAsyG+lIpPrrCwUOjbt2866GqA5ctFYNYmWMhRHAKWlpYgS7KAFh5ExoyMjProjsLGp9gBYWFhfyUlJWOAhq/FZgEhMYodALLg7du3gkBKjZBl2OQpdkBubq7or1+/9gEN1wXi68CgX4PNIlxiFDkAZjkw7nWAFl/j5OR0dHZ2jgBatgKXhejiZDsA3XIODg6niRMnvgSlCRcXlxguLq4r6JZh45OVDdEtB/reEWj5K5gFIEcA2e9gfHw0WSEAjPO5oGAHGnwVZPmMGTPgluOzDJscCzntAKDlOUCLGYA4hRLLQQ6iayMEOQRGGySw0GCBBQVMABdNTlrBZRayOFm5ANkAStnwcgCXD4kNIXIdMuAhMOqA0RCA5wJSUztQfScw5ZeRm/ph+gY8CgDI6n5CGMkLsQAAAABJRU5ErkJggg==';

  class ZoomBar {
    constructor(t) {
      this.parent = t, this._spr = t._spr, this.root = this.parent.dom, this.dom = null, this.textDom = null, this._barList = [], this.init()
    }

    static factory(t) {
      return new ZoomBar(t)
    }

    init() {
      this.dom = b(), this.dom.style.cssText = 'display: flex; flex-direction: row-reverse; align-items: center; padding-right: 20px; margin-bottom: 20px; pointer-events: all; flex: 1; height: 40px; order: -1;transition: margin-bottom 0.25s linear 0s;', this.root.appendChild(this.dom), this.createBarItem({
        width: 20,
        height: 20,
        backgroundImage: q,
        backgroundSize: [16, 16]
      }, '播放', this._playEvent), this.createBarItem({
        width: 20,
        height: 20,
        backgroundImage: U,
        backgroundSize: [16, 16]
      }, '放大', this._zoomIn), this.textDom = this.createBarItem({
        width: 40,
        height: 20,
        lineHeight: 20
      }, null, this._refreshEvent), this.createBarItem({
        width: 20,
        height: 20,
        backgroundImage: Z,
        backgroundSize: [16, 16]
      }, '缩小', this._zoomOut), this.createBarItem({
        width: 20,
        height: 20,
        backgroundImage: Q,
        backgroundSize: [16, 16]
      }, '画布居中', this._focusing), this.ratioText = this._spr.canvas.ratio
    }

    createBarItem(t, e, s = null) {
      const i = t.backgroundSize, n = t.lineHeight, r = b();
      let o = null,
        a = `width: ${ t.width || 20 }px; height: ${ t.height || 20 }px; ${ n ? `line-height: ${ n }px;` : '' } text-align: center; margin: 0 5px; font-size: 12px; color: #707070; cursor: pointer;`;
      return e && r.setAttribute('title', e), t.backgroundImage && (a += `background: url(${ t.backgroundImage }) no-repeat center center/${ i ? `${ i[0] }px ${ i[1] }px` : '100% 100%' }`), r.style.cssText = a, g(s, 'Function') && (o = s.bind(this), r.addEventListener('click', o)), this._barList.push({
        dom: r,
        clickEvent: o
      }), this.dom.appendChild(r), r
    }

    _zoomIn() {
      'play' !== T().canvasMode && (this._spr.canvas.ratio = this._spr.canvas.ratio + .1 > 4 ? 4 : this._spr.canvas.ratio + .1)
    }

    _zoomOut() {
      'play' !== T().canvasMode && (this._spr.canvas.ratio = this._spr.canvas.ratio - .1 < .04 ? .04 : this._spr.canvas.ratio - .1)
    }

    _focusing() {
      'play' !== T().canvasMode && (this._spr.canvas.zoomCanvasToCenter(), this._spr.eventbus.emit('canvasFocusing'))
    }

    _refreshEvent() {
      'play' !== T().canvasMode && (this._spr.canvas.ratio = 1)
    }

    _playEvent() {
      R('canvasMode', 'play')
    }

    show() {
      this.dom.style.marginBottom = '20px'
    }

    hidden() {
      this.dom.style.marginBottom = '-30px'
    }

    destroy() {
      return this._barList.forEach(t => {
        t.clickEvent && t.dom.removeEventListener('click', t.clickEvent), t.dom && this.dom.removeChild(t.dom)
      }), this._barList = null, this.root.removeChild(this.dom), this.parent = null, this._spr = null, this.root = null, this.dom = null, !0
    }

    set ratioText(t) {
      this.textDom.innerText = (100 * t).toFixed(0) + '%'
    }

    get ratioText() {
      return this._spr.canvas.ratio
    }
  }

  class ExtendManage {
    constructor(t) {
      this._spr = t, this.root = this._spr.root, this.dom = null, this.zoomBar = null, this.inited = !1, this._spr.eventbus.on('configChange', this.changeExtend, this)
    }

    static factory(t) {
      return new ExtendManage(t)
    }

    init() {
      this.dom = b('div'), this.dom.setAttribute('data-name', 'extend'), this.dom.style.cssText = 'position: absolute; display: flex; align-items: flex-end; top: 0; left: 0; width: 100%; height: 100%; overflow: hidden; pointer-events: none;', this.root.appendChild(this.dom), 'matrix' === T().canvasMode && T().zoomBar && (this.zoomBar = ZoomBar.factory(this)), this.inited = !0
    }

    destroy() {
      return this.zoomBar && this.zoomBar.destroy(), this.root.removeChild(this.dom), this._spr.eventbus.off('configChange', this.changeExtend, this), this._spr = null, this.root = null, this.dom = null, this.zoomBar = null, !0
    }

    changeExtend(t) {
      'zoomBar' === t.key && (t.value ? !this.zoomBar && (this.zoomBar = this.zoomBar = ZoomBar.factory(this)) : (this.zoomBar && this.zoomBar.destroy(), this.zoomBar = null)), 'canvasMode' === t.key && ('matrix' === t.value && this.zoomBar && this.zoomBar.show(), 'play' === t.value && this.zoomBar && this.zoomBar.hidden())
    }
  }

  class AlignmentLineElement {
    constructor(t, e) {
      this.parent = t, this.spr = t.spr, this.oprLayer = t.oprLayer, this.index = e, this.dom = null, this.realWidth = 1, this.realHeight = 1, this.isAdsorbed = !1, this.adsorbMovement = 0, this.initStyle = `position:absolute;display:none;top:0px;left:0px;pointer-events:all;\n\t\t\t\t\t\twidth:${ this.realWidth }px;height:${ this.realHeight }px;z-index:10;\n\t\t\t\t\t\tbackground-color:#ff3366;`, this.init()
    }

    init() {
      this.dom = b(), this.dom.style = this.initStyle, this.oprLayer.dom.appendChild(this.dom)
    }

    resetStyle() {
      this.dom.style = this.initStyle
    }
  }

  class DistanceLine {
    constructor(t, e) {
      this.parent = t, this.spr = t.spr, this.oprLayer = t.oprLayer, this.dom = null, this.toolTipDom = null, this.index = e, this.isShow = !1, this.realWidth = 1, this.realHeight = 1, this.toolTipWidth = 40, this.toolTipHeight = 20, this.sideWidth = 2, this.sideHeight = 2, this.sideShowSize = 8, this.show = this._show(), this.initStyle = `position:absolute;display:none;top:0px;left:0px;pointer-events:all;\n            width:${ this.realWidth }px;height:${ this.realHeight }px;z-index:20;\n            background-color:#CCFF99;`, this.toolTipInitStyle = `display:block;position:absolute;top:0px;left:0px;pointer-events:all;\n            width:${ this.toolTipWidth }px;height:${ this.toolTipHeight }px;background-color:#CCFF99;\n\t\t\t\t\t\tcolor:#333;line-height:${ this.toolTipHeight }px;text-align:center`, this.leftSideInitStyle = `display:block;position:absolute;top:0px;left:0px;width:${ this.sideWidth }px;\n\t\t\t\t\t\theight:${ this.sideHeight }px;background-color:#CCFF99;`, this.rightSideInitStyle = `display:block;position:absolute;top:0px;left:0px;width:${ this.sideWidth }px;\n\t\t\t\t\t\theight:${ this.sideHeight }px;background-color:#CCFF99;`, this.init()
    }

    init() {
      this.dom = b(), this.toolTipDom = b(), this.leftSide = b(), this.rightSide = b(), this.dom.style = this.initStyle, this.toolTipDom.style = this.toolTipInitStyle, this.leftSide.style = this.leftSideInitStyle, this.rightSide.style = this.rightSideInitStyle, this.dom.appendChild(this.toolTipDom), this.dom.appendChild(this.leftSide), this.dom.appendChild(this.rightSide), this.oprLayer.dom.appendChild(this.dom)
    }

    resetStyle() {
      this.dom.style = this.initStyle, this.toolTipDom.style = this.toolTipInitStyle, this.leftSide.style = this.leftSideInitStyle, this.rightSide.style = this.rightSideInitStyle, this.isShow = !1
    }

    _show() {
      const t = new Map;
      return t.set(0, t => {
        if (!t) return;
        const e = this.spr.canvas.ratio;
        this.isShow = !0, this.dom.style.display = 'block', this.dom.style.left = t.pos + ('vl' === t.from.type ? -1 : 0) + 'px', this.dom.style.top = t.from.start - t.distance + 'px', this.dom.style.height = t.distance + 'px', this.toolTipDom.style.top = t.distance / 2 - 10 + 'px', this.toolTipDom.innerText = t.distance, this.leftSide.style.width = this.sideShowSize / e + 'px', this.leftSide.style.transform = 'translate(-50%, 0)', this.rightSide.style.width = this.sideShowSize / e + 'px', this.rightSide.style.transform = `translate(-50%, ${ t.distance - this.sideHeight }px)`
      }), t.set(1, t => {
        if (!t) return;
        const e = this.spr.canvas.ratio;
        this.isShow = !0, this.dom.style.display = 'block', this.dom.style.left = t.pos + ('vl' === t.from.type ? -1 : 0) + 'px', this.dom.style.top = t.from.end + 'px', this.dom.style.height = t.distance + 'px', this.toolTipDom.style.top = t.distance / 2 - 10 + 'px', this.toolTipDom.innerText = t.distance, this.leftSide.style.width = this.sideShowSize / e + 'px', this.leftSide.style.transform = 'translate(-50%, 0)', this.rightSide.style.width = this.sideShowSize / e + 'px', this.rightSide.style.transform = `translate(-50%, ${ t.distance - this.sideHeight }px)`
      }), t.set(2, t => {
        if (!t) return;
        const e = this.spr.canvas.ratio;
        this.isShow = !0, this.dom.style.display = 'block', this.dom.style.left = t.from.start - t.distance + 'px', this.dom.style.top = t.pos + ('ht' === t.from.type ? -1 : 0) + 'px', this.dom.style.width = t.distance + 'px', this.toolTipDom.style.left = t.distance / 2 - 20 + 'px', this.toolTipDom.innerText = t.distance, this.leftSide.style.height = this.sideShowSize / e + 'px', this.leftSide.style.transform = 'translate(0, -50%)', this.rightSide.style.height = this.sideShowSize / e + 'px', this.rightSide.style.transform = `translate(${ t.distance - this.sideWidth }px, -50%)`
      }), t.set(3, t => {
        if (!t) return;
        const e = this.spr.canvas.ratio;
        this.isShow = !0, this.dom.style.display = 'block', this.dom.style.left = t.from.end + 'px', this.dom.style.top = t.pos + ('ht' === t.from.type ? -1 : 0) + 'px', this.dom.style.width = t.distance + 'px', this.toolTipDom.style.left = t.distance / 2 - 20 + 'px', this.toolTipDom.innerText = t.distance, this.leftSide.style.height = this.sideShowSize / e + 'px', this.leftSide.style.transform = 'translate(0, -50%)', this.rightSide.style.height = this.sideShowSize / e + 'px', this.rightSide.style.transform = `translate(${ t.distance - this.sideWidth }px, -50%)`
      }), t
    }
  }

  class FunctionLayer {
    constructor(t) {
      this.spr = t, this.oprLayer = null, this.resizeHandler = [], this.alignmentLineElement = [], this.distanceLineElement = [], this.isInit = !1, this.selectedDisplayable = null, this.boundRect = null
    }

    static factory(t) {
      return this.instance || (this.instance = new FunctionLayer(t)), this.instance
    }

    init() {
      if (!this.isInit) {
        this.oprLayer = this.spr.createLayer({
          id: 'FunctionLayer',
          name: 'FunctionLayer',
          order: 9999
        }), this.boundRect = new BoundRect(this), this.spr.selector.setBoundRect(this.boundRect), this.resizeHandler = [];
        for (let t = 0; t < 8; t++) this.resizeHandler.push(new ResizeHandler(this, t));
        this.alignmentLineElement = [];
        for (let t = 0; t < 6; t++) this.alignmentLineElement.push(new AlignmentLineElement(this, t));
        this.distanceLineElement = [];
        for (let t = 0; t < 4; t++) this.distanceLineElement.push(new DistanceLine(this, t));
        this.isInit = !0
      }
    }

    contain(t, e) {
      return this.resizeHandler.filter(s => s.contain(t, e))[0] || null
    }

    resetResizeHandler() {
      const t = this.spr.selector.getSelectElements(), e = this.spr.selector.getSelectBoundRect();
      t && t.length > 0 ? this.resizeHandler.forEach((t, s) => {
        let i = 0, n = 0;
        switch (s) {
          case 0:
            n = e.top, i = e.left + e.width / 2;
            break;
          case 1:
            n = e.bottom, i = e.left + e.width / 2;
            break;
          case 2:
            n = e.top + e.height / 2, i = e.left;
            break;
          case 3:
            n = e.top + e.height / 2, i = e.right;
            break;
          case 4:
            n = e.top, i = e.left;
            break;
          case 5:
            n = e.top, i = e.right;
            break;
          case 6:
            n = e.bottom, i = e.left;
            break;
          case 7:
            n = e.bottom, i = e.right
        }
        t.show(i, n), 3 === s && t.resetSizeText(`${ Math.round(e.width) } × ${ Math.round(e.height) }`)
      }) : this.hiddenResizeHandler()
    }

    hiddenResizeHandler() {
      this.resizeHandler.forEach(t => {
        t.hidden()
      })
    }

    destroy() {
      this.resizeHandler.forEach(t => {
        t.destroy()
      }), this.boundRect.destroy(), this.spr = null, this.oprLayer = null, this.resizeHandler = null, this.alignmentLineElement = null, this.distanceLineElement = null, this.isInit = !1, this.selectedDisplayable = null, this.boundRect = null, FunctionLayer.instance = null
    }
  }

  class ResizeHandler {
    constructor(t, e) {
      this.parent = t, this.spr = t.spr, this.canvas = this.spr.canvas, this.oprLayer = t.oprLayer, this.index = e, this.isShow = !1, this.dom = null, this.sizeDom = null, this.realWidth = 10, this.handlerFnArr = [[0], [1], [2], [3], [0, 2], [0, 3], [1, 2], [1, 3]], this.fnMaps = this._fnMaps(), this.initStyle = `width:${ this.realWidth }px;height:${ this.realWidth }px;border-radius:${ this.realWidth / 2 }px;background-color:#007AFF;\n    transform:scale(${ 1 / this.spr.canvas.ratio });position:absolute;display:none;top:0px;left:0px;pointer-events:all`, this.sizeStyle = null, this.init()
    }

    init() {
      this.dom = b(), this.dom.style = this.initStyle, this.oprLayer.dom.appendChild(this.dom), this.initCursor(), 3 === this.index && this.initSizeBlock(), this.spr.eventbus.on('zoomCanvas', this.resizeHandler, this)
    }

    initSizeBlock() {
      this.sizeStyle = `padding: 0 4px;line-height:20px;background-color:#007AFF;color:#ffffff;transform-origin:left;border-radius:2px;\n    transform:scale(${ 1 / this.spr.canvas.ratio });position:absolute;display:none;top:0px;left:0px;font-size:12px;user-select:none`, this.sizeDom = b(), this.sizeDom.style = this.sizeStyle, this.oprLayer.dom.appendChild(this.sizeDom)
    }

    initCursor() {
      this.dom.style.cursor = ['n-resize', 's-resize', 'w-resize', 'e-resize', 'nw-resize', 'ne-resize', 'sw-resize', 'se-resize'][this.index]
    }

    resizeHandler(t) {
      this.isShow && (this.dom.style.transform = `scale(${ 1 / t.ratio })`, this.sizeDom && (this.sizeDom.style.transform = `scale(${ 1 / t.ratio })`))
    }

    resetSizeText(t) {
      this.sizeDom && (this.sizeDom.innerText = t)
    }

    contain(t, e) {
      const s = this.dom.getBoundingClientRect();
      return t > s.left && t < s.right && e > s.top && e < s.bottom && this
    }

    show(t, e) {
      this.dom.style.display = 'block', this.dom.style.left = t - this.realWidth / 2 + 'px', this.dom.style.top = e - this.realWidth / 2 + 'px', this.sizeDom && (this.sizeDom.style.display = 'inline-block', 3 === this.index && (this.sizeDom.style.left = t + 15 + 'px', this.sizeDom.style.top = e - 10 + 'px')), this.isShow = !0, this.resizeHandler(this.canvas)
    }

    hidden() {
      this.isShow && (this.dom.style.display = 'none', this.dom.style.left = '0px', this.dom.style.top = '0px', this.sizeDom && (this.sizeDom.style.display = 'none', this.sizeDom.style.left = '0px', this.sizeDom.style.top = '0px'), this.isShow = !1)
    }

    moveHandler(t) {
      let e = this.canvas.mouseMoveInfo;
      const s = this.spr.selector.getSelectElements(), i = this.handlerFnArr, n = this.fnMaps;
      i[this.index].forEach(t => {
        this.spr.alignmentLineStorage && this.spr.alignmentLineStorage.adsorb && this.spr.alignmentLineStorage.adsorb.resizeAdsorbIndex && this.spr.alignmentLineStorage.adsorb.resizeAdsorbIndex[t] || s.forEach(s => {
          if ('FreeContainer' === s.constructor.name && n.get(t)(s, e), 'Group' === s.constructor.name) {
            const i = s.getAllElsInGroups();
            g(i, 'Array') && i.forEach(s => {
              n.get(t)(s, e)
            })
          }
        })
      });
      const r = this.spr.selector.getSelectBoundRect();
      this.parent.boundRect.show(r), this.spr.eventbus.emit('resizeHandlerMove', { event: t, ctx: this })
    }

    adsorbContainer(t, e) {
      const s = this.canvas.mouseMoveInfo;
      s.x += t, s.y += e;
      const i = this.spr.selector.getSelectFreeContainers() || [], n = this.handlerFnArr, r = this.fnMaps;
      n[this.index].forEach(t => {
        i.forEach(e => r.get(t)(e, s))
      }), this.parent.resetResizeHandler(), i.forEach(t => t.adapter && t.adapter.resize())
    }

    _fnMaps() {
      const t = new Map;
      return t.set(0, (function (t, e) {
        const s = t.oldOptsRecord, i = Math.floor(s.height - e.y);
        !t.opts.lock.height && i > -1 && (t.height = i, t.top = Math.floor(s.top + e.y))
      })), t.set(1, (function (t, e) {
        const s = t.oldOptsRecord, i = Math.floor(s.height + e.y);
        !t.opts.lock.height && i > -1 && (t.height = i)
      })), t.set(2, (function (t, e) {
        const s = t.oldOptsRecord, i = Math.floor(s.width - e.x);
        !t.opts.lock.width && i > -1 && (t.width = i, t.left = Math.floor(s.left + e.x))
      })), t.set(3, (function (t, e) {
        const s = t.oldOptsRecord, i = Math.floor(s.width + e.x);
        !t.opts.lock.width && i > -1 && (t.width = i)
      })), t
    }

    destroy() {
      this.spr.eventbus.off('zoomCanvas', this.resizeHandler, this), this.parent = null, this.spr = null, this.canvas = null, this.oprLayer = null, this.index = null, this.isShow = null, this.dom = null, this.sizeDom = null, this.realWidth = null, this.handlerFnArr = null, this.fnMaps = null
    }
  }

  class BoundRect {
    constructor(t) {
      this.parent = t, this.oprLayer = t.oprLayer, this.spr = t.spr, this.canvas = this.spr.canvas, this.dom = null, this.isShow = !1, this.initStyle = 'width:0px;height:0px;position:absolute;display:none;top:0px;left:0px;pointer-events:none;', this.init()
    }

    init() {
      this.dom = b(), this.dom.dataset.id = 'boundrect', this.dom.style = this.initStyle, this.oprLayer.dom.appendChild(this.dom), this.spr.eventbus.on('zoomCanvas', this.resize, this)
    }

    show(t) {
      if (t) {
        const { top: e, left: s, width: i, height: n } = t;
        if (0 === i && 0 === n) return this.hidden(), void this.parent.hiddenResizeHandler();
        this.dom.style.top = e + 'px', this.dom.style.left = s + 'px', this.dom.style.width = i + 'px', this.dom.style.height = n + 'px', this.dom.style.border = 1 / this.canvas.ratio + 'px #007AFF solid', this.dom.style.display = 'block', this.parent.resetResizeHandler()
      } else this.hidden(), this.parent.hiddenResizeHandler()
    }

    moveBoundRect(t) {
      if (t) {
        const { top: e, left: s, width: i, height: n } = t;
        this.dom.style.top = e + 'px', this.dom.style.left = s + 'px', this.dom.style.width = i + 'px', this.dom.style.height = n + 'px', this.dom.style.border = 1 / this.canvas.ratio + 'px #007AFF solid', this.dom.style.display = 'block'
      }
    }

    hidden() {
      this.dom.style.top = '0px', this.dom.style.left = '0px', this.dom.style.width = '0px', this.dom.style.height = '0px', this.dom.style.display = 'none', this.parent.hiddenResizeHandler()
    }

    resize() {
      'block' === this.dom.style.display && (this.dom.style.border = 1 / this.canvas.ratio + 'px #007AFF solid')
    }

    destroy() {
      this.spr.eventbus.off('zoomCanvas', this.resize, this), this.parent = null, this.oprLayer = null, this.spr = null, this.canvas = null, this.dom = null, this.isShow = !1
    }
  }

  let tt = null, et = null;

  async function st(t, e, s = null) {
    if (arguments.length < 2) return void console.warn('从定义文件创建画布至少有根DOM和definition两个参数');
    const i = new Spray(t);
    return i && (i.conchOptions = s), tt = i, await i.loadFromJSON(e), i
  }

  function it() {
    return et
  }

  class Scene {
    constructor(t) {
      this.sceneIds = t, this.spr = window.spray.getInstance(), this.sceneList = this.sceneIds.map(t => this.spr.getElementById(t))
    }

    hidden() {
      this.sceneList.forEach(t => {
        t.hidden()
      })
    }

    show() {
      this.sceneList.forEach(t => {
        t.show()
      })
    }
  }

  function nt() {
    return tt
  }

  class Spray {
    constructor(t) {
      var e;
      this._running = !1,
        this.appRoot = f(t),
        this.root = b(),
        this.storage = Storage.factory(this),
        this.painter = Painter.factory(this, this.storage),
        this.eventbus = Eventbus.factory(),
        this.adapter = s,
        this.selector = Selector.factory(this),
        this.sceneTransition = SceneTransition.factory(this),
        this.mode = 'dev',
        this.eventLayerManager = null,
        this.alignmentLineStorage = null,
        this.extendManage = null,
        this._needRefresh = !1, this.ticks = [],
        this.canvas = null,
        this.width = 0, this.height = 0, this._theme = '',
        this.conch = window.conch ? window.conch : (console.warn('未检测到spray-conch，请先加载spray-conch组件库文件，否则后续用到的组件将全部无法使用'), null),
        this.conchOptions = null,
        this.whale = (e = this, window.SprayWhale ? new window.SprayWhale(e) : (console.log('未检测到spray-Whale，请先加载spray-Whale相关的js文件，否则Spray后续无法使用界面化接数方式，但可以调用Spray的API接数'), null)),
        this.sysComps = { Text: Text },
        this.appRoot.appendChild(this.root),
        this._initOptions(),
        this.resize(), this.extendManage = ExtendManage.factory(this),
        this.functionLayer = FunctionLayer.factory(this),
        this.commandManager = CommandManager.factory(this),
        this.eventbus.on('configChange', t => {
          'extendManage' === t.key && (t.value ? this.extendManage || (this.extendManage = ExtendManage.factory(this),
          this.canvas && this.extendManage.init()) : (this.extendManage && this.extendManage.destroy(), this.extendManage = null)), 'appMode' === t.key && (this.resize(), this.canvas && this.canvas.zoomCanvasToCenter())
        })
    }

    resize() {
      const { appMode: t, canvasMode: e } = T(),
        s = this.canvas && 3 === this.canvas.scaleConstraints ? 'auto' : 'hidden';
      t ? (this.width = this.appRoot.clientWidth, this.height = this.appRoot.clientHeight, 'play' === e && this.canvas && this.canvas._resizeCanvas()) : (document.body.style.overflow = 'hidden', this.width = document.documentElement.clientWidth, this.height = document.documentElement.clientHeight), this.root.style.cssText = `position: relative; width: ${ this.width }px; height: ${ this.height }px; overflow: ${ s };`
    }

    setTheme(t) {
    }

    _initOptions() {
    }

    setMode(t) {
      t && (this.mode = t)
    }

    setFilter(t, e) {
      this.canvas.setFilter(t, e)
    }

    getMode() {
      return this.mode
    }

    async setOption(t) {
      await this.canvas.destroy(), this.functionLayer.destroy(), this.functionLayer = null, await this.loadFromJSON(t)
    }

    async mergeLayer(t) {
      let e = null;
      e = g(t, 'String') ? JSON.parse(t) : JSON.parse(JSON.stringify(t));
      const s = {},
        i = this.storage._displayables.filter(t => t.id.includes('-spray-ps') || t.id.includes('cr') && t.id.includes('-sps'));
      i && i.forEach(t => {
        const e = t.id;
        let i = null;
        if (t.adapter) {
          const e = t.adapter.constructor.name, s = t.adapter.name, n = t.adapter.opts,
            r = t.adapter.subsDataChain.filter(t => !g(t[1], 'Funtion'));
          let o = null;
          'Text' === s && (o = t.adapter.bizData), i = { type: e, name: s, option: n, dataChain: r }, o && (i.data = o)
        }
        i && (s[e] = i)
      });
      const n = e.children[0], r = n.children[0].children;
      r && g(r, 'Array') && r.forEach(t => {
        s[t.option.id] && (t.option.adapter = s[t.option.id])
      });
      const o = e.option;
      this.canvas.setOptsBySprayPS(o);
      const a = this.canvas.children.filter(t => t.id.includes('sprayps') || t.id.includes('lr') && t.id.includes('-sps'));
      for (let t = 0; t < a.length; t++) await a[t].destroy();
      g(n, 'Object') && x(this.canvas, [n], !1)
    }

    setData(t) {
      if (!t) return void console.log(new Date + ' 接收到的数据格式错误，本次放弃刷新');
      if (!g(t, 'Object')) return void console.log(new Date + ' 接收到的数据格式错误，本次放弃刷新');
      Object.keys(t).forEach(e => {
        const s = this.getElementById(e);
        s && s instanceof Displayable && s.setData(t[e])
      })
    }

    getSize() {
      return this.canvas && this.canvas.getSize()
    }

    getRoot() {
      return this.root
    }

    getJSONObject() {
      if ('play' !== T().canvasMode) return this.storage.toJSON();
      console.log('如果需要获取spray定义文件，请先退出播放模式')
    }

    getJSONString() {
      if ('play' !== T().canvasMode) return JSON.stringify(this.storage.toJSON());
      console.log('如果需要获取spray定义文件，请先退出播放模式')
    }

    play() {
      R('canvasMode', 'play')
    }

    async loadFromJSON(t) {
      await this.storage.fromJSON(t), this.eventbus.emit('selectChange')
    }

    async createCanvas(t) {
      this.canvas && await this.canvas.destroy(), this.canvas = null;
      let e = Canvas.factory(this, t);
      this.canvas = e, this.extendManage && !this.extendManage.inited && this.extendManage.init(), this.functionLayer || (this.functionLayer = FunctionLayer.factory(this)), this.functionLayer.init(), this.createAlignmentLineStore()
    }

    createAlignmentLineStore() {
      this.alignmentLineStorage && this.alignmentLineStorage.destroy(), this.alignmentLineStorage = null, this.alignmentLineStorage = AlignmentLineStorage.factory(this).init()
    }

    createLayer(t) {
      if (this.canvas && this.canvas instanceof Canvas) return this.canvas.createLayer(t);
      console.warn('创建图层必须在创建画布之后')
    }

    createContainer(t) {
      let e = !1;
      const s = this.selector.getSelectElements().reverse()[0];
      return s ? s instanceof Layer ? (s.children[0] instanceof Displayable && (e = s.children[0].createContainer(t)), e) : (s && new RegExp('^(FreeContainer|FlexContainer|GridContainer)$').test(s.constructor.name) && s.parent && (e = s.parent.createContainer(t)), e) : (console.warn('请先选中图层才能在图层中创建容器'), e)
    }

    createGroup(t, e) {
      if (!g(t, 'Array')) return void console.warn('单个元素对象无法打组，目前只能为一组元素打组');
      let s = null, i = t[0];
      if (i) {
        const t = this.storage.findIndexAtParent(i);
        if (t >= 0) {
          const n = { name: e, order: t, groupId: i.groupId };
          s = p('Group', i.parent, n)
        }
      }
      return s && s.add(t), s
    }

    setBackgroundImage(t) {
      this.canvas && this.canvas.setBackgroundImage(t)
    }

    refreshImmediately() {
      this.painter && this.painter.refresh()
    }

    refresh() {
      this.start()
    }

    flush() {
      const t = this.ticks;
      for (const e of t) !e() && t.splice(t.indexOf(e), 1);
      this.refreshImmediately(), this.ticks.length || this.painter && this.painter.isRuning || (this.pause(), this.eventbus.emit('nextTick'))
    }

    addTick(t) {
      this.ticks.push(t), this.start()
    }

    show() {
      this.canvas && this.canvas.show()
    }

    hidden() {
      this.canvas && this.canvas.hidden()
    }

    async destroy(t = !0) {
      t && (await this.canvas.destroy(), this.destroy(!1)), this.pause(), this.canvas = null, this.storage = null, this.painter = null, this.adapter = null, this.eventbus = null, tt = null
    }

    _startLoop() {
      if (this._running) return;
      const t = this;
      t._running = !0, window.requestAnimationFrame((function e() {
        t._running && (window.requestAnimationFrame(e), t.flush())
      }))
    }

    start() {
      this._startLoop()
    }

    pause() {
      this._running = !1
    }
  }

  n(Spray, [class {
    constructor() {
    }

    getElementById(t) {
      return this.storage.getElementById(t)[0]
    }

    getElementByName(t) {
      return this.storage.getElementByName(t)
    }

    getAllElementList() {
      return this.storage.getDisplayableListByClassName()
    }

    getCanvas() {
      return this.canvas
    }

    getLayers() {
      return this.storage.getDisplayableListByClassName('Layer')
    }

    getLayouts() {
      return this.storage.getDisplayableListByClassName('Flex|Free|Grid')
    }

    getLayoutContainers() {
      return this.storage.getDisplayableListByClassName('FlexContainer|FreeContainer|GridContainer')
    }

    getContainers() {
      return this.storage.getDisplayableListByClassName('FlexContainer|FreeContainer|GridContainer')
    }

    getCells() {
      return this.storage.getDisplayableListByClassName('Cell')
    }

    getMouseOverElement() {
      return this.storage.mouseOverElement
    }

    getSelectedElement() {
      return this.selector.getSelectElements()
    }

    _filteElById(t, e) {
      let s = null;
      return t && g(e, 'Array') && (s = e.filter(e => e.id === t)[0]), s
    }

    _filteByName(t, e) {
      let s = null;
      return t && g(e, 'Array') && (s = e.filter(e => e.name === t)[0]), s
    }
  }]);

  class BaseAdapter {
    constructor(t, e) {
      this.parent = t, this.name = e, this.componentInstance = null, this.opts = null, this.dom = null, this.bizData = null, this.subsDataChain = [], this.complete = !1, this._subsParentData = !1, this._dirty = !1, this.initDom(), this.parent.spr.eventbus.on('canvasResizeOnPlayMode', this.resize, this), this.parent.spr.eventbus.on('dataChange', this._refreshDataHandler, this)
    }

    initDom() {
      const t = this.parent.getSize();
      let e = document.createElement('div');
      e.style.width = t.width + 'px', e.style.height = t.height + 'px', this.dom = e
    }

    init(t) {
    }

    setOption(t) {
      this.opts = v(this.opts, t || {})
    }

    update() {
    }

    resize() {
    }

    setData(t) {
      this.bizData = t
    }

    getData() {
      return this.bizData
    }

    getComponentInstance() {
      return this.componentInstance
    }

    destroy() {
      this.parent.spr.eventbus.off('canvasResizeOnPlayMode', this.resize, this), this.parent.spr.eventbus.off('dataChange', this._refreshDataHandler, this)
    }

    transferTo(t) {
    }

    transferToImmediately(t) {
    }

    exchangeTo(t) {
    }

    subsData(t, e = null) {
      let s = null, i = null;
      t instanceof Displayable && (s = t.id), g(t, 'String') && (s = t), g(e, 'String') && (i = e), g(e, 'Function') && (i = e), s && !this.subsDataChain.some(t => t[0] === s) && this.subsDataChain.push([s, i])
    }

    unSubsData(t) {
      let e = null;
      t instanceof Displayable && (e = t.id), g(t, 'String') && (e = t), null === e && (this.subsDataChain = []), e && (this.subsDataChain = this.subsDataChain.filter(t => t[0] !== e))
    }

    _componentComplete() {
      this.parent.spr.eventbus.emit('componentComplete', this.parent.id)
    }

    _refreshDataHandler(t) {
      if (0 === this.subsDataChain.length) return null;
      if (t && Reflect.has(t, 'id')) {
        let e = null;
        const s = this.subsDataChain.filter(e => e[0] === t.id)[0];
        if (g(s, 'Array') && s[0] === t.id) {
          if (s[1]) {
            if (g(s[1], 'String')) try {
              const i = s[1];
              e = new Function('return ' + i)()(t.bizData)
            } catch (i) {
              e = t.bizData[s[1]]
            }
          } else e = t.bizData;
          null !== e ? this.setData(e) : console.warn(`订阅者${ this.parent.id }==>在被订阅者${ t.id }目标数据源中未找到合规数据项`)
        }
      }
    }

    get dirty() {
      return this._dirty
    }

    set dirty(t) {
      g(t, 'Boolean') && (this._dirty = t, t && this.parent.spr && this.parent.spr.refresh())
    }
  }

  s.registAdapter('BaseAdapter', BaseAdapter);

  class ConchAdapter extends BaseAdapter {
    constructor(t, e) {
      super(t, e), this.parent.spr.eventbus.on('configChange', this._configChange, this)
    }

    static factory(t, e) {
      let s = null;
      return t instanceof Displayable && t.spr ? t.spr.conch && t.spr.conch[e] ? (s = new ConchAdapter(t, e), s) : (console.warn(`Conch没有加载或者Conch中没有ID为${ e }的组件`), s) : s
    }

    init(t) {
      this.opts = v({ prefix: '.' }, t);
      let e = null;
      if (this.parent && this.parent.spr) {
        const t = this.parent.spr.conchOptions, s = this.parent.id;
        if (t && g(t, 'Object') && (e = t[s], e && g(e, 'String'))) try {
          e = JSON.parse(e)
        } catch (t) {
          e = null, console.warn(t)
        }
      }
      let s = null;
      if (this.parent && this.parent.spr && (s = this.parent.spr.conch), !s[this.name]) return console.warn(`组件${ this.name }未检测到，请先到spray-conch中下载对应的组件包`), null;
      this.parent.getRoot().appendChild(this.dom), this.parent && !this.componentInstance && this.dom && (this.componentInstance = new s[this.name](this.dom, this.opts)), e && this.setOption(e), this.parent.staticData ? this.setData(this.parent.staticData) : this.bizData = this.componentInstance.data, this.componentInstance.render().then(() => {
        this._configChange({ key: 'canvasMode', value: T().canvasMode }), this._componentComplete()
      }).catch(t => {
        console.warn(`组件${ this.name }运行异常`, t)
      })
    }

    async update() {
      this.complete = !1, this.complete = !0, this.parent && this.parent.stopLoading()
    }

    setOption(t) {
      super.setOption(t), this.componentInstance && this.componentInstance.setOption(this.opts), this.dirty = !0
    }

    setData(t) {
      super.setData(t), this.componentInstance && this.componentInstance.setData(t)
    }

    resize() {
      const t = this.parent.getSize(), e = t.width, s = t.height;
      this.dom.style.width = e + 'px', this.dom.style.height = s + 'px', this.complete && this.componentInstance && this.componentInstance.resize && this.componentInstance.resize()
    }

    destroy() {
      super.destroy(), this.parent.spr.eventbus.off('configChange', this._configChange, this), this.componentInstance && this.componentInstance.destroy(), this.dom && this.parent.getRoot().removeChild(this.dom), this.parent = null
    }

    transferTo(t) {
      return t instanceof Displayable ? (super.transferTo(t), t.adapter ? (console.warn(`容器${ t.name }内当前有组件适配器，如需强制将组件迁移到该容器内请使用transferToImmediately`), null) : (this.parent.getRoot().removeChild(this.dom), this.parent.adapter = null, this.parent = t, this.parent.adapter = this, void this.parent.getRoot().appendChild(this.dom))) : (console.warn('transferTo参数必须是一个容器对象，请检查参数是否正确'), null)
    }

    transferToImmediately(t) {
      super.transferToImmediately(t), console.log(t instanceof Displayable), t instanceof Displayable && t.destroyAdapter(), this.transferTo(t)
    }

    exchangeTo(t) {
      if (!t.adapter) return void this.transferTo(t);
      const e = t.adapter;
      t.getRoot().removeChild(e.dom), t.adapter = null;
      const s = this.parent;
      this.transferTo(t), this.resize(), e.parent = s, s.adapter = e, s.getRoot().appendChild(e.dom), e.resize()
    }

    _configChange(t) {
      'canvasMode' === t.key && ('matrix' === t.value && (this.dom.style.pointerEvents = 'none'), 'play' === t.value && (this.dom.style.pointerEvents = 'all'))
    }
  }

  s.registAdapter('ConchAdapter', ConchAdapter);

  class EchartsAdapter extends BaseAdapter {
    constructor(t, e) {
      super(t, e)
    }

    static factory(t, e) {
      return new EchartsAdapter(t, e)
    }

    init(t) {
      this.opts = t;
      let e = window.echarts;
      e ? (this.parent && !this.componentInstance && this.dom && (this.componentInstance = e.init(this.dom)), this.parent.getRoot().appendChild(this.dom)) : console.warn('echarts不存在，请先加载echarts')
    }

    update() {
      this.componentInstance.setOption(this.opts), this.parent && this.parent.stopLoading(), this._componentComplete()
    }

    setOption(t) {
      super.setOption(t), this.dirty = !0
    }

    resize() {
      let t = arguments[0], e = this.parent.spr.height / t.height;
      const s = this.parent.getSize(), i = s.width, n = s.height * e;
      this.dom.style.width = i + 'px', this.dom.style.height = n + 'px', this.componentInstance && this.componentInstance.resize({
        width: i,
        height: n
      })
    }

    destroy() {
      super.destroy(), this.componentInstance && this.componentInstance.dispose(), this.parent = null
    }
  }

  s.registAdapter('EchartsAdapter', EchartsAdapter);

  class ThingJSAdapter extends BaseAdapter {
    constructor(t, e) {
      super(t, e), this.parent.spr.eventbus.on('configChange', this._configChange, this)
    }

    static factory(t, e) {
      let s = null;
      return window.THING ? (s = new ThingJSAdapter(t, e), s) : (console.warn('ThingJS在当前环境中检测不到，请先加载ThingJS的发布包'), s)
    }

    init(t) {
      let e = { url: '', el: this.dom };
      this.opts = v(e, t || {}), this.opts.el = this.dom, this.dom.id = this.opts.id || 'spray-thingjs';
      const s = window.THING;
      s ? (this.parent && !this.componentInstance && (this.componentInstance = new s.App(this.opts)), this.parent.getRoot().appendChild(this.dom), this._componentComplete()) : console.warn('ThingJS不存在，请先加载ThingJS的发布包')
    }

    update() {
      this.parent && this.parent.stopLoading()
    }

    resize() {
      if ('matrix' === T().canvasMode) {
        const t = this.parent.getSize();
        this.dom.style.width = t.width + 'px', this.dom.style.height = t.height + 'px'
      }
      'play' === T().canvasMode && (this.dom.style.width = this.parent.spr.width + 'px', this.dom.style.height = this.parent.spr.height + 'px')
    }

    _configChange(t) {
      'canvasMode' === t.key && ('matrix' === t.value && (this.parent.style.pointerEvents = 'none'), 'play' === t.value && (this.parent.style.pointerEvents = 'all'))
    }

    destroy() {
      super.destroy(), this.parent.spr.eventbus.off('configChange', this._configChange, this), this.componentInstance && this.componentInstance.query('*').destroyAll(), this.dom && this.parent.getRoot().removeChild(this.dom), this.parent = null
    }
  }

  s.registAdapter('ThingJSAdapter', ThingJSAdapter);

  class SysAdapter extends BaseAdapter {
    constructor(t, e) {
      super(t, e), this.dom.style.width = 'inherit', this.dom.style.height = 'inherit', this.subsData(t)
    }

    static factory(t, e) {
      let s = null;
      return t instanceof Displayable && t.spr ? (s = new SysAdapter(t, e), s) : s
    }

    init(t) {
      if (!(this.parent instanceof Displayable)) return null;
      this.opts = t;
      let e = null;
      if (this.parent && this.parent.spr && (e = this.parent.spr.sysComps), !e[this.name]) return console.warn(`系统组件${ this.name }未检测到`), null;
      this.parent.getRoot().appendChild(this.dom), this.parent && !this.componentInstance && this.dom && (this.componentInstance = new e[this.name](this.dom, this.opts)), this._componentComplete()
    }

    update() {
      this.componentInstance && this.componentInstance.render(), this.parent && this.parent.stopLoading()
    }

    setOption(t) {
      super.setOption(t), this.componentInstance && this.componentInstance.setOption(this.opts), this.dirty = !0
    }

    setData(t) {
      super.setData(t), this.componentInstance && this.componentInstance.setData(t), this.dirty = !0
    }

    resize() {
      this.componentInstance && this.componentInstance.resize()
    }

    destroy() {
      super.destroy(), this.componentInstance && this.componentInstance.destroy(), this.dom && this.parent.getRoot().removeChild(this.dom), this.parent = null
    }
  }

  s.registAdapter('SysAdapter', SysAdapter);
  const rt = [];

  function ot(t = 1920, e = 1080, s = 2, i = 2) {
    const n = [], r = (e - (100 + 15 * i)) / i, o = (t - 15 * (s + 1)) / s;
    for (let t = 0; t < s; t++) for (let e = 0; e < i; e++) {
      const s = {};
      s.top = 100 + e * r + 15 * e, s.left = 15 * (t + 1) + t * o, s.width = o, s.height = r, s.constraints = E.TOPCENTER, n.push(s)
    }
    return n.push(at(t)), n
  }

  function at(t) {
    return { top: 0, left: 0, width: t, height: 110, constraints: E.TOPCENTER }
  }

  rt.push((function (t = 1920, e = 1080) {
    const s = [], i = (e - 180) / 3, n = 380 * i / 300;
    for (let t = 0; t < 3; t++) {
      const e = { style: { backgroundImage: 'static/images/container.png' } };
      e.top = t * i + 15 * t + 100, e.left = 15, e.width = n, e.height = i, e.constraints = E.CENTERLEFT, s.push(e)
    }
    for (let e = 0; e < 3; e++) {
      const r = { style: { backgroundImage: 'static/images/container.png' } };
      r.top = e * i + 15 * e + 100, r.left = t - 15 - n, r.width = n, r.height = i, r.constraints = E.CENTERRIGHT, s.push(r)
    }
    return s.push(at(t)), s
  }), (function (t = 1920, e = 1080) {
    const s = [], i = (e - 145) / 3, n = 380 * i / 300;
    for (let t = 0; t < 3; t++) {
      const e = {};
      e.top = t * i + 15 * t + 100, e.left = 15, e.width = n, e.height = i, e.constraints = E.CENTERLEFT, s.push(e)
    }
    for (let e = 0; e < 3; e++) {
      const r = {};
      r.top = e * i + 15 * e + 100, r.left = t - 15 - n, r.width = n, r.height = i, r.constraints = E.CENTERRIGHT, s.push(r)
    }
    const r = 200 * i / 300,
      o = { top: e - 15 - r, left: 30 + n, width: t - 2 * n - 60, height: r, constraints: E.BOTTOMCENTER };
    return s.push(o), s.push(at(t)), s
  }), (function (t = 1920, e = 1080) {
    const s = [], i = (e - 165) / 2, n = (e - 180) / 3, r = 380 * i / 458;
    for (let t = 0; t < 2; t++) {
      const e = {};
      e.top = t * i + 15 * t + 100, e.left = 15, e.width = r, e.height = i, e.constraints = E.CENTERLEFT, s.push(e)
    }
    for (let e = 0; e < 3; e++) {
      const i = {};
      i.top = e * n + 15 * e + 100, i.left = t - 15 - r, i.width = r, i.height = n, i.constraints = E.CENTERRIGHT, s.push(i)
    }
    return s.push(at(t)), s
  }), (function (t = 1920, e = 1080) {
    const s = [], i = (e - 165) / 2, n = (e - 180) / 3, r = 380 * i / 458;
    for (let e = 0; e < 2; e++) {
      const n = {};
      n.top = e * i + 15 * e + 100, n.left = t - 15 - r, n.width = r, n.height = i, n.constraints = E.CENTERLEFT, s.push(n)
    }
    for (let t = 0; t < 3; t++) {
      const e = {};
      e.top = t * n + 15 * t + 100, e.left = 15, e.width = r, e.height = n, e.constraints = E.CENTERRIGHT, s.push(e)
    }
    return s.push(at(t)), s
  }), (function (t = 3840, e = 1080) {
    const s = [], i = (e - 165) / 2, n = 763 * i / 458;
    for (let t = 0; t < 2; t++) {
      const e = {};
      e.top = t * i + 15 * t + 100, e.left = 15, e.width = n, e.height = i, e.constraints = E.CENTERLEFT, s.push(e)
    }
    for (let e = 0; e < 2; e++) {
      const r = {};
      r.top = e * i + 15 * e + 100, r.left = t - 15 - n, r.width = n, r.height = i, r.constraints = E.CENTERRIGHT, s.push(r)
    }
    return s.push(at(t)), s
  }), (function (t = 1920, e = 1080) {
    const s = [], i = (e - 180) / 3, n = (e - 165) / 2, r = 380 * i / 300, o = 2 * i + 15,
      a = { top: 100, left: 15, width: r, height: o, constraints: E.CENTERLEFT },
      h = { top: 100 + o + 15, left: 15, width: r, height: i, constraints: E.CENTERLEFT };
    for (let e = 0; e < 2; e++) {
      const i = {};
      i.top = e * n + 15 * e + 100, i.left = t - 15 - r, i.width = r, i.height = n, i.constraints = E.CENTERRIGHT, s.push(i)
    }
    return s.push(a), s.push(h), s.push(at(t)), s
  }), (function (t = 1920, e = 1080) {
    const s = [], i = (e - 180) / 3, n = 380 * i / 300, r = 2 * i + 15,
      o = { top: 100, left: 15, width: n, height: r, constraints: E.CENTERLEFT },
      a = { top: 100 + r + 15, left: 15, width: n, height: i, constraints: E.CENTERLEFT },
      h = { top: 100, left: t - 15 - n, width: n, height: e - 100 - 50, constraints: E.CENTERRIGHT };
    return s.push(o), s.push(a), s.push(h), s.push(at(t)), s
  }), (function (t = 1920, e = 1080) {
    const s = [], i = (e - 165) / 2, n = 380 * i / 458;
    for (let e = 0; e < 2; e++) {
      const r = {};
      r.top = e * i + 15 * e + 100, r.left = t - 15 - n, r.width = n, r.height = i, r.constraints = E.CENTERRIGHT, s.push(r)
    }
    const r = { top: 100, left: 15, width: n, height: e - 100 - 50, constraints: E.CENTERLEFT };
    return s.push(r), s.push(at(t)), s
  }), (function (t = 1920, e = 1080) {
    const s = [], i = e - 150, n = 380 * i / 930,
      r = { top: 100, left: 15, width: n, height: i, constraints: E.CENTERLEFT },
      o = { top: 100, left: t - 15 - n, width: n, height: i, constraints: E.CENTERRIGHT };
    return s.push(r), s.push(o), s.push(at(t)), s
  }), (function (t = 1920, e = 1080) {
    return ot(t, e, 2, 2)
  }), (function (t = 1920, e = 1080) {
    return ot(t, e, 3, 2)
  }), (function (t = 1920, e = 1080) {
    return ot(t, e, 3, 3)
  }));

  class Free extends Displayable {
    constructor(t, e) {
      super(t, e);
      this.typeName = 'Free布局', this.opts = v({
        id: null,
        name: null,
        width: 'inherit',
        height: 'inherit',
        order: 0,
        lock: { left: !1, top: !1, width: !0, height: !0 },
        style: { position: 'relative' },
        containerList: []
      }, this._options), this.style.setOption(this.opts.style), this.initId('layout'), this.width = this.opts.width, this.height = this.opts.height, this.verifyOpts(), this.initDom(), this.opts.containerList.forEach(t => {
        this.createContainer(t)
      })
    }

    static factory(t, e) {
      return new Free(t, e)
    }

    verifyOpts() {
    }

    createContainer(t) {
      return p('FreeContainer', this, t)
    }

    getContainerByName(t) {
      return this.children.filter(e => e.name === t)[0]
    }

    getContainerById(t) {
      return this.children.filter(e => e.id === t)[0]
    }

    getContainerByIndex(t) {
      return this.children[t]
    }

    getContainerAll() {
      return this.children
    }

    toJSON() {
      const t = super.toJSON();
      return t.type = 'Free', t
    }
  }

  u('Free', Free);

  class FreeContainer extends Displayable {
    constructor(t, e) {
      super(t, e);
      const s = {
        id: null,
        name: null,
        width: 100,
        height: 100,
        order: 0,
        freeOnPlay: !1,
        constraints: E.TOPLEFT,
        top: 0,
        left: 0,
        lock: { left: !1, top: !1, width: !1, height: !1 },
        style: { position: 'absolute', backgroundRepeat: 'no-repeat', backgroundSize: '100% 100%' }
      };
      this.typeName = 'Free布局容器', this.moveLock = {
        x: !1,
        y: !1
      }, this.opts = v(s, this._options), this.style.setOption(this.opts.style), this.width = this.opts.width, this.height = this.opts.height, this.opts.sceneAnimator && (this.sceneAnimator.enter = this.opts.sceneAnimator.enter, this.sceneAnimator.leave = this.opts.sceneAnimator.leave), this.alimentLines = null, this.resetHandlerTimer = null, this.initId('container'), this.verifyOpts(), this.initDom(), this.initAnimator(), this.initAlignmentLine(), this.spr.eventbus.on('canvasResizeOnPlayMode', this.resize, this)
    }

    resize() {
      D(this, arguments[0])
    }

    static factory(t, e) {
      return new FreeContainer(t, e)
    }

    verifyOpts() {
    }

    updateAlignmentLines(t, e) {
      this.alimentLines = AlignmentLine.factory(t, e)
    }

    initAlignmentLine() {
      this.updateAlignmentLines(this, this.opts), this.spr.alignmentLineStorage.addLine(this.opts, this.alimentLines), this.adsorb = Adsorb.factory(this), this.distanceTip = DistanceTip.factory(this)
    }

    moveInGroup(t) {
      if (this.groupId) {
        const t = this.spr.getElementById(this.groupId);
        t && t.remove(this)
      }
      t && t.add(this)
    }

    moveOutGroup(t) {
    }

    toJSON() {
      const t = super.toJSON();
      return t.type = 'FreeContainer', t.option.constraints = this.opts.constraints, this.opts.scaleConstraints && (t.option.scaleConstraints = this.opts.scaleConstraints), t.option.top = this.opts.top, t.option.left = this.opts.left, t
    }

    setTop(t) {
      this.clearResetHandlerTimer(), g(t, 'Number') && t !== this.opts.top && (this.isSelected && this.spr.functionLayer.hiddenResizeHandler(), this.opts.top = t, this.style.translate = [this.opts.left, this.opts.top], this.isSelected && this.createResetHandlerTimer())
    }

    setLeft(t) {
      this.clearResetHandlerTimer(), g(t, 'Number') && t !== this.opts.left && (this.isSelected && this.spr.functionLayer.hiddenResizeHandler(), this.opts.left = t, this.style.translate = [this.opts.left, this.opts.top], this.isSelected && this.createResetHandlerTimer())
    }

    clearResetHandlerTimer() {
      window.clearTimeout(this.resetHandlerTimer), this.resetHandlerTimer = null
    }

    createResetHandlerTimer() {
      this.resetHandlerTimer = setTimeout(() => {
        this.spr.eventbus.emit('containerMoveEnd', { displayable: this })
      }, 500)
    }

    get top() {
      return this.opts.top
    }

    set top(t) {
      g(t, 'Number') && t !== this.opts.top && (this.opts.top = t, this.style.translate = [this.opts.left, this.opts.top])
    }

    get left() {
      return this.opts.left
    }

    set left(t) {
      g(t, 'Number') && t !== this.opts.left && (this.opts.left = t, this.style.translate = [this.opts.left, this.opts.top])
    }

    get constraints() {
      return this.opts.constraints
    }

    set constraints(t) {
      this.opts.constraints = t
    }

    get scaleConstraints() {
      return this.opts.scaleConstraints
    }

    set scaleConstraints(t) {
      this.opts.scaleConstraints = t
    }

    get freeOnPlay() {
      return this.opts.freeOnPlay
    }

    set freeOnPlay(t) {
      g(t, 'Boolean') || (this.opts.freeOnPlay = t)
    }
  }

  u('FreeContainer', FreeContainer);

  class Group {
    constructor(t, e) {
      this.parent = t;
      const s = { id: A('group'), name: '未命名组', order: 1, groupId: null };
      this.opts = v(s, e), this.addSelfToStorage()
    }

    static factory(t, e) {
      return new Group(t, e)
    }

    show() {
      const t = this.getAllElsInGroups();
      for (let e = 0; e < t.length; e++) t[e].show()
    }

    hidden() {
      const t = this.getAllElsInGroups();
      for (let e = 0; e < t.length; e++) t[e].hidden()
    }

    addSelfToStorage() {
      this.parent && this.parent.spr && this.parent.spr.storage.addElToStorage(this)
    }

    add(t) {
      if (this.parent && t) if (t.every(t => g(t, 'String'))) {
        const e = [];
        t.forEach(t => {
          let s = null;
          this.parent && this.parent.spr && (s = this.parent.spr.getElementById(t)), s && e.push(s)
        }), e.length > 0 && this.parent.spr.storage.moveDisplayables(e, this, 'in')
      } else this.parent && this.parent.spr && this.parent.spr.storage.moveDisplayables(t, this, 'in')
    }

    dismiss() {
      if (!this.parent) return;
      const t = this.parent.spr.storage, e = t.getElementByGroup(this);
      g(e, 'Array') && e.forEach(e => {
        t.moveDisplayable(e, this, 'front')
      }), this.destroySelf()
    }

    select() {
    }

    deselect() {
    }

    contain(t, e) {
      const s = this.getBoundRect();
      return s && t >= s.left && t <= s.right && e >= s.top && e <= s.bottom
    }

    getBoundRect() {
      if (!this.parent) return;
      if (!this.parent.spr) return;
      const t = [], e = [], s = [], i = [], n = this.parent.spr.storage.getAllElementByGroupExcludeGroup(this);
      g(n, 'Array') && n.forEach(n => {
        t.push(n.top), e.push(n.left), s.push(n.left + n.width), i.push(n.top + n.height)
      });
      const r = Math.min(...t) || 0, o = Math.min(...e) || 0, a = Math.max(...s) || 0, h = Math.max(...i) || 0;
      return { top: r, left: o, right: a, bottom: h, width: a - o || 0, height: h - r || 0 }
    }

    getSelectLockStatus() {
      if (!this.parent) return;
      let t = !1;
      const e = this.parent.spr.storage.getAllElementByGroupExcludeGroup(this);
      return g(e, 'Array') && e.forEach(e => {
        'FreeContainer' === e.constructor.name && (t = e.getLockStatusByPropName('top') || e.getLockStatusByPropName('left'))
      }), t
    }

    getAllElsInGroups() {
      if (!this.parent) return;
      return this.parent.spr.storage.getAllElementByGroupExcludeGroup(this)
    }

    getJSONWithChild() {
      const t = [];
      const e = this.parent.spr.storage.findGroupParentArr(this).find(t => t[0] && t[0].id === this.id).flat(1 / 0);
      return e.sort((t, e) => t.order - e.order), e.forEach(e => {
        const s = e.toJSON();
        s && t.push(s)
      }), t
    }

    saveInfoPreMouseAction() {
      if (!this.parent) return;
      this.parent.spr.storage.getAllElementByGroupExcludeGroup(this).forEach(t => {
        'FreeContainer' === t.constructor.name && t.saveInfoPreMouseAction()
      })
    }

    moveGroupElsByMouse(t, e) {
      if (!this.parent) return;
      const s = this.parent.spr.storage.getAllElementByGroupExcludeGroup(this),
        i = this.parent.spr.alignmentLineStorage, n = i && i.getAdsorbStatus('top'), r = i && i.getAdsorbStatus('left');
      s.forEach(s => {
        if ('FreeContainer' === s.constructor.name) {
          const i = s.oldOptsRecord;
          !n && i && !s.getLockStatusByPropName('top') && (s.top = Math.floor(e + i.top)), !r && i && !s.getLockStatusByPropName('left') && (s.left = Math.floor(t + i.left))
        }
      })
    }

    moveGroupElsByKeyboard(t, e) {
      if (!this.parent) return;
      this.parent.spr.storage.getAllElementByGroupExcludeGroup(this).forEach(s => {
        'FreeContainer' === s.constructor.name && !s.getLockStatusByPropName(t) && (s[t] += e)
      })
    }

    async destroy() {
      if (!this.parent) return;
      const t = this.parent.spr.storage.getAllElementByGroupIncludeGroup(this);
      if (t.sort((t, e) => t.order - e.order), g(t, 'Array')) {
        const e = t.filter(t => 'Group' === t.constructor.name),
          s = t.filter(t => 'FreeContainer' === t.constructor.name);
        for (let t of s) await t.destroy();
        e.reverse(), e.forEach(t => {
          t.destroySelf()
        })
      }
    }

    destroySelf() {
      this.parent && (this.parent.spr.storage.deleteElFromStorage(this), this.parent.removeChildren(this), this.parent = null)
    }

    duplicate() {
      if (!this.parent) return;
      let t = null, e = this.parent.spr.storage.findGroupParentArr(this).find(t => t[0] && t[0].id === this.id);
      const s = {}, i = [];
      if (e && g(e, 'Array')) {
        e = e.flat(1 / 0);
        e.filter(t => 'Group' === t.constructor.name).forEach(t => {
          const e = A('group');
          s[t.id] = e
        }), e.forEach(t => {
          const e = t.toJSON();
          e && i.push(e)
        })
      }
      if (i.forEach(t => {
        if ('Group' === t.type) {
          const e = s[t.option.id];
          e && (t.option.id = e)
        }
        if ('FreeContainer' === t.type) {
          const e = s[t.option.groupId];
          e && (t.option.groupId = e)
        }
        if ('Group' === t.type) {
          const e = s[t.option.groupId];
          e && (t.option.groupId = e)
        }
      }), i.length > 0) {
        const e = i[0].option.id;
        L(this.parent, i, !0), e && (t = e)
      }
      return t
    }

    toJSON() {
      const t = { type: 'Group' }, e = {};
      return e.id = this.id, e.name = this.name, e.order = this.order, e.groupId = this.groupId, t.option = e, t
    }

    get order() {
      return this.opts.order
    }

    set order(t) {
      g(t, 'Number') && (this.opts.order = t)
    }

    get name() {
      return this.opts.name
    }

    set name(t) {
      g(t, 'String') && (this.opts.name = t)
    }

    get groupId() {
      return this.opts.groupId
    }

    set groupId(t) {
      this.opts.groupId = t
    }

    get id() {
      return this.opts.id
    }

    set id(t) {
      this.opts.id = t
    }

    get left() {
      return this.getBoundRect().left
    }

    get right() {
      return this.getBoundRect().right
    }

    get top() {
      return this.getBoundRect().top
    }

    get bottom() {
      return this.getBoundRect().bottom
    }

    get width() {
      return this.getBoundRect().width
    }

    get height() {
      return this.getBoundRect().height
    }
  }

  u('Group', Group);

  class Node {
    constructor(t, e, s) {
      if (this._uid = o('node'), this.dom = null, this.list = [], this.nodeList = [], this.refs = {}, this._eventMap = {
        click: [],
        dblclick: [],
        mouseEnter: [],
        mouseLeave: [],
        mousewheel: [],
        mouseout: [],
        mouseup: [],
        mousedown: [],
        mousemove: [],
        contextmenu: [],
        mouseover: []
      }, this.dom = document.createElement(t), s.length) for (const t of s) g(t, 'Object') && t.dom instanceof HTMLElement ? (this.dom.appendChild(t.dom), this.list = [...this.list, ...t.list || []], this.nodeList = [...this.nodeList, ...t.nodeList || []], this.refs = { ...this.refs, ...t.refs || {} }, this._eventMap.click = [...this._eventMap.click, ...t._eventMap.click || []], this._eventMap.mouseEnter = [...this._eventMap.mouseEnter, ...t._eventMap.mouseEnter || []], this._eventMap.mouseLeave = [...this._eventMap.mouseLeave, ...t._eventMap.mouseLeave || []]) : g(t, 'Array') ? t.forEach(t => {
        this.dom.appendChild(t.dom), this.list = [...this.list, ...t.list || []], this.nodeList = [...this.nodeList, ...t.nodeList || []], this.refs = { ...this.refs, ...t.refs || {} }, this._eventMap.click = [...this._eventMap.click, ...t._eventMap.click || []], this._eventMap.mouseEnter = [...this._eventMap.mouseEnter, ...t._eventMap.mouseEnter || []], this._eventMap.mouseLeave = [...this._eventMap.mouseLeave, ...t._eventMap.mouseLeave || []]
      }) : this.dom.innerText = t;
      if (e) {
        if (e.style && (this.dom.style.cssText = e.style), e.ref && (this.refs[e.ref] = this.dom), e.click) {
          const t = e.click, s = e => {
            t(e)
          };
          this._eventMap.click.push({ dom: this.dom, event: s }), this.dom.addEventListener('click', s), delete e.click
        }
        if (e.mouseEnter) {
          const t = e.mouseEnter, s = e => {
            t(e)
          };
          this._eventMap.mouseEnter.push({
            dom: this.dom,
            event: s
          }), this.dom.addEventListener('mouseenter', s), delete e.mouseEnter
        }
        if (e.mouseLeave) {
          const t = e.mouseLeave, s = e => {
            t(e)
          };
          this._eventMap.mouseLeave.push({
            dom: this.dom,
            event: s
          }), this.dom.addEventListener('mouseleave', s), delete e.mouseLeave
        }
        delete e.style, delete e.ref, Object.keys(e).forEach(t => {
          this.dom.setAttribute(t, e[t])
        })
      }
      this.list.push(this.dom), this.nodeList.push(this)
    }

    static factory(t, e, s) {
      return new Node(t, e, s)
    }

    destroy() {
      return Object.keys(this._eventMap).forEach(t => {
        this._eventMap[t].forEach(e => {
          e.dom.removeEventListener(t.toLowerCase(), e.event)
        })
      }), this.dom = null, this.list = null, this.nodeList = null, this.refs = null, this._eventMap = null, !0
    }
  }

  let ht = Eventbus.factory(),
    lt = { Canvas: Canvas, Layer: Layer, Free: Free, FreeContainer: FreeContainer, Group: Group };
  t.BaseAdapter = BaseAdapter, t.ConchAdapter = ConchAdapter, t.EchartsAdapter = EchartsAdapter, t.Element = lt, t.Spray = Spray, t.SysAdapter = SysAdapter, t.ThingJSAdapter = ThingJSAdapter, t.adapter = s, t.addSceneById = function (t, e = null) {
    let s = null, i = !1;
    const n = it().find(e => e.id === t);
    if (n) {
      let t = null, e = null;
      try {
        t = n.scene
      } catch (t) {
        i = !0
      }
      if (t && (e = t.children), Array.isArray(e)) {
        const t = [];
        e.forEach(e => {
          if ('object' == typeof e) {
            const s = x(nt().canvas, [e], !1);
            t.push(s)
          }
        }), t.length || (i = !0, console.log('没有新场景编号')), s = new Scene(t)
      } else i = !0
    }
    try {
      'function' == typeof e && e(i, s)
    } catch (t) {
      console.error(t)
    }
    return s
  }, t.config = z, t.createElement = (...t) => {
    const [e, s, ...i] = t;
    return Node.factory(e, s, i)
  }, t.destroy = function (t) {
    t && t.destroy && t.destroy()
  }, t.eventbus = ht, t.getInstance = nt, t.getRegisteScene = it, t.init = function (t, e) {
    if (arguments.length < 1) return void console.warn('初始化spray至少需要传入一个DOM节点作为参数');
    const s = new Spray(t);
    return tt = s, s.createCanvas(e || {}), s
  }, t.initFromJSON = st, t.initFromRegiste = async function (t, e, s = 'id') {
    if (!et) return console.warn('没有获取已注册的定义文件，请在spray.js加载完毕后调用spray.registeScene注册场景定义文件'), Promise.resolve(!1);
    let i = null, n = null, r = null, o = null, a = null;
    if ('id' === s && (o = et.find(t => t && t.id === e)), 'index' === s && (o = et[e]), o && (i = o.scene, a = i.conchOptions, n = o.script), i && (r = await st(t, i, a)), r && g(n, 'Function')) try {
      n()
    } catch (t) {
      console.warn(t)
    }
    return r
  }, t.registeScene = function (t) {
    return t && (et = t), et
  }, t.register = m, t.tool = I, t.useTemplate = function (t, e) {
    if (!e || 'Spray' !== e.constructor.name) return;
    if (!rt[t]) return;
    const s = e.canvas.width, i = e.canvas.height, n = rt[t](s, i), r = e.createLayer().createLayout('Free');
    return n.forEach(t => {
      r.createContainer(t)
    }), !0
  }, t.version = '1.6.0', Object.defineProperty(t, '__esModule', { value: !0 })
}));
